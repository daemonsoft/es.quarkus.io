# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-04-22 09:16+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: es_ES\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_versions/2.2/guides/kafka.adoc:6
#, fuzzy, no-wrap
msgid "Apache Kafka Reference Guide"
msgstr "Guía de referencia de Apache Kafka"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:16
#, fuzzy
msgid "This reference guide demonstrates how your Quarkus application can utilize SmallRye Reactive Messaging to interact with Apache Kafka."
msgstr "Esta guía de referencia demuestra cómo su aplicación Quarkus puede utilizar SmallRye Reactive Messaging para interactuar con Apache Kafka."

#. type: Title ==
#: upstream/_versions/2.2/guides/kafka.adoc:17
#, fuzzy, no-wrap
msgid "Introduction"
msgstr "Introducción"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:22
#, fuzzy
msgid "https://kafka.apache.org[Apache Kafka] is a popular open-source distributed event streaming platform.  It is used commonly for high-performance data pipelines, streaming analytics, data integration, and mission-critical applications.  Similar to a message queue, or an enterprise messaging platform, it lets you:"
msgstr "link:https://kafka.apache.org[Apache Kafka] es una popular plataforma de streaming de eventos distribuidos de código abierto. Se utiliza habitualmente para canalizaciones de datos de alto rendimiento, análisis de streaming, integración de datos y aplicaciones de misión crítica. Similar a una cola de mensajes, o una plataforma de mensajería empresarial, le permite:"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:24
#, fuzzy, no-wrap
msgid "*publish* (write) and *subscribe* to (read) streams of events, called _records_.\n"
msgstr "*publicar* (escribir) y *suscribirse* (leer) a flujos de eventos, denominados _registros_ ."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:25
#, fuzzy, no-wrap
msgid "*store* streams of records durably and reliably inside _topics_.\n"
msgstr "*almacenar* flujos de registros de forma duradera y fiable dentro de _los temas_ ."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:26
#, fuzzy, no-wrap
msgid "*process* streams of records as they occur or retrospectively.\n"
msgstr "*procesar* flujos de registros a medida que se producen o retrospectivamente."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:28
#, fuzzy
msgid "And all this functionality is provided in a distributed, highly scalable, elastic, fault-tolerant, and secure manner."
msgstr "Y toda esta funcionalidad se proporciona de forma distribuida, altamente escalable, elástica, tolerante a fallos y segura."

#. type: Title ==
#: upstream/_versions/2.2/guides/kafka.adoc:29
#, fuzzy, no-wrap
msgid "Quarkus Extension for Apache Kafka"
msgstr "Extensión de Quarkus para Apache Kafka"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:33
#, fuzzy
msgid "Quarkus provides support for Apache Kafka through https://smallrye.io/smallrye-reactive-messaging/[SmallRye Reactive Messaging] framework.  Based on Eclipse MicroProfile Reactive Messaging specification 2.0, it proposes a flexible programming model bridging CDI and event-driven."
msgstr "Quarkus proporciona soporte para Apache Kafka a través del marco de mensajería reactiva link:https://smallrye.io/smallrye-reactive-messaging/[SmallRye] . Basado en la especificación 2.0 de Eclipse MicroProfile Reactive Messaging, propone un modelo de programación flexible que tiende un puente entre la CDI y la basada en eventos."

#. type: delimited block =
#: upstream/_versions/2.2/guides/kafka.adoc:38
#, fuzzy
msgid "This guide provides an in-depth look on Apache Kafka and SmallRye Reactive Messaging framework.  For a quick start take a look at xref:kafka-reactive-getting-started.adoc[Getting Started to SmallRye Reactive Messaging with Apache Kafka]."
msgstr "Esta guía proporciona una mirada en profundidad sobre Apache Kafka y el framework SmallRye Reactive Messaging. Para un inicio rápido eche un vistazo a xref:kafka-reactive-getting-started.adoc[Introducción a SmallRye Reactive Messaging con Apache Kafka] ."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:41
#, fuzzy
msgid "You can add the `smallrye-reactive-messaging-kafka` extensions to your project by running the following command in your project base directory:"
msgstr "Puede añadir las extensiones de `smallrye-reactive-messaging-kafka` a su proyecto ejecutando el siguiente comando en el directorio base de su proyecto:"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:45
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"smallrye-reactive-messaging-kafka\"\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:48
#, fuzzy
msgid "This will add the following to your `pom.xml`:"
msgstr "Esto añadirá lo siguiente a su `pom.xml`:"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:55
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-smallrye-reactive-messaging-kafka</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/2.2/guides/kafka.adoc:57
#, fuzzy, no-wrap
msgid "Configuring Smallrye Kafka Connector"
msgstr "Configuración del conector Kafka de Smallrye"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:60
#, fuzzy
msgid "Because Smallrye Reactive Messaging framework supports different messaging backends like Apache Kafka, AMQP, Apache Camel, JMS, MQTT, etc., it employs a generic vocabulary:"
msgstr "Dado que el marco de mensajería reactiva de Smallrye soporta diferentes backends de mensajería como Apache Kafka, AMQP, Apache Camel, JMS, MQTT, etc., emplea un vocabulario genérico:"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:62
#, fuzzy
msgid "Applications send and receive *messages*. A message wraps a _payload_ and can be extended with some _metadata_. With the Kafka connector, a _message_ corresponds to a Kafka _record_."
msgstr "Las aplicaciones envían y reciben *mensajes*. Un mensaje envuelve una _carga útil_ y puede ampliarse con algunos _metadatos_. Con el conector Kafka, un _mensaje_ corresponde a un _registro_ Kafka."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:63
#, fuzzy
msgid "Messages transit on *channels*. Application components connect to channels to publish and consume messages. The Kafka connector maps _channels_ to Kafka _topics_."
msgstr "Los mensajes transitan por *los* canales. Los componentes de la aplicación se conectan a los canales para publicar y consumir mensajes. El conector Kafka asigna _canales_ a _temas_ Kafka."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:64
#, fuzzy
msgid "Channels are connected to message backends using *connectors*. Connectors are configured to map incoming messages to a specific channel (consumed by the application) and collect outgoing messages sent to a specific channel. Each connector is dedicated to a specific messaging technology. For example, the connector dealing with Kafka is named `smallrye-kafka`."
msgstr "Los canales se conectan a los backends de mensajes mediante *conectores*. Los conectores se configuran para asignar los mensajes entrantes a un canal específico (consumido por la aplicación) y recoger los mensajes salientes enviados a un canal específico. Cada conector está dedicado a una tecnología de mensajería específica. Por ejemplo, el conector que se ocupa de Kafka se llama `smallrye-kafka`."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:66
#, fuzzy
msgid "A minimal configuration for the Kafka connector with an incoming channel looks like the following:"
msgstr "Una configuración mínima para el conector Kafka con un canal de entrada tiene el siguiente aspecto:"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:71
#, no-wrap
msgid ""
"%prod.kafka.bootstrap.servers=kafka:9092 <1>\n"
"mp.messaging.incoming.prices.connector=smallrye-kafka <2>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:76
msgid "Configure the broker location for the production profile. You can configure it globally or per channel using `mp.messaging.incoming.$channel.bootstrap.servers` property.  In dev mode and when running tests, link:kafka-dev-services[Dev Services for Kafka] automatically starts a Kafka broker.  When not provided this property defaults to `localhost:9092`."
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:77
#, fuzzy
msgid "Configure the connector to manage the prices channel. By default the topic name is same as the channel name. You can configure the topic attribute to override it."
msgstr "Configure el conector para gestionar el canal de precios. Por defecto, el nombre del tema es el mismo que el del canal. Puede configurar el atributo de tema para anularlo."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:79
#, fuzzy
msgid "The `%prod` prefix indicates that the property is only used when the application runs in prod mode (so not in dev or test). Refer to the xref:config-reference.adoc#profiles[Profile documentation] for further details."
msgstr "El prefijo `%prod` indica que la propiedad sólo se utiliza cuando la aplicación se ejecuta en modo prod (es decir, no en dev o test). Consulte la  link:config-reference.html#profiles[documentación del perfil] para obtener más detalles."

#. type: Title ==
#: upstream/_versions/2.2/guides/kafka.adoc:80
#, fuzzy, no-wrap
msgid "Receiving messages from Kafka"
msgstr "Recepción de mensajes de Kafka"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:83
#, fuzzy
msgid "Continuing from the previous minimal configuration, your Quarkus application can receive message payload directly:"
msgstr "Continuando con la configuración mínima anterior, su aplicación Quarkus puede recibir la carga útil de los mensajes directamente:"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:87
#: upstream/_versions/2.2/guides/kafka.adoc:1683
#: upstream/_versions/2.2/guides/kafka.adoc:1764
#, no-wrap
msgid "import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:89
#: upstream/_versions/2.2/guides/kafka.adoc:871
#: upstream/_versions/2.2/guides/kafka.adoc:918
#: upstream/_versions/2.2/guides/kafka.adoc:941
#: upstream/_versions/2.2/guides/kafka.adoc:1081
#: upstream/_versions/2.2/guides/kafka.adoc:1762
#, no-wrap
msgid "import javax.enterprise.context.ApplicationScoped;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:92
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class PriceConsumer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:97
#, no-wrap
msgid ""
"    @Incoming(\"prices\")\n"
"    public void consume(double price) {\n"
"        // process your price.\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:99
#: upstream/_versions/2.2/guides/kafka.adoc:247
#: upstream/_versions/2.2/guides/kafka.adoc:512
#: upstream/_versions/2.2/guides/kafka.adoc:538
#: upstream/_versions/2.2/guides/kafka.adoc:619
#: upstream/_versions/2.2/guides/kafka.adoc:931
#: upstream/_versions/2.2/guides/kafka.adoc:959
#: upstream/_versions/2.2/guides/kafka.adoc:1043
#: upstream/_versions/2.2/guides/kafka.adoc:1100
#: upstream/_versions/2.2/guides/kafka.adoc:1468
#: upstream/_versions/2.2/guides/kafka.adoc:1671
#: upstream/_versions/2.2/guides/kafka.adoc:1752
#: upstream/_versions/2.2/guides/kafka.adoc:1780
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:102
#, fuzzy
msgid "There are several other ways your application can consume incoming messages:"
msgstr "Existen otras formas en las que tu aplicación puede consumir los mensajes entrantes:"

#. type: Block title
#: upstream/_versions/2.2/guides/kafka.adoc:103
#, fuzzy, no-wrap
msgid "Message"
msgstr "Mensaje"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:115
#, no-wrap
msgid ""
"@Incoming(\"prices\")\n"
"public CompletionStage<Void> consume(Message<Double> msg) {\n"
"    // access record metadata\n"
"    var metadata = msg.getMetadata(IncomingKafkaRecordMetadata.class).orElseThrow();\n"
"    // process the message payload.\n"
"    double price = msg.getPayload();\n"
"    // Acknowledge the incoming message (commit the offset)\n"
"    return msg.ack();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:119
#, fuzzy
msgid "The `Message` type lets the consuming method access the incoming message metadata and handle the acknowledgment manually.  We'll explore different acknowledgment strategies in <<commit-strategies>>."
msgstr "El tipo `Message` permite al método consumidor acceder a los metadatos del mensaje entrante y gestionar el acuse de recibo manualmente. Exploraremos diferentes estrategias de acuse de recibo en <<commit-strategies>> ."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:121
#, fuzzy
msgid "If you want to access the Kafka record objects directly, use:"
msgstr "Si quiere acceder directamente a los objetos de registro de Kafka, utilice"

#. type: Block title
#: upstream/_versions/2.2/guides/kafka.adoc:122
#, fuzzy, no-wrap
msgid "ConsumerRecord"
msgstr "ConsumerRecord"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:133
#, no-wrap
msgid ""
"@Incoming(\"prices\")\n"
"public void consume(ConsumerRecord<String, Double> record) {\n"
"    String key = record.key(); // Can be `null` if the incoming record has no key\n"
"    String value = record.value(); // Can be `null` if the incoming record has no value\n"
"    String topic = record.topic();\n"
"    int partition = record.partition();\n"
"    // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:137
#, fuzzy
msgid "`ConsumerRecord` is provided by the underlying Kafka client and can be injected directly to the consumer method.  Another simpler approach consists in using `Record`:"
msgstr "`ConsumerRecord` lo proporciona el cliente Kafka subyacente y puede inyectarse directamente en el método consumidor. Otro enfoque más sencillo consiste en utilizar `Record` :"

#. type: Block title
#: upstream/_versions/2.2/guides/kafka.adoc:138
#, fuzzy, no-wrap
msgid "Record"
msgstr "Registro"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:146
#, no-wrap
msgid ""
"@Incoming(\"prices\")\n"
"public void consume(Record<String, Double> record) {\n"
"    String key = record.key(); // Can be `null` if the incoming record has no key\n"
"    String value = record.value(); // Can be `null` if the incoming record has no value\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:149
#, fuzzy
msgid "`Record` is a simple wrapper around key and payload of the incoming Kafka record."
msgstr "`Record` es una simple envoltura alrededor de la clave y la carga útil del registro Kafka entrante."

#. type: Block title
#: upstream/_versions/2.2/guides/kafka.adoc:150
#, fuzzy, no-wrap
msgid "@Channel"
msgstr "@Canal"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:153
#, fuzzy
msgid "Alternatively, your application can inject a `Multi` in your bean and subscribe to its events as the following example:"
msgstr "Alternativamente, tu aplicación puede inyectar un `Multi` en tu bean y suscribirse a sus eventos como en el siguiente ejemplo:"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:158
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import io.smallrye.reactive.messaging.annotations.Channel;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:165
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
"import org.jboss.resteasy.annotations.SseElementType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:168
#: upstream/_versions/2.2/guides/kafka.adoc:700
#: upstream/_versions/2.2/guides/kafka.adoc:745
#: upstream/_versions/2.2/guides/kafka.adoc:781
#, no-wrap
msgid ""
"@Path(\"/prices\")\n"
"public class PriceResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:172
#, no-wrap
msgid ""
"    @Inject\n"
"    @Channel(\"prices\")\n"
"    Multi<Double> prices;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:181
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/prices\")\n"
"    @Produces(MediaType.SERVER_SENT_EVENTS)\n"
"    @SseElementType(\"text/plain\")\n"
"    public Multi<Double> stream() {\n"
"        return prices;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:185
#, fuzzy
msgid "This is a good example of how to integrate a Kafka consumer with another downstream, in this example exposing it as a Server-Sent Events endpoint."
msgstr "Este es un buen ejemplo de cómo integrar un consumidor Kafka con otro descendente, en este ejemplo exponiéndolo como un punto final de Eventos Enviados por el Servidor."

#. type: delimited block =
#: upstream/_versions/2.2/guides/kafka.adoc:191
#, fuzzy
msgid "When consuming messages with `@Channel`, the application code is responsible for the subscription.  In the example above, RESTEasy endpoint handles that for you."
msgstr "Al consumir mensajes con `@Channel` , el código de la aplicación es responsable de la suscripción. En el ejemplo anterior, el punto final RESTEasy se encarga de ello por usted."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:194
#, fuzzy
msgid "Following types can be injected as channels:"
msgstr "Los siguientes tipos pueden ser inyectados como canales:"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:198
#, no-wrap
msgid "@Inject @Channel(\"prices\") Multi<Double> streamOfPayloads;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:200
#, no-wrap
msgid "@Inject @Channel(\"prices\") Multi<Message<Double>> streamOfMessages;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:202
#, no-wrap
msgid "@Inject @Channel(\"prices\") Publisher<Double> publisherOfPayloads;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:204
#, no-wrap
msgid "@Inject @Channel(\"prices\") Publisher<Message<Double>> publisherOfMessages;\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:209
#, fuzzy
msgid "As with the previous `Message` example, if your injected channel receives payloads (`Multi<T>`), it acknowledges the message automatically, and support multiple subscribers.  If you injected channel receives Message (`Multi<Message<T>>`), you will be responsible for the acknowledgment and broadcasting.  We will explore sending broadcast messages in <<broadcasting-messages-on-multiple-consumers>>."
msgstr "Como en el ejemplo anterior de `Message` , si su canal inyectado recibe cargas útiles ( `Multi<T>` ), acusará recibo del mensaje automáticamente y admitirá múltiples suscriptores. Si su canal inyectado recibe mensajes ( `Multi<Message<T>>` ), será responsable del acuse de recibo y de la difusión. Exploraremos el envío de mensajes de difusión en <<broadcasting-messages-on-multiple-consumers>> ."

#. type: delimited block =
#: upstream/_versions/2.2/guides/kafka.adoc:214
#, fuzzy
msgid "Injecting `@Channel(\"prices\")` or having `@Incoming(\"prices\")` does not automatically configure the application to consume messages from Kafka.  You need to configure an inbound connector with `mp.messaging.incoming.prices\\...` or have an `@Outgoing(\"prices\")` method somewhere in your application (in which case, `prices` will be an in-memory channel)."
msgstr "Inyectar `@Channel(\"prices\")` o tener `@Incoming(\"prices\")` no configura automáticamente la aplicación para consumir mensajes de Kafka. Necesita configurar un conector de entrada con `mp.messaging.incoming.prices...` o tener un método `@Outgoing(\"prices\")` en algún lugar de su aplicación (en cuyo caso, `prices` será un canal en memoria)."

#. type: Title ===
#: upstream/_versions/2.2/guides/kafka.adoc:217
#, fuzzy, no-wrap
msgid "Blocking processing"
msgstr "Bloqueo del tratamiento"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:223
msgid "Reactive Messaging invokes your method on an I/O thread.  See the xref:quarkus-reactive-architecture.adoc[Quarkus Reactive Architecture documentation] for further details on this topic.  But, you often need to combine Reactive Messaging with blocking processing such as database interactions.  For this, you need to use the `@Blocking` annotation indicating that the processing is _blocking_ and should not be run on the caller thread."
msgstr "La mensajería reactiva invoca su método en un hilo de E/S. Consulta la xref:quarkus-reactive-architecture.html[documentación de la Arquitectura Reactiva de Quarkus] para más detalles sobre este tema. Pero, a menudo necesitas combinar la Mensajería Reactiva con el procesamiento de bloqueo, como las interacciones con la base de datos. Para ello, es necesario utilizar la anotación `@Blocking` indicando que el procesamiento es _de_ bloqueo y no debe ser ejecutado en el hilo de llamada."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:225
#, fuzzy
msgid "For example, The following code illustrates how you can store incoming payloads to a database using Hibernate with Panache:"
msgstr "Por ejemplo, el siguiente código ilustra cómo puede almacenar las cargas útiles entrantes en una base de datos utilizando Hibernate con Panache:"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:230
#, no-wrap
msgid ""
"import io.smallrye.reactive.messaging.annotations.Blocking;\n"
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:233
#: upstream/_versions/2.2/guides/kafka.adoc:1681
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.transaction.Transactional;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:236
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class PriceStorage {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:245
#, no-wrap
msgid ""
"    @Incoming(\"prices\")\n"
"    @Blocking\n"
"    @Transactional\n"
"    public void store(int priceInUsd) {\n"
"        Price price = new Price();\n"
"        price.value = priceInUsd;\n"
"        price.persist();\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:250
#, fuzzy
msgid "The complete example is available in the `kafka-panache-quickstart` {quickstarts-tree-url}/kafka-panache-quickstart[directory]."
msgstr "El ejemplo completo está disponible en `kafka-panache-quickstart` {quickstarts-tree-url}/kafka-panache-quickstart[directory]."

#. type: delimited block =
#: upstream/_versions/2.2/guides/kafka.adoc:254
msgid "There are 2 `@Blocking` annotations:"
msgstr "Hay 2 anotaciones en `@Blocking`:"

#. type: delimited block =
#: upstream/_versions/2.2/guides/kafka.adoc:256
msgid "`io.smallrye.reactive.messaging.annotations.Blocking`"
msgstr "`io.smallrye.reactive.messaging.annotations.Blocking`"

#. type: delimited block =
#: upstream/_versions/2.2/guides/kafka.adoc:257
msgid "`io.smallrye.common.annotation.Blocking`"
msgstr "`io.smallrye.common.annotation.Blocking`"

#. type: delimited block =
#: upstream/_versions/2.2/guides/kafka.adoc:262
msgid "They have the same effect.  Thus, you can use both.  The first one provides more fine-grained tuning such as the worker pool to use and whether it preserves the order.  The second one, used also with other reactive features of Quarkus, uses the default worker pool and preserves the order."
msgstr "Tienen el mismo efecto. Por lo tanto, puede utilizar ambos. El primero proporciona un ajuste más fino, como el grupo de trabajadores a utilizar y si preserva el orden. El segundo, utilizado también con otras características reactivas de Quarkus, utiliza el grupo de trabajadores por defecto y preserva el orden."

#. type: Title ===
#: upstream/_versions/2.2/guides/kafka.adoc:264
#, fuzzy, no-wrap
msgid "Acknowledgment Strategies"
msgstr "Estrategias de reconocimiento"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:272
#, fuzzy
msgid "All messages received by a consumer must be acknowledged.  In the absence of acknowledgment, the processing is considered in error.  If the consumer method receives a `Record` or a payload, the message will be acked on method return, also known as `Strategy.POST_PROCESSING`.  If the consumer method returns another reactive stream or `CompletionStage`, the message will be acked when the downstream message is acked.  You can override the default behavior to ack the message on arrival (`Strategy.PRE_PROCESSING`), or do not ack the message at all (`Strategy.NONE`) on the consumer method as in the following example:"
msgstr "Todos los mensajes recibidos por un consumidor deben ser acusados de recibo. En ausencia de acuse de recibo, el procesamiento se considera erróneo. Si el método consumidor recibe un `Record` o una carga útil, el mensaje será acuse de recibo al retorno del método, también conocido como `Strategy.POST_PROCESSING` . Si el método consumidor devuelve otro flujo reactivo o `CompletionStage` , el mensaje se acogerá cuando se acoja el mensaje descendente. Puede anular el comportamiento por defecto para ack el mensaje a su llegada ( `Strategy.PRE_PROCESSING` ), o no ack el mensaje en absoluto ( `Strategy.NONE` ) en el método consumidor como en el siguiente ejemplo:"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:280
#, no-wrap
msgid ""
"@Incoming(\"prices\")\n"
"@Acknowledgment(Acknowledgment.Strategy.PRE_PROCESSING)\n"
"public void process(double price) {\n"
"    // process price\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:284
#, fuzzy
msgid "If the consumer method receives a `Message`, the acknowledgment strategy is `Strategy.MANUAL` and the consumer method is in charge of ack/nack the message."
msgstr "Si el método consumidor recibe un `Message` , la estrategia de acuse de recibo es `Strategy.MANUAL` y el método consumidor se encarga de ack/nack el mensaje."

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:292
#, no-wrap
msgid ""
"@Incoming(\"prices\")\n"
"public CompletionStage<Void> process(Message<Double> msg) {\n"
"    // process price\n"
"    return msg.ack();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:295
#, fuzzy
msgid "As mentioned above, the method can also override the acknowledgment strategy to `PRE_PROCESSING` or `NONE`."
msgstr "Como se mencionó anteriormente, el método también puede anular la estrategia de reconocimiento a `PRE_PROCESSING` o `NONE`."

#. type: Title ===
#: upstream/_versions/2.2/guides/kafka.adoc:297
#, fuzzy, no-wrap
msgid "Commit Strategies"
msgstr "Estrategias de compromiso"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:303
#, fuzzy
msgid "When a message produced from a Kafka record is acknowledged, the connector invokes a commit strategy.  These strategies decide when the consumer offset for a specific topic/partition is committed.  Committing an offset indicates that all previous records have been processed.  It is also the position where the application would restart the processing after a crash recovery or a restart."
msgstr "Cuando se acusa recibo de un mensaje producido a partir de un registro Kafka, el conector invoca una estrategia de consignación. Estas estrategias deciden cuándo se compromete el desplazamiento del consumidor para un tema/partición específico. Comprometer un desplazamiento indica que todos los registros anteriores han sido procesados. También es la posición en la que la aplicación reiniciaría el procesamiento tras una recuperación o un reinicio."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:306
#, fuzzy
msgid "Committing every offset has performance penalties as Kafka offset management can be slow.  However, not committing the offset often enough may lead to message duplication if the application crashes between two commits."
msgstr "Confirmar cada offset tiene penalizaciones de rendimiento, ya que la gestión de offset de Kafka puede ser lenta. Sin embargo, no consignar el desplazamiento con la frecuencia suficiente puede provocar la duplicación de mensajes si la aplicación se bloquea entre dos consignaciones."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:308
#, fuzzy
msgid "The Kafka connector supports three strategies:"
msgstr "El conector Kafka admite tres estrategias:"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:317
#, fuzzy
msgid "`throttled` keeps track of received messages and commits an offset of the latest acked message in sequence (meaning, all previous messages were also acked).  This strategy guarantees at-least-once delivery even if the channel performs asynchronous processing.  The connector tracks the received records and periodically (period specified by `auto.commit.interval.ms`, default: 5000 ms) commits the highest consecutive offset.  The connector will be marked as unhealthy if a message associated with a record is not acknowledged in `throttled.unprocessed-record-max-age.ms` (default: 60000 ms).  Indeed, this strategy cannot commit the offset as soon as a single record processing fails (see <<error-handling>> to configure what happens on failing processing).  If `throttled.unprocessed-record-max-age.ms` is set to less than or equal to `0`, it does not perform any health check verification.  Such a setting might lead to running out of memory if there are \"poison pill\" messages (that are never acked).  This strategy is the default if `enable.auto.commit` is not explicitly set to true."
msgstr "`throttled` mantiene un registro de los mensajes recibidos y consigna un desplazamiento del último mensaje acuse de recibo en la secuencia (lo que significa que todos los mensajes anteriores también fueron acuse de recibo). Esta estrategia garantiza la entrega al menos una vez, incluso si el canal realiza un procesamiento asíncrono. El conector realiza un seguimiento de los registros recibidos y periódicamente (periodo especificado por `auto.commit.interval.ms` , por defecto: 5000 ms) consigna el desplazamiento consecutivo más alto. El conector se marcará como no sano si un mensaje asociado a un registro no es reconocido en `throttled.unprocessed-record-max-age.ms` (por defecto: 60000 ms). De hecho, esta estrategia no puede consignar el desfase en cuanto falla el procesamiento de un único registro (consulte <<error-handling>> para configurar lo que ocurre en caso de procesamiento fallido). Si `throttled.unprocessed-record-max-age.ms` se configura como menor o igual que `0` , no realiza ninguna verificación de salud. Una configuración de este tipo puede provocar que se agote la memoria si hay mensajes de \"píldora venenosa\" (que nunca se aceptan). Esta estrategia es la predeterminada si `enable.auto.commit` no se establece explícitamente en true."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:321
#, fuzzy
msgid "`latest` commits the record offset received by the Kafka consumer as soon as the associated message is acknowledged (if the offset is higher than the previously committed offset).  This strategy provides at-least-once delivery if the channel processes the message without performing any asynchronous processing.  This strategy should not be used in high load environment, as offset commit is expensive. However, it reduces the risk of duplicates."
msgstr "`latest` consigna el desplazamiento de registro recibido por el consumidor de Kafka en cuanto se acusa recibo del mensaje asociado (si el desplazamiento es mayor que el consignado anteriormente). Esta estrategia proporciona una entrega al menos una vez si el canal procesa el mensaje sin realizar ningún procesamiento asíncrono. Esta estrategia no debe utilizarse en un entorno de alta carga, ya que la confirmación del desplazamiento es costosa. Sin embargo, reduce el riesgo de duplicados."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:326
msgid "`ignore` performs no commit. This strategy is the default strategy when the consumer is explicitly configured with `enable.auto.commit` to true.  It delegates the offset commit to the underlying Kafka client.  This strategy provides at-least-once delivery if the channel processes the message without performing any asynchronous operations and when `enable.auto.commit` is set to true.  However, if the processing failed between two commits, messages received after the commit and before the failure will be re-processed."
msgstr ""

#. type: delimited block =
#: upstream/_versions/2.2/guides/kafka.adoc:331
#, fuzzy
msgid "The Kafka connector disables the Kafka auto commit when it is not explicitly enabled. This behavior differs from the traditional Kafka consumer.  If high throughput is important for you, and you are not limited by the downstream, we recommend to either:"
msgstr "El conector Kafka desactiva el autocompromiso de Kafka cuando no está explícitamente habilitado. Este comportamiento difiere del consumidor Kafka tradicional. Si el alto rendimiento es importante para usted y no está limitado por el flujo descendente, le recomendamos cualquiera de los dos:"

#. type: delimited block =
#: upstream/_versions/2.2/guides/kafka.adoc:333
#, fuzzy
msgid "use the `throttled` policy,"
msgstr "utilizar la política de `throttled`,"

#. type: delimited block =
#: upstream/_versions/2.2/guides/kafka.adoc:334
#, fuzzy
msgid "or set `enable.auto.commit` to true and annotate the consuming method with `@Acknowledgment(Acknowledgment.Strategy.NONE)`."
msgstr "o establecer `enable.auto.commit` como verdadero y anotar el método de consumo con `@Acknowledgment(Acknowledgment.Strategy.NONE)`."

#. type: Title ===
#: upstream/_versions/2.2/guides/kafka.adoc:337
#, fuzzy, no-wrap
msgid "Error Handling Strategies"
msgstr "Estrategias de gestión de errores"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:340
#, fuzzy
msgid "If a message produced from a Kafka record is nacked, a failure strategy is applied. The Kafka connector supports three strategies:"
msgstr "Si un mensaje producido a partir de un registro de Kafka es nacked, se aplica una estrategia de fallo. El conector Kafka soporta tres estrategias:"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:342
#, fuzzy
msgid "`fail`: fail the application, no more records will be processed (default strategy). The offset of the record that has not been processed correctly is not committed."
msgstr "`fail`: falla la aplicación, no se procesarán más registros (estrategia por defecto). El desplazamiento del registro que no se ha procesado correctamente no se compromete."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:343
#, fuzzy
msgid "`ignore`: the failure is logged, but the processing continue. The offset of the record that has not been processed correctly is committed."
msgstr "`ignore`El fallo se registra, pero el procesamiento continúa. Se consigna el desplazamiento del registro que no se ha procesado correctamente."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:344
#, fuzzy
msgid "`dead-letter-queue`: the offset of the record that has not been processed correctly is committed, but the record is written to a Kafka dead letter topic."
msgstr "`dead-letter-queue`: el desplazamiento del registro que no se ha procesado correctamente se consigna, pero el registro se escribe en un tema de letra muerta de Kafka."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:346
#, fuzzy
msgid "The strategy is selected using the `failure-strategy` attribute."
msgstr "La estrategia se selecciona mediante el atributo `failure-strategy`."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:348
#, fuzzy
msgid "In the case of `dead-letter-queue`, you can configure the following attributes:"
msgstr "En el caso de `dead-letter-queue`, puede configurar los siguientes atributos:"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:350
#, fuzzy
msgid "`dead-letter-queue.topic`: the topic to use to write the records not processed correctly, default is `dead-letter-topic-$channel`, with `$channel` being the name of the channel."
msgstr "`dead-letter-queue.topic`: el tema a utilizar para escribir los registros no procesados correctamente, por defecto es `dead-letter-topic-$channel`, siendo `$channel` el nombre del canal."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:351
#, fuzzy
msgid "`dead-letter-queue.key.serializer`: the serializer used to write the record key on the dead letter queue. By default, it deduces the serializer from the key deserializer."
msgstr "`dead-letter-queue.key.serializer`: el serializador utilizado para escribir la clave de registro en la cola de letra muerta. Por defecto, deduce el serializador del deserializador de la clave."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:352
#, fuzzy
msgid "`dead-letter-queue.value.serializer`: the serializer used to write the record value on the dead letter queue. By default, it deduces the serializer from the value deserializer."
msgstr "`dead-letter-queue.value.serializer`: el serializador utilizado para escribir el valor del registro en la cola de letra muerta. Por defecto, deduce el serializador del deserializador del valor."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:354
#, fuzzy
msgid "The record written on the dead letter queue contains a set of additional headers about the original record:"
msgstr "El registro escrito en la cola de la letra muerta contiene un conjunto de cabeceras adicionales sobre el registro original:"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:356
#, fuzzy, no-wrap
msgid "*dead-letter-reason*: the reason of the failure\n"
msgstr "*dead-letter-reason* : la razón del fracaso"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:357
#, fuzzy, no-wrap
msgid "*dead-letter-cause*: the cause of the failure if any\n"
msgstr "*dead-letter-cause* : la causa del fallo si la hay"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:358
#, fuzzy, no-wrap
msgid "*dead-letter-topic*: the original topic of the record\n"
msgstr "*dead-letter-topic* : el tema original del registro"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:359
#, fuzzy, no-wrap
msgid "*dead-letter-partition*: the original partition of the record (integer mapped to String)\n"
msgstr "*dead-letter-partition* : la partición original del registro (entero mapeado a String)"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:360
#, fuzzy, no-wrap
msgid "*dead-letter-offset*: the original offset of the record (long mapped to String)\n"
msgstr "*dead-letter-offset* : el offset original del registro (long mapped to String)"

#. type: Title ====
#: upstream/_versions/2.2/guides/kafka.adoc:361
#, fuzzy, no-wrap
msgid "Retrying processing"
msgstr "Reintento de procesamiento"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:364
#, fuzzy
msgid "You can combine Reactive Messaging with https://github.com/smallrye/smallrye-fault-tolerance[SmallRye Fault Tolerance], and retry processing if it failed:"
msgstr "Puede combinar la Mensajería Reactiva con la  link:https://github.com/smallrye/smallrye-fault-tolerance[Tolerancia a Fallos de SmallRye], y reintentar el procesamiento si ha fallado:"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:372
#, no-wrap
msgid ""
"@Incoming(\"kafka\")\n"
"@Retry(delay = 10, maxRetries = 5)\n"
"public void consume(String v) {\n"
"   // ... retry if this method throws an exception\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:375
#, fuzzy
msgid "You can configure the delay, the number of retries, the jitter, etc."
msgstr "Puedes configurar el retraso, el número de reintentos, el jitter, etc."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:377
#, fuzzy
msgid "If your method returns a `Uni` or `CompletionStage`, you need to add the `@NonBlocking` annotation:"
msgstr "Si su método devuelve un `Uni` o `CompletionStage`, debe añadir la anotación `@NonBlocking`:"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:386
#, no-wrap
msgid ""
"@Incoming(\"kafka\")\n"
"@Retry(delay = 10, maxRetries = 5)\n"
"@NonBlocking\n"
"public Uni<String> consume(String v) {\n"
"   // ... retry if this method throws an exception or the returned Uni produce a failure\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:391
#, fuzzy
msgid "The `@NonBlocking` annotation is only required with SmallRye Fault Tolerance 5.1.0 and earlier.  Starting with SmallRye Fault Tolerance 5.2.0 (available since Quarkus 2.1.0.Final), it is not necessary.  See https://smallrye.io/docs/smallrye-fault-tolerance/5.2.0/usage/extra.html#_non_compatible_mode[SmallRye Fault Tolerance documentation] for more information."
msgstr "La anotación `@NonBlocking` sólo es necesaria con SmallRye Fault Tolerance 5.1.0 y anteriores. A partir de SmallRye Fault Tolerance 5.2.0 (disponible desde Quarkus 2.1.0.Final), no es necesaria. Consulte link:https://smallrye.io/docs/smallrye-fault-tolerance/5.2.0/usage/extra.html#_non_compatible_mode[la documentación] de SmallRye Fault Tolerance para más información."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:395
#, fuzzy
msgid "The incoming messages are acknowledged only once the processing completes successfully.  So, it commits the offset after the successful processing.  If the processing still fails, even after all retries, the message is _nacked_ and the failure strategy is applied."
msgstr "Los mensajes entrantes sólo se confirman una vez que el procesamiento se completa con éxito. Por lo tanto, se compromete el desplazamiento después del procesamiento con éxito. Si el procesamiento sigue fallando, incluso después de todos los reintentos, el mensaje es _nacked_ y se aplica la estrategia de fallo."

#. type: Title ===
#: upstream/_versions/2.2/guides/kafka.adoc:396
#, fuzzy, no-wrap
msgid "Consumer Groups"
msgstr "Grupos de consumidores"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:403
#, fuzzy
msgid "In Kafka, a consumer group is a set of consumers which cooperate to consume data from a topic.  A topic is divided into a set of partitions.  The partitions of a topic are assigned among the consumers in the group, effectively allowing to scale consumption throughput.  Note that each partition is assigned to a single consumer from a group.  However, a consumer can be assigned multiple partitions if the number of partitions is greater than the number of consumer in the group."
msgstr "En Kafka, un grupo de consumidores es un conjunto de consumidores que cooperan para consumir datos de un tema. Un tema se divide en un conjunto de particiones. Las particiones de un tema se asignan entre los consumidores del grupo, lo que permite escalar eficazmente el rendimiento del consumo. Tenga en cuenta que cada partición se asigna a un único consumidor de un grupo. Sin embargo, a un consumidor se le pueden asignar varias particiones si el número de particiones es mayor que el número de consumidores del grupo."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:405
#, fuzzy
msgid "Let's explore briefly different producer/consumer patterns and how to implement them using Quarkus:"
msgstr "Exploremos brevemente diferentes patrones de productor/consumidor y cómo implementarlos usando Quarkus:"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:407
#, fuzzy, no-wrap
msgid "*Single consumer thread inside a consumer group*\n"
msgstr "*Un único hilo consumidor dentro de un grupo de consumidores*"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:411
#, fuzzy
msgid "This is the default behavior of an application subscribing to a Kafka topic: Each Kafka connector will create a single consumer thread and place it inside a single consumer group.  Consumer group id defaults to the application name as set by the `quarkus.application.name` configuration property.  It can also be set using the `kafka.group.id` property."
msgstr "Este es el comportamiento por defecto de una aplicación que se suscribe a un tema Kafka: Cada conector Kafka creará un único hilo consumidor y lo colocará dentro de un único grupo consumidor. El identificador del grupo de consumidores es, por defecto, el nombre de la aplicación establecido por la propiedad de configuración `quarkus.application.name` . También puede establecerse mediante la propiedad `kafka.group.id` ."

#. type: Named 'alt' AttributeList argument for macro 'image'
#: upstream/_versions/2.2/guides/kafka.adoc:412
#: upstream/_versions/2.2/guides/kafka.adoc:420
#: upstream/_versions/2.2/guides/kafka.adoc:427
#: upstream/_versions/2.2/guides/kafka.adoc:435
#, fuzzy, no-wrap
msgid "Architecture,"
msgstr "Arquitectura,"

#. type: Target for macro image
#: upstream/_versions/2.2/guides/kafka.adoc:412
#, no-wrap
msgid "kafka-one-app-one-consumer.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:415
#, fuzzy, no-wrap
msgid "*Multiple consumer threads inside a consumer group*\n"
msgstr "*Múltiples hilos consumidores dentro de un grupo de consumidores*"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:419
#, fuzzy
msgid "For a given application instance, the number of consumers inside the consumer group can be configured using `mp.messaging.incoming.$channel.partitions` property.  The partitions of the subscribed topic will be divided among the consumer threads.  Note that if the `partitions` value exceed the number of partitions of the topic, some consumer threads won't be assigned any partitions."
msgstr "Para una instancia de aplicación determinada, el número de consumidores dentro del grupo de consumidores puede configurarse utilizando la propiedad `mp.messaging.incoming.$channel.partitions` . Las particiones del tema suscrito se dividirán entre los hilos consumidores. Tenga en cuenta que si el valor `partitions` excede el número de particiones del tema, a algunos hilos consumidores no se les asignará ninguna partición."

#. type: Target for macro image
#: upstream/_versions/2.2/guides/kafka.adoc:420
#, no-wrap
msgid "kafka-one-app-two-consumers.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:423
#, fuzzy, no-wrap
msgid "*Multiple consumer applications inside a consumer group*\n"
msgstr "*Múltiples aplicaciones para consumidores dentro de un grupo de consumidores*"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:426
#, fuzzy
msgid "Similar to the previous example, multiple instances of an application can subscribe to a single consumer group, configured via `mp.messaging.incoming.$channel.group.id` property, or left default to the application name.  This in turn will divide partitions of the topic among application instances."
msgstr "De forma similar al ejemplo anterior, varias instancias de una aplicación pueden suscribirse a un único grupo de consumidores, configurado a través de la propiedad `mp.messaging.incoming.$channel.group.id` , o dejar por defecto el nombre de la aplicación. Esto, a su vez, dividirá las particiones del tema entre las instancias de la aplicación."

#. type: Target for macro image
#: upstream/_versions/2.2/guides/kafka.adoc:427
#, no-wrap
msgid "kafka-two-app-one-consumer-group.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:430
#, fuzzy, no-wrap
msgid "*Pub/Sub: Multiple consumer groups subscribed to a topic*\n"
msgstr "*Pub/Sub: Múltiples grupos de consumidores suscritos a un tema*"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:434
#, fuzzy
msgid "Lastly different applications can subscribe independently to same topics using different *consumer group ids*.  For example, messages published to a topic called _orders_ can be consumed independently on two consumer applications, one with `mp.messaging.incoming.orders.group.id=invoicing` and second with `mp.messaging.incoming.orders.group.id=shipping`.  Different consumer groups can thus scale independently according to the message consumption requirements."
msgstr "Por último, diferentes aplicaciones pueden suscribirse de forma independiente a los mismos temas utilizando diferentes *identificadores de grupo de consumidores* . Por ejemplo, los mensajes publicados en un tema llamado _pedidos_ pueden consumirse independientemente en dos aplicaciones consumidoras, una con `mp.messaging.incoming.orders.group.id=invoicing` y la segunda con `mp.messaging.incoming.orders.group.id=shipping` . De este modo, diferentes grupos de consumidores pueden escalar de forma independiente en función de las necesidades de consumo de mensajes."

#. type: Target for macro image
#: upstream/_versions/2.2/guides/kafka.adoc:435
#, no-wrap
msgid "kafka-two-app-two-consumer-groups.png"
msgstr ""

#. type: Title ====
#: upstream/_versions/2.2/guides/kafka.adoc:437
#, fuzzy, no-wrap
msgid "Consumer Rebalance Listener"
msgstr "Escucha del reequilibrio de los consumidores"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:444
#, fuzzy
msgid "Inside a consumer group, as new group members arrive and old members leave, the partitions are re-assigned so that each member receives a proportional share of the partitions.  This is known as rebalancing the group.  To handle offset commit and assigned partitions yourself, you can provide a consumer rebalance listener.  To achieve this, implement the `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` interface and expose it as a CDI bean with the `@Idenfier` qualifier.  A common use case is to store offset in a separate data store to implement exactly-once semantic, or starting the processing at a specific offset."
msgstr "Dentro de un grupo de consumidores, a medida que llegan nuevos miembros al grupo y se marchan los antiguos, las particiones se reasignan para que cada miembro reciba una parte proporcional de las particiones. Esto se conoce como reequilibrar el grupo. Para gestionar usted mismo el commit de compensación y las particiones asignadas, puede proporcionar un listener de reequilibrio del consumidor. Para ello, implemente la interfaz `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` y expóngala como un bean CDI con el calificador `@Idenfier` . Un caso de uso común es almacenar el desplazamiento en un almacén de datos separado para implementar la semántica \"exactamente una vez\", o iniciar el procesamiento en un desplazamiento específico."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:448
#, fuzzy
msgid "The listener is invoked every time the consumer topic/partition assignment changes.  For example, when the application starts, it invokes the `partitionsAssigned` callback with the initial set of topics/partitions associated with the consumer.  If, later, this set changes, it calls the `partitionsRevoked` and `partitionsAssigned` callbacks again, so you can implement custom logic."
msgstr "La escucha se invoca cada vez que cambia la asignación de temas/particiones del consumidor. Por ejemplo, cuando la aplicación se inicia, invoca la llamada de retorno `partitionsAssigned` con el conjunto inicial de temas/particiones asociados al consumidor. Si, más tarde, este conjunto cambia, vuelve a llamar a las retrollamadas `partitionsRevoked` y `partitionsAssigned` , por lo que puede implementar una lógica personalizada."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:451
#, fuzzy
msgid "Note that the rebalance listener methods are called from the Kafka polling thread and **will** block the caller thread until completion.  That’s because the rebalance protocol has synchronization barriers, and using asynchronous code in a rebalance listener may be executed after the synchronization barrier."
msgstr "Tenga en cuenta que los métodos de escucha de reequilibrio se llaman desde el hilo de sondeo de Kafka *y* bloquearán el hilo de llamada hasta su finalización. Esto se debe a que el protocolo de reequilibrio tiene barreras de sincronización, y el uso de código asíncrono en un oyente de reequilibrio puede ejecutarse después de la barrera de sincronización."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:453
#, fuzzy
msgid "When topics/partitions are assigned or revoked from a consumer, it pauses the message delivery and resumes once the rebalance completes."
msgstr "Cuando se asignan o revocan temas/particiones de un consumidor, se pausa la entrega de mensajes y se reanuda una vez completado el reequilibrio."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:457
#, fuzzy
msgid "If the rebalance listener handles offset commit on behalf of the user (using the `NONE` commit strategy), the rebalance listener must commit the offset synchronously in the partitionsRevoked callback.  We also recommend applying the same logic when the application stops."
msgstr "Si el receptor de reequilibrio gestiona la confirmación del reequilibrio en nombre del usuario (utilizando la estrategia de confirmación `NONE` ), el receptor de reequilibrio debe confirmar el reequilibrio de forma sincrónica en la llamada de retorno partitionsRevoked. También recomendamos aplicar la misma lógica cuando se detenga la aplicación."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:459
#, fuzzy
msgid "Unlike the `ConsumerRebalanceListener` from Apache Kafka, the `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` methods pass the Kafka Consumer and the set of topics/partitions."
msgstr "A diferencia del `ConsumerRebalanceListener` de Apache Kafka, los métodos de `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` pasan el consumidor de Kafka y el conjunto de temas/particiones."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:463
#, fuzzy
msgid "In the following example we set-up a consumer that always starts on messages from at most 10 minutes ago (or offset 0).  First we need to provide a bean that implements `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` and is annotated with `io.smallrye.common.annotation.Identifier`.  We then must configure our inbound connector to use this bean."
msgstr "En el siguiente ejemplo configuramos un consumidor que siempre se inicia con los mensajes de hace como máximo 10 minutos (o desplazamiento 0). Primero debemos proporcionar un bean que implemente `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` y esté anotado con `io.smallrye.common.annotation.Identifier` . A continuación debemos configurar nuestro conector de entrada para que utilice este bean."

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:467
#: upstream/_versions/2.2/guides/kafka.adoc:517
#, no-wrap
msgid "package inbound;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:473
#, no-wrap
msgid ""
"import io.smallrye.common.annotation.Identifier;\n"
"import io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener;\n"
"import org.apache.kafka.clients.consumer.Consumer;\n"
"import org.apache.kafka.clients.consumer.OffsetAndTimestamp;\n"
"import org.apache.kafka.clients.consumer.TopicPartition;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:479
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import java.util.Collection;\n"
"import java.util.HashMap;\n"
"import java.util.Map;\n"
"import java.util.logging.Logger;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:483
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"@Identifier(\"rebalanced-example.rebalancer\")\n"
"public class KafkaRebalancedConsumerRebalanceListener implements KafkaConsumerRebalanceListener {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:485
#, no-wrap
msgid "    private static final Logger LOGGER = Logger.getLogger(KafkaRebalancedConsumerRebalanceListener.class.getName());\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:497
#, no-wrap
msgid ""
"    /**\n"
"     * When receiving a list of partitions, will search for the earliest offset within 10 minutes\n"
"     * and seek the consumer to it.\n"
"     *\n"
"     * @param consumer   underlying consumer\n"
"     * @param partitions set of assigned topic partitions\n"
"     */\n"
"    @Override\n"
"    public void onPartitionsAssigned(Consumer<?, ?> consumer, Collection<TopicPartition> partitions) {\n"
"        long now = System.currentTimeMillis();\n"
"        long shouldStartAt = now - 600_000L; //10 minute ago\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:510
#, no-wrap
msgid ""
"        Map<TopicPartition, Long> request = new HashMap<>();\n"
"        for (TopicPartition partition : partitions) {\n"
"            LOGGER.info(\"Assigned \" + partition);\n"
"            request.put(partition, shouldStartAt);\n"
"        }\n"
"        Map<TopicPartition, OffsetAndTimestamp> offsets = consumer.offsetsForTimes(request);\n"
"        for (Map.Entry<TopicPartition, OffsetAndTimestamp> position : offsets.entrySet()) {\n"
"            long target = position.getValue() == null ? 0L : position.getValue().offset();\n"
"            LOGGER.info(\"Seeking position \" + target + \" for \" + position.getKey());\n"
"            consumer.seek(position.getKey(), target);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:521
#, no-wrap
msgid ""
"import io.smallrye.reactive.messaging.kafka.IncomingKafkaRecord;\n"
"import org.eclipse.microprofile.reactive.messaging.Acknowledgment;\n"
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:525
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import java.util.concurrent.CompletableFuture;\n"
"import java.util.concurrent.CompletionStage;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:528
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class KafkaRebalancedConsumer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:536
#, no-wrap
msgid ""
"    @Incoming(\"rebalanced-example\")\n"
"    @Acknowledgment(Acknowledgment.Strategy.NONE)\n"
"    public CompletionStage<Void> consume(IncomingKafkaRecord<Integer, String> message) {\n"
"        // We don't need to ACK messages because in this example,\n"
"        // we set offset during consumer rebalance\n"
"        return CompletableFuture.completedFuture(null);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:542
#, fuzzy
msgid "To configure the inbound connector to use the provided listener, we either set the consumer rebalance listener’s identifier: `mp.messaging.incoming.rebalanced-example.consumer-rebalance-listener.name=rebalanced-example.rebalancer`"
msgstr "Para configurar el conector de entrada para que utilice el receptor proporcionado, o bien establecemos el identificador del receptor de reequilibrio del consumidor: `mp.messaging.incoming.rebalanced-example.consumer-rebalance-listener.name=rebalanced-example.rebalancer`"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:544
#, fuzzy
msgid "Or have the listener’s name be the same as the group id:"
msgstr "O que el nombre del oyente sea el mismo que el identificador del grupo:"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:546
#, fuzzy
msgid "`mp.messaging.incoming.rebalanced-example.group.id=rebalanced-example.rebalancer`"
msgstr "`mp.messaging.incoming.rebalanced-example.group.id=rebalanced-example.rebalancer`"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:548
#, fuzzy
msgid "Setting the consumer rebalance listener’s name takes precedence over using the group id."
msgstr "La configuración del nombre del consumidor de rebalanceo tiene prioridad sobre el uso del id del grupo."

#. type: Title ====
#: upstream/_versions/2.2/guides/kafka.adoc:549
#, fuzzy, no-wrap
msgid "Using unique consumer groups"
msgstr "Utilizar grupos de consumidores únicos"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:552
#, fuzzy
msgid "If you want to process all the records from a topic (from its beginning), you need:"
msgstr "Si quieres procesar todos los registros de un tema (desde su inicio), necesitas:"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:554
#, fuzzy
msgid "to set `auto.offset.reset = earliest`"
msgstr "para establecer `auto.offset.reset = earliest`"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:555
#, fuzzy
msgid "assign your consumer to a consumer group not used by any other application."
msgstr "asignar su consumidor a un grupo de consumidores que no sea utilizado por ninguna otra aplicación."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:558
#, fuzzy
msgid "Quarkus generates a UUID that changes between two executions (including in dev mode).  So, you are sure no other consumer uses it, and you receive a new unique group id every time your application starts."
msgstr "Quarkus genera un UUID que cambia entre dos ejecuciones (incluso en modo dev). Así, usted está seguro de que ningún otro consumidor lo utiliza, y recibe un nuevo id de grupo único cada vez que se inicia su aplicación."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:560
#, fuzzy
msgid "You can use that generated UUID as the consumer group as follows:"
msgstr "Puede utilizar ese UUID generado como grupo de consumidores de la siguiente manera:"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:565
#, no-wrap
msgid ""
"mp.messaging.incoming.your-channel.auto.offset.reset=earliest\n"
"mp.messaging.incoming.your-channel.group.id=${quarkus.uuid}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:568
#, fuzzy
msgid "If the `group.id` attribute is not set, it defaults the `quarkus.application.name` configuration property."
msgstr "Si no se establece el atributo `group.id`, se establece por defecto la propiedad de configuración `quarkus.application.name`."

#. type: Title ==
#: upstream/_versions/2.2/guides/kafka.adoc:570
#, fuzzy, no-wrap
msgid "Sending messages to Kafka"
msgstr "Envío de mensajes a Kafka"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:573
#, fuzzy
msgid "Configuration for the Kafka connector outgoing channels is similar to that of incoming:"
msgstr "La configuración de los canales salientes del conector Kafka es similar a la de los entrantes:"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:579
#, no-wrap
msgid ""
"%prod.kafka.bootstrap.servers=kafka:9092 <1>\n"
"mp.messaging.outgoing.prices-out.connector=smallrye-kafka <2>\n"
"mp.messaging.outgoing.prices-out.topic=prices <3>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:584
msgid "Configure the broker location for the production profile. You can configure it globally or per channel using `mp.messaging.outgoing.$channel.bootstrap.servers` property.  In dev mode and when running tests, link:kafka-dev-services[Dev Services for Kafka] automatically starts a Kafka broker.  When not provided, this property defaults to `localhost:9092`."
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:585
#, fuzzy
msgid "Configure the connector to manage the `prices-out` channel."
msgstr "Configure el conector para gestionar el canal `prices-out`."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:586
#, fuzzy
msgid "By default, the topic name is same as the channel name. You can configure the topic attribute to override it."
msgstr "Por defecto, el nombre del tema es el mismo que el del canal. Puede configurar el atributo de tema para anularlo."

#. type: delimited block =
#: upstream/_versions/2.2/guides/kafka.adoc:591
#, fuzzy
msgid "Inside application configuration, channel names are unique.  Therefore, if you'd like to configure an incoming and outgoing channel on the same topic, you will need to name channels differently (like in the examples of this guide, `mp.messaging.incoming.prices` and `mp.messaging.outgoing.prices-out`)."
msgstr "Dentro de la configuración de la aplicación, los nombres de los canales son únicos. Por lo tanto, si desea configurar un canal entrante y saliente sobre el mismo tema, deberá nombrar los canales de forma diferente (como en los ejemplos de esta guía, `mp.messaging.incoming.prices` y `mp.messaging.outgoing.prices-out` )."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:595
#, fuzzy
msgid "Then, your application can generate messages and publish them to the `prices-out` channel.  It can use `double` payloads as in the following snippet:"
msgstr "A continuación, su aplicación puede generar mensajes y publicarlos en el canal `prices-out` . Puede utilizar cargas útiles de `double` como en el siguiente fragmento:"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:600
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:604
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import java.time.Duration;\n"
"import java.util.Random;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:607
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class KafkaPriceProducer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:609
#: upstream/_versions/2.2/guides/kafka.adoc:881
#, no-wrap
msgid "    private final Random random = new Random();\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:617
#, no-wrap
msgid ""
"    @Outgoing(\"prices-out\")\n"
"    public Multi<Double> generate() {\n"
"        // Build an infinite stream of random prices\n"
"        // It emits a price every second\n"
"        return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n"
"            .map(x -> random.nextDouble());\n"
"    }\n"
msgstr ""

#. type: delimited block =
#: upstream/_versions/2.2/guides/kafka.adoc:624
#, fuzzy
msgid "You should not call methods annotated with `@Incoming` and/or `@Outgoing` directly from your code. They are invoked by the framework. Having user code invoking them would not have the expected outcome."
msgstr "No debe llamar a los métodos anotados con `@Incoming` y/o `@Outgoing` directamente desde su código. Son invocados por el framework. Tener código de usuario invocándolos no tendría el resultado esperado."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:628
#, fuzzy
msgid "Note that the `generate` method returns a `Multi<Double>`, which implements the Reactive Streams `Publisher` interface.  This publisher will be used by the framework to generate messages and send them to the configured Kafka topic."
msgstr "Tenga en cuenta que el método `generate` devuelve un `Multi<Double>` , que implementa la interfaz Reactive Streams `Publisher` . Este publicador será utilizado por el framework para generar mensajes y enviarlos al tema Kafka configurado."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:630
#, fuzzy
msgid "Instead of returning a payload, you can return a `io.smallrye.reactive.messaging.kafka.Record` to send key/value pairs:"
msgstr "En lugar de devolver una carga útil, puede devolver un `io.smallrye.reactive.messaging.kafka.Record` para enviar pares clave/valor:"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:638
#, no-wrap
msgid ""
"@Outgoing(\"out\")\n"
"public Multi<Record<String, Double>> generate() {\n"
"    return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n"
"        .map(x -> Record.of(\"my-key\", random.nextDouble()));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:641
#, fuzzy
msgid "Payload can be wrapped inside `org.eclipse.microprofile.reactive.messaging.Message` to have more control on the written records:"
msgstr "La carga útil se puede envolver dentro de `org.eclipse.microprofile.reactive.messaging.Message` para tener más control sobre los registros escritos:"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:654
#, no-wrap
msgid ""
"@Outgoing(\"generated-price\")\n"
"public Multi<Message<Double>> generate() {\n"
"    return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n"
"            .map(x -> Message.of(random.nextDouble())\n"
"                    .addMetadata(OutgoingKafkaRecordMetadata.<String>builder()\n"
"                            .withKey(\"my-key\")\n"
"                            .withTopic(\"my-key-prices\")\n"
"                            .withHeaders(new RecordHeaders().add(\"my-header\", \"value\".getBytes()))\n"
"                            .build()));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:659
#, fuzzy
msgid "`OutgoingKafkaRecordMetadata` allows to set metadata attributes of the Kafka record, such as `key`, `topic`, `partition` or `timestamp`.  One use case is to dynamically select the destination topic of a message.  In this case, instead of configuring the topic inside your application configuration file, you need to use the outgoing metadata to set the name of the topic."
msgstr "`OutgoingKafkaRecordMetadata` permite establecer atributos de metadatos del registro Kafka, como `key` , `topic` , `partition` o `timestamp` . Un caso de uso es seleccionar dinámicamente el tema de destino de un mensaje. En este caso, en lugar de configurar el tema dentro del archivo de configuración de su aplicación, deberá utilizar los metadatos salientes para establecer el nombre del tema."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:662
#, fuzzy
msgid "Other than method signatures returning a Reactive Stream `Publisher` (`Multi` being an implementation of `Publisher`), outgoing method can also return single message.  In this case the producer will use this method as generator to create an infinite stream."
msgstr "Aparte de las firmas de métodos que devuelven un flujo reactivo `Publisher` ( siendo `Multi` una implementación de `Publisher` ), el método saliente también puede devolver un único mensaje. En este caso, el productor utilizará este método como generador para crear un flujo infinito."

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:666
#, no-wrap
msgid "@Outgoing(\"prices-out\") T generate(); // T excluding void\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:668
#, no-wrap
msgid "@Outgoing(\"prices-out\") Message<T> generate();\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:670
#, no-wrap
msgid "@Outgoing(\"prices-out\") Uni<T> generate();\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:672
#, no-wrap
msgid "@Outgoing(\"prices-out\") Uni<Message<T>> generate();\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:674
#, no-wrap
msgid "@Outgoing(\"prices-out\") CompletionStage<T> generate();\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:676
#, no-wrap
msgid "@Outgoing(\"prices-out\") CompletionStage<Message<T>> generate();\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/2.2/guides/kafka.adoc:678
#, fuzzy, no-wrap
msgid "Sending messages with @Emitter"
msgstr "Envío de mensajes con @Emitter"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:681
#, fuzzy
msgid "Sometimes, you need to have an imperative way of sending messages."
msgstr "A veces, es necesario tener una forma imperativa de enviar mensajes."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:684
#, fuzzy
msgid "For example, if you need to send a message to a stream when receiving a POST request inside a REST endpoint.  In this case, you cannot use `@Outgoing` because your method has parameters."
msgstr "Por ejemplo, si necesita enviar un mensaje a un flujo al recibir una solicitud POST dentro de un punto final REST. En este caso, no puede utilizar `@Outgoing` porque su método tiene parámetros."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:686
#, fuzzy
msgid "For this, you can use an `Emitter`."
msgstr "Para ello, puede utilizar un `Emitter`."

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:691
#: upstream/_versions/2.2/guides/kafka.adoc:1581
#: upstream/_versions/2.2/guides/kafka.adoc:1629
#: upstream/_versions/2.2/guides/kafka.adoc:1847
#, no-wrap
msgid ""
"import org.eclipse.microprofile.reactive.messaging.Channel;\n"
"import org.eclipse.microprofile.reactive.messaging.Emitter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:697
#: upstream/_versions/2.2/guides/kafka.adoc:742
#: upstream/_versions/2.2/guides/kafka.adoc:776
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Consumes;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:704
#, no-wrap
msgid ""
"    @Inject\n"
"    @Channel(\"price-create\")\n"
"    Emitter<Double> priceEmitter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:711
#, no-wrap
msgid ""
"    @POST\n"
"    @Consumes(MediaType.TEXT_PLAIN)\n"
"    public void addPrice(Double price) {\n"
"        CompletionStage<Void> ack = priceEmitter.send(price);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:714
#, fuzzy
msgid "Sending a payload returns a `CompletionStage`, completed when the message is acked. If the message transmission fails, the `CompletionStage` is completed exceptionally with the reason of the nack."
msgstr "El envío de una carga útil devuelve un `CompletionStage`, completado cuando el mensaje es aceptado. Si la transmisión del mensaje falla, el `CompletionStage` se completa excepcionalmente con la razón del nack."

#. type: delimited block =
#: upstream/_versions/2.2/guides/kafka.adoc:718
#, fuzzy
msgid "The `Emitter` configuration is done the same way as the other stream configuration used by `@Incoming` and `@Outgoing`."
msgstr "La configuración de `Emitter` se realiza de la misma manera que la otra configuración de flujo utilizada por `@Incoming` y `@Outgoing`."

#. type: delimited block =
#: upstream/_versions/2.2/guides/kafka.adoc:727
#, fuzzy
msgid "Using the `Emitter` you are sending messages from your imperative code to reactive messaging.  These messages are stored in a queue until they are sent.  If the Kafka producer client can't keep up with messages trying to be sent over to Kafka, this queue can become a memory hog and you may even run out of memory.  You can use `@OnOverflow` to configure back-pressure strategy.  It lets you configure the size of the queue (default is 256) and the strategy to apply when the buffer size is reached. Available strategies are `DROP`, `LATEST`, `FAIL`, `BUFFER`, `UNBOUNDED_BUFFER` and `NONE`."
msgstr "Utilizando la página `Emitter` estará enviando mensajes desde su código imperativo a la mensajería reactiva. Estos mensajes se almacenan en una cola hasta que se envían. Si el cliente productor de Kafka no puede seguir el ritmo de los mensajes que intentan enviarse a Kafka, esta cola puede convertirse en un devorador de memoria e incluso puede quedarse sin memoria. Puede utilizar `@OnOverflow` para configurar la estrategia de contrapresión. Le permite configurar el tamaño de la cola (por defecto es 256) y la estrategia a aplicar cuando se alcance el tamaño del búfer. Las estrategias disponibles son `DROP` , `LATEST` , `FAIL` , `BUFFER` , `UNBOUNDED_BUFFER` y `NONE` ."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:730
#, fuzzy
msgid "With the `Emitter` API, you can also encapsulate the outgoing payload inside `Message<T>`. As with the previous examples, `Message` lets you handle the ack/nack cases differently."
msgstr "Con la API `Emitter`, también puedes encapsular la carga útil saliente dentro de `Message&amp;lt;T&amp;gt;`. Como en los ejemplos anteriores, `Message` te permite manejar los casos de ack/nack de forma diferente."

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:736
#, no-wrap
msgid ""
"import java.util.concurrent.CompletableFuture;\n"
"import org.eclipse.microprofile.reactive.messaging.Channel;\n"
"import org.eclipse.microprofile.reactive.messaging.Emitter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:747
#, no-wrap
msgid "    @Inject @Channel(\"price-create\") Emitter<Double> priceEmitter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:762
#, no-wrap
msgid ""
"    @POST\n"
"    @Consumes(MediaType.TEXT_PLAIN)\n"
"    public void addPrice(Double price) {\n"
"        priceEmitter.send(Message.of(price)\n"
"            .withAck(() -> {\n"
"                // Called when the message is acked\n"
"                return CompletableFuture.completedFuture(null);\n"
"            })\n"
"            .withNack(throwable -> {\n"
"                // Called when the message is nacked\n"
"                return CompletableFuture.completedFuture(null);\n"
"            }));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:766
#, fuzzy
msgid "If you prefer using Reactive Stream APIs, you can use `MutinyEmitter` that will return `Uni<Void>` from the `send` method.  You can therefore use Mutiny APIs for handling downstream messages and errors."
msgstr "Si prefiere utilizar las API de flujo reactivo, puede utilizar `MutinyEmitter` que devolverá `Uni<Void>` del método `send` . Por lo tanto, puede utilizar las API de Mutiny para gestionar los mensajes y errores posteriores."

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:770
#: upstream/_versions/2.2/guides/kafka.adoc:1884
#, no-wrap
msgid "import org.eclipse.microprofile.reactive.messaging.Channel;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:778
#, no-wrap
msgid "import io.smallrye.reactive.messaging.MutinyEmitter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:785
#, no-wrap
msgid ""
"    @Inject\n"
"    @Channel(\"price-create\")\n"
"    MutinyEmitter<Double> priceEmitter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:794
#, no-wrap
msgid ""
"    @POST\n"
"    @Consumes(MediaType.TEXT_PLAIN)\n"
"    public Uni<String> addPrice(Double price) {\n"
"        return quoteRequestEmitter.send(price)\n"
"                .map(x -> \"ok\")\n"
"                .onFailure().recoverWithItem(\"ko\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:798
#, fuzzy
msgid "It is also possible to block on sending the event to the emitter with the `sendAndAwait` method.  It will only return from the method when the event is acked or nacked by the receiver."
msgstr "También es posible bloquear el envío del evento al emisor con el método `sendAndAwait` . Sólo regresará del método cuando el receptor acepte o rechace el evento."

#. type: Block title
#: upstream/_versions/2.2/guides/kafka.adoc:800
#, fuzzy, no-wrap
msgid "Deprecation"
msgstr "Depreciación"

#. type: delimited block =
#: upstream/_versions/2.2/guides/kafka.adoc:803
#, fuzzy
msgid "The `io.smallrye.reactive.messaging.annotations.Emitter`, `io.smallrye.reactive.messaging.annotations.Channel` and `io.smallrye.reactive.messaging.annotations.OnOverflow` classes are now deprecated and replaced by:"
msgstr "Las clases `io.smallrye.reactive.messaging.annotations.Emitter`, `io.smallrye.reactive.messaging.annotations.Channel` y `io.smallrye.reactive.messaging.annotations.OnOverflow` están ahora obsoletas y se sustituyen por:"

#. type: delimited block =
#: upstream/_versions/2.2/guides/kafka.adoc:805
#, fuzzy
msgid "`org.eclipse.microprofile.reactive.messaging.Emitter`"
msgstr "`org.eclipse.microprofile.reactive.messaging.Emitter`"

#. type: delimited block =
#: upstream/_versions/2.2/guides/kafka.adoc:806
#, fuzzy
msgid "`org.eclipse.microprofile.reactive.messaging.Channel`"
msgstr "`org.eclipse.microprofile.reactive.messaging.Channel`"

#. type: delimited block =
#: upstream/_versions/2.2/guides/kafka.adoc:807
#, fuzzy
msgid "`org.eclipse.microprofile.reactive.messaging.OnOverflow`"
msgstr "`org.eclipse.microprofile.reactive.messaging.OnOverflow`"

#. type: delimited block =
#: upstream/_versions/2.2/guides/kafka.adoc:809
#, fuzzy
msgid "The new `Emitter.send` method returns a `CompletionStage` completed when the produced message is acknowledged."
msgstr "El nuevo método `Emitter.send` devuelve un `CompletionStage` completado cuando el mensaje producido es reconocido."

#. type: Title ===
#: upstream/_versions/2.2/guides/kafka.adoc:811
#, fuzzy, no-wrap
msgid "Write Acknowledgement"
msgstr "Escriba el acuse de recibo"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:815
#, fuzzy
msgid "When Kafka broker receives a record, its acknowledgement can take time depending on the configuration.  Also, it stores in-memory the records that cannot be written."
msgstr "Cuando el corredor Kafka recibe un registro, su acuse de recibo puede tardar dependiendo de la configuración. Además, almacena en memoria los registros que no pueden escribirse."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:818
#, fuzzy
msgid "By default, the connector does wait for Kafka to acknowledge the record to continue the processing (acknowledging the received Message).  You can disable this by setting the `waitForWriteCompletion` attribute to `false`."
msgstr "Por defecto, el conector espera a que Kafka acuse recibo del registro para continuar con el procesamiento (acuse de recibo del mensaje recibido). Puede desactivar esto estableciendo el atributo `waitForWriteCompletion` en `false` ."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:820
#, fuzzy
msgid "Note that the `acks` attribute has a huge impact on the record acknowledgement."
msgstr "Tenga en cuenta que el atributo `acks` tiene un gran impacto en el reconocimiento del registro."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:822
#, fuzzy
msgid "If a record cannot be written, the message is nacked."
msgstr "Si no se puede escribir un registro, el mensaje es nacked."

#. type: Title ===
#: upstream/_versions/2.2/guides/kafka.adoc:823
#, fuzzy, no-wrap
msgid "Backpressure"
msgstr "Contrapresión"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:827
#, fuzzy
msgid "The Kafka outbound connector handles back-pressure, monitoring the number of in-flight messages waiting to be written to the Kafka broker.  The number of in-flight messages is configured using the `max-inflight-messages` attribute and defaults to 1024."
msgstr "El conector de salida Kafka gestiona la contrapresión, controlando el número de mensajes en vuelo que esperan ser escritos en el corredor Kafka. El número de mensajes en vuelo se configura mediante el atributo `max-inflight-messages` y su valor predeterminado es 1024."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:832
#, fuzzy
msgid "The connector only sends that amount of messages concurrently.  No other messages will be sent until at least one in-flight message gets acknowledged by the broker.  Then, the connector writes a new message to Kafka when one of the broker’s in-flight messages get acknowledged.  Be sure to configure Kafka’s `batch.size` and `linger.ms` accordingly."
msgstr "El conector sólo envía esa cantidad de mensajes simultáneamente. No se enviará ningún otro mensaje hasta que al menos un mensaje en vuelo reciba acuse de recibo del corredor. Entonces, el conector escribe un nuevo mensaje en Kafka cuando uno de los mensajes en vuelo del corredor obtiene acuse de recibo. Asegúrese de configurar `batch.size` y `linger.ms` de Kafka en consecuencia."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:835
#, fuzzy
msgid "You can also remove the limit of in-flight messages by setting `max-inflight-messages` to `0`.  However, note that the Kafka producer may block if the number of requests reaches `max.in.flight.requests.per.connection`."
msgstr "También puede eliminar el límite de mensajes en vuelo estableciendo `max-inflight-messages` en `0` . Sin embargo, tenga en cuenta que el productor Kafka puede bloquearse si el número de peticiones alcanza `max.in.flight.requests.per.connection` ."

#. type: Title ===
#: upstream/_versions/2.2/guides/kafka.adoc:836
#, fuzzy, no-wrap
msgid "Retrying message dispatch"
msgstr "Reintento de envío de mensajes"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:841
#, fuzzy
msgid "When the Kafka producer receives an error from the server, if it is a transient, recoverable error, the client will retry sending the batch of messages.  This behavior is controlled by `retries` and `retry.backoff.ms` parameters.  In addition to this, SmallRye Reactive Messaging will retry individual messages on recoverable errors, depending on the `retries` and `delivery.timeout.ms` parameters."
msgstr "Cuando el productor de Kafka recibe un error del servidor, si se trata de un error transitorio y recuperable, el cliente volverá a intentar enviar el lote de mensajes. Este comportamiento se controla mediante los parámetros `retries` y `retry.backoff.ms` . Además, SmallRye Reactive Messaging reintentará el envío de mensajes individuales en caso de errores recuperables, en función de los parámetros `retries` y `delivery.timeout.ms` ."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:844
#, fuzzy
msgid "Note that while having retries in a reliable system is a best practice, the `max.in.flight.requests.per.connection` parameter defaults to `5`, meaning that the order of the messages is not guaranteed.  If the message order is a must for your use case, setting `max.in.flight.requests.per.connection` to `1` will make sure a single batch of messages is sent at a time, in the expense of limiting the throughput of the producer."
msgstr "Tenga en cuenta que aunque tener reintentos en un sistema fiable es una buena práctica, el parámetro `max.in.flight.requests.per.connection` por defecto es `5` , lo que significa que el orden de los mensajes no está garantizado. Si el orden de los mensajes es imprescindible para su caso de uso, estableciendo `max.in.flight.requests.per.connection` en `1` se asegurará de que se envía un único lote de mensajes a la vez, a costa de limitar el rendimiento del productor."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:846
#, fuzzy
msgid "For applying retry mechanism on processing errors, see the section on <<retrying-processing>>."
msgstr "Para aplicar el mecanismo de reintento en los errores de procesamiento, consulte la sección <<retrying-processing>> ."

#. type: Title ===
#: upstream/_versions/2.2/guides/kafka.adoc:847
#, fuzzy, no-wrap
msgid "In-memory channels"
msgstr "Canales en memoria"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:852
#, fuzzy
msgid "In some use cases, it is convenient to use the messaging patterns to transfer messages inside the same application.  When you don't connect a channel to a messaging backend like Kafka, everything happens in-memory, and the streams are created by chaining methods together.  Each chain is still a reactive stream and enforces the back-pressure protocol."
msgstr "En algunos casos de uso, es conveniente utilizar los patrones de mensajería para transferir mensajes dentro de la misma aplicación. Cuando no se conecta un canal a un backend de mensajería como Kafka, todo sucede en memoria, y los flujos se crean encadenando métodos. Cada cadena sigue siendo un flujo reactivo y aplica el protocolo de contrapresión."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:856
#, fuzzy
msgid "The framework verifies that the producer/consumer chain is complete, meaning that if the application writes messages into an in-memory channel (using a method with only `@Outgoing`, or an `Emitter`), it must also consume the messages from within the application (using a method with only `@Incoming` or using an unmanaged stream)."
msgstr "El marco de trabajo verifica que la cadena productor/consumidor esté completa, lo que significa que si la aplicación escribe mensajes en un canal en memoria (utilizando un método con sólo `@Outgoing` , o un `Emitter` ), también debe consumir los mensajes desde dentro de la aplicación (utilizando un método con sólo `@Incoming` o utilizando un flujo no gestionado)."

#. type: Title ===
#: upstream/_versions/2.2/guides/kafka.adoc:858
#, fuzzy, no-wrap
msgid "Broadcasting messages on multiple consumers"
msgstr "Difusión de mensajes en múltiples consumidores"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:863
#, fuzzy
msgid "By default, a channel can be linked to a single consumer, using `@Incoming` method or `@Channel` reactive stream.  At application startup, channels are verified to form a chain of consumers and producers with single consumer and producer.  You can override this behavior by setting `mp.messaging.$channel.broadcast=true` on a channel."
msgstr "Por defecto, un canal puede estar vinculado a un único consumidor, utilizando el método `@Incoming` o el flujo reactivo `@Channel` . Al iniciarse la aplicación, se verifica que los canales formen una cadena de consumidores y productores con un único consumidor y productor. Puede anular este comportamiento configurando `mp.messaging.$channel.broadcast=true` en un canal."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:865
#, fuzzy
msgid "In case of in-memory channels, `@Broadcast` annotation can be used on the `@Outgoing` method. For example,"
msgstr "En el caso de los canales en memoria, se puede utilizar la anotación `@Broadcast` en el método `@Outgoing`. Por ejemplo,"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:869
#, no-wrap
msgid "import java.util.Random;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:874
#: upstream/_versions/2.2/guides/kafka.adoc:916
#: upstream/_versions/2.2/guides/kafka.adoc:944
#, no-wrap
msgid ""
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:876
#, no-wrap
msgid "import io.smallrye.reactive.messaging.annotations.Broadcast;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:879
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class MultipleConsumer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:887
#, no-wrap
msgid ""
"    @Outgoing(\"in-memory-channel\")\n"
"    @Broadcast\n"
"    double generate() {\n"
"        return random.nextDouble();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:892
#, no-wrap
msgid ""
"    @Incoming(\"in-memory-channel\")\n"
"    void consumeAndLog(double price) {\n"
"        System.out.println(price);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:899
#, no-wrap
msgid ""
"    @Incoming(\"in-memory-channel\")\n"
"    @Outgoing(\"prices2\")\n"
"    double consumeAndSend(double price) {\n"
"        return price;\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block =
#: upstream/_versions/2.2/guides/kafka.adoc:905
#, fuzzy
msgid "Reciprocally, multiple producers on the same channel can be merged by setting `mp.messaging.incoming.$channel.merge=true`.  On the `@Incoming` methods, you can control how multiple channels are merged using the `@Merge` annotation."
msgstr "Recíprocamente, varios productores de un mismo canal pueden fusionarse mediante la anotación `mp.messaging.incoming.$channel.merge=true` . En los métodos `@Incoming` , puede controlar cómo se fusionan varios canales utilizando la anotación `@Merge` ."

#. type: Title ==
#: upstream/_versions/2.2/guides/kafka.adoc:907
#, fuzzy, no-wrap
msgid "Processing Messages"
msgstr "Procesamiento de mensajes"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:911
#, fuzzy
msgid "Applications streaming data often need to consume some events from a topic, process them and publish the result to a different topic.  A processor method can be simply implemented using both the `@Incoming` and `@Outgoing` annotations:"
msgstr "Las aplicaciones que transmiten datos a menudo necesitan consumir algunos eventos de un tema, procesarlos y publicar el resultado en un tema diferente. Un método procesador puede implementarse de forma sencilla utilizando las anotaciones `@Incoming` y `@Outgoing` :"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:921
#: upstream/_versions/2.2/guides/kafka.adoc:949
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class PriceProcessor {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:923
#: upstream/_versions/2.2/guides/kafka.adoc:951
#: upstream/_versions/2.2/guides/kafka.adoc:1090
#, no-wrap
msgid "    private static final double CONVERSION_RATE = 0.88;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:929
#, no-wrap
msgid ""
"    @Incoming(\"price-in\")\n"
"    @Outgoing(\"price-out\")\n"
"    public double process(double price) {\n"
"        return price * CONVERSION_RATE;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:935
#, fuzzy
msgid "The parameter of the `process` method is the incoming message payload, whereas the return value will be used as the outgoing message payload.  Previously mentioned signatures for parameter and return types are also supported, such as `Message<T>`, `Record<K, V>`, etc."
msgstr "El parámetro del método `process` es la carga útil del mensaje entrante, mientras que el valor de retorno se utilizará como carga útil del mensaje saliente. También se admiten las firmas mencionadas anteriormente para los tipos de parámetro y de retorno, como `Message<T>` , `Record<K, V>` , etc."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:937
#, fuzzy
msgid "You can apply asynchronous stream processing by consuming and returning reactive stream `Multi<T>` type:"
msgstr "Puede aplicar el procesamiento asíncrono de flujos consumiendo y devolviendo flujos reactivos del tipo `Multi&amp;lt;T&amp;gt;`:"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:946
#, no-wrap
msgid "import io.smallrye.mutiny.Multi;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:957
#, no-wrap
msgid ""
"    @Incoming(\"price-in\")\n"
"    @Outgoing(\"price-out\")\n"
"    public Multi<Double> process(Multi<Integer> prices) {\n"
"        return prices.filter(p -> p > 100).map(p -> p * CONVERSION_RATE);\n"
"    }\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/2.2/guides/kafka.adoc:961
#, fuzzy, no-wrap
msgid "Propagating Record Key"
msgstr "Propagación de la clave de registro"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:964
#, fuzzy
msgid "When processing messages, you can propagate incoming record key to the outgoing record."
msgstr "Al procesar los mensajes, puede propagar la clave del registro de entrada al registro de salida."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:967
#, fuzzy
msgid "Enabled with `mp.messaging.outgoing.$channel.propagate-record-key=true` configuration, record key propagation produces the outgoing record with the same _key_ as the incoming record."
msgstr "Activada con la configuración `mp.messaging.outgoing.$channel.propagate-record-key=true` , la propagación de la clave del registro produce el registro saliente con la misma _clave_ que el registro entrante."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:970
#, fuzzy
msgid "If the outgoing record already contains a _key_, it *won't be overridden* by the incoming record key.  If the incoming record does have a _null_ key, the `mp.messaging.outgoing.$channel.key` property is used."
msgstr "Si el registro saliente ya contiene una _clave_ , ésta *no será anulada* por la clave del registro entrante. Si el registro entrante sí tiene una clave _nula_ , se utilizará la propiedad `mp.messaging.outgoing.$channel.key` ."

#. type: Title ==
#: upstream/_versions/2.2/guides/kafka.adoc:972
#, fuzzy, no-wrap
msgid "Accessing Kafka clients directly"
msgstr "Acceso directo a los clientes de Kafka"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:976
#, fuzzy
msgid "In rare cases, you may need to access the underlying Kafka clients.  `KafkaClientService` provides thread-safe access to `Producer` and `Consumer`."
msgstr "En casos excepcionales, puede que necesite acceder a los clientes Kafka subyacentes. `KafkaClientService` proporciona un acceso a prueba de hilos a `Producer` y `Consumer` ."

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:982
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.enterprise.event.Observes;\n"
"import javax.inject.Inject;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:984
#, no-wrap
msgid "import org.apache.kafka.clients.producer.ProducerRecord;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:989
#, no-wrap
msgid ""
"import io.quarkus.runtime.StartupEvent;\n"
"import io.smallrye.reactive.messaging.kafka.KafkaClientService;\n"
"import io.smallrye.reactive.messaging.kafka.KafkaConsumer;\n"
"import io.smallrye.reactive.messaging.kafka.KafkaProducer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:992
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class PriceSender {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:995
#, no-wrap
msgid ""
"    @Inject\n"
"    KafkaClientService clientService;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1002
#, no-wrap
msgid ""
"    void onStartup(@Observes StartupEvent startupEvent) {\n"
"        KafkaProducer<String, Double> producer = clientService.getProducer(\"generated-price\");\n"
"        producer.runOnSendingThread(client -> client.send(new ProducerRecord<>(\"prices\", 2.4)))\n"
"            .await().indefinitely();\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block =
#: upstream/_versions/2.2/guides/kafka.adoc:1007
#, fuzzy
msgid "The `KafkaClientService` is an experimental API and can change in the future."
msgstr "La `KafkaClientService` es una API experimental y puede cambiar en el futuro."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1010
#, fuzzy
msgid "You can also get the Kafka configuration injected to your application and create Kafka producer, consumer and admin clients directly:"
msgstr "También puede obtener la configuración de Kafka inyectada en su aplicación y crear clientes productores, consumidores y administradores de Kafka directamente:"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1017
#, no-wrap
msgid ""
"import io.smallrye.common.annotation.Identifier;\n"
"import org.apache.kafka.clients.admin.AdminClient;\n"
"import org.apache.kafka.clients.admin.AdminClientConfig;\n"
"import org.apache.kafka.clients.admin.KafkaAdminClient;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1023
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.enterprise.inject.Produces;\n"
"import javax.inject.Inject;\n"
"import java.util.HashMap;\n"
"import java.util.Map;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1026
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class KafkaClients {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1030
#, no-wrap
msgid ""
"    @Inject\n"
"    @Identifier(\"default-kafka-broker\")\n"
"    Map<String, Object> config;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1041
#, no-wrap
msgid ""
"    @Produces\n"
"    AdminClient getAdmin() {\n"
"        Map<String, Object> copy = new HashMap<>();\n"
"        for (Map.Entry<String, Object> entry : config.entrySet()) {\n"
"            if (AdminClientConfig.configNames().contains(entry.getKey())) {\n"
"                copy.put(entry.getKey(), entry.getValue());\n"
"            }\n"
"        }\n"
"        return KafkaAdminClient.create(copy);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1047
msgid "This configuration map will contain all Kafka related properties configured inside `application.properties` file."
msgstr ""

#. type: Title ==
#: upstream/_versions/2.2/guides/kafka.adoc:1049
#, fuzzy, no-wrap
msgid "JSON serialization"
msgstr "Serialización JSON"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1052
#, fuzzy
msgid "Quarkus has built-in capabilities to deal with JSON Kafka messages."
msgstr "Quarkus tiene capacidades incorporadas para tratar con mensajes JSON Kafka."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1054
#, fuzzy
msgid "Imagine we have a `Fruit` data class as follows:"
msgstr "Imaginemos que tenemos una clase de datos `Fruit` como la siguiente:"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1058
#, no-wrap
msgid "public class Fruit {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1061
#, no-wrap
msgid ""
"    public String name;\n"
"    public int price;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1064
#, no-wrap
msgid ""
"    public Fruit() {\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1070
#, no-wrap
msgid ""
"    public Fruit(String name, int price) {\n"
"        this.name = name;\n"
"        this.price = price;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1073
#, fuzzy
msgid "And we want to use it to receive messages from Kafka, make some price transformation, and send messages back to Kafka."
msgstr "Y queremos usarlo para recibir mensajes de Kafka, hacer alguna transformación de precios, y enviar mensajes de vuelta a Kafka."

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1079
#, no-wrap
msgid ""
"import io.smallrye.reactive.messaging.annotations.Broadcast;\n"
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1088
#, no-wrap
msgid ""
"/**\n"
"* A bean consuming data from the \"fruit-in\" channel and applying some price conversion.\n"
"* The result is pushed to the \"fruit-out\" channel.\n"
"*/\n"
"@ApplicationScoped\n"
"public class FruitProcessor {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1098
#, no-wrap
msgid ""
"    @Incoming(\"fruit-in\")\n"
"    @Outgoing(\"fruit-out\")\n"
"    @Broadcast\n"
"    public Fruit process(Fruit fruit) {\n"
"        fruit.price = fruit.price * CONVERSION_RATE;\n"
"        return fruit;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1103
#, fuzzy
msgid "To do this, we will need to setup JSON serialization with Jackson or JSON-B."
msgstr "Para ello, necesitaremos configurar la serialización JSON con Jackson o JSON-B."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1105
#, fuzzy
msgid "With JSON serialization correctly configured, you can also use `Publisher<Fruit>` and `Emitter<Fruit>`."
msgstr "Con la serialización JSON correctamente configurada, también se puede utilizar `Publisher&amp;lt;Fruit&amp;gt;` y `Emitter&amp;lt;Fruit&amp;gt;`."

#. type: Title ===
#: upstream/_versions/2.2/guides/kafka.adoc:1107
#, fuzzy, no-wrap
msgid "Serializing via Jackson"
msgstr "Serialización a través de Jackson"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1110
msgid "First, you need to include the `quarkus-jackson` extension."
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1117
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-jackson</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1121
#, fuzzy
msgid "There is an existing `ObjectMapperSerializer` that can be used to serialize all data objects via Jackson.  You may create an empty subclass if you want to use <<serialization-autodetection>>."
msgstr "Existe un `ObjectMapperSerializer` que puede utilizarse para serializar todos los objetos de datos a través de Jackson. Puede crear una subclase vacía si desea utilizar <<serialization-autodetection>> ."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1124
#, fuzzy
msgid "The corresponding deserializer class needs to be subclassed.  So, let's create a `FruitDeserializer` that extends the `ObjectMapperDeserializer`."
msgstr "Es necesario subclasificar la clase deserializadora correspondiente. Así pues, creemos un `FruitDeserializer` que extienda el `ObjectMapperDeserializer` ."

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1128
#, no-wrap
msgid "package com.acme.fruit.jackson;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1130
#: upstream/_versions/2.2/guides/kafka.adoc:1711
#: upstream/_versions/2.2/guides/kafka.adoc:1797
#, no-wrap
msgid "import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1136
#: upstream/_versions/2.2/guides/kafka.adoc:1717
#: upstream/_versions/2.2/guides/kafka.adoc:1803
#, no-wrap
msgid ""
"public class FruitDeserializer extends ObjectMapperDeserializer<Fruit> {\n"
"    public FruitDeserializer() {\n"
"        super(Fruit.class);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1139
#, fuzzy
msgid "Finally, configure your channels to use the Jackson serializer and deserializer."
msgstr "Por último, configure sus canales para utilizar el serializador y el deserializador de Jackson."

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1146
#, no-wrap
msgid ""
"# Configure the Kafka source (we read from it)\n"
"mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n"
"mp.messaging.incoming.fruit-in.topic=fruit-in\n"
"mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jackson.FruitDeserializer\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1151
#, no-wrap
msgid ""
"# Configure the Kafka sink (we write to it)\n"
"mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n"
"mp.messaging.outgoing.fruit-out.topic=fruit-out\n"
"mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.ObjectMapperSerializer\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1155
#, fuzzy
msgid "Now, your Kafka messages will contain a Jackson serialized representation of your `Fruit` data object.  In this case, the `deserializer` configuration is not necessary as the <<serialization-autodetection>> is enabled by default."
msgstr "Ahora, sus mensajes Kafka contendrán una representación serializada Jackson de su objeto de datos `Fruit` . En este caso, la configuración de `deserializer` no es necesaria, ya que <<serialization-autodetection>> está activada por defecto."

#. type: Title ===
#: upstream/_versions/2.2/guides/kafka.adoc:1157
#, fuzzy, no-wrap
msgid "Serializing via JSON-B"
msgstr "Serialización mediante JSON-B"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1160
#, fuzzy
msgid "First, you need to include the `quarkus-jsonb` extension."
msgstr "En primer lugar, debe incluir la extensión `quarkus-jsonb`."

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1167
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-jsonb</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1171
#, fuzzy
msgid "There is an existing `JsonbSerializer` that can be used to serialize all data objects via JSON-B.  You may create an empty subclass if you want to use <<serialization-autodetection>>."
msgstr "Existe un `JsonbSerializer` que puede utilizarse para serializar todos los objetos de datos mediante JSON-B. Puede crear una subclase vacía si desea utilizar <<serialization-autodetection>> ."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1174
#, fuzzy
msgid "The corresponding deserializer class needs to be subclassed.  So, let's create a `FruitDeserializer` that extends the generic `JsonbDeserializer`."
msgstr "Es necesario subclasificar la clase deserializadora correspondiente. Así pues, creemos un `FruitDeserializer` que extienda el genérico `JsonbDeserializer` ."

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1178
#, no-wrap
msgid "package com.acme.fruit.jsonb;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1180
#, no-wrap
msgid "import io.quarkus.kafka.client.serialization.JsonbDeserializer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1186
#, no-wrap
msgid ""
"public class FruitDeserializer extends JsonbDeserializer<Fruit> {\n"
"    public FruitDeserializer() {\n"
"        super(Fruit.class);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1189
#, fuzzy
msgid "Finally, configure your channels to use the JSON-B serializer and deserializer."
msgstr "Por último, configura tus canales para que utilicen el serializador y deserializador JSON-B."

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1196
#, no-wrap
msgid ""
"# Configure the Kafka source (we read from it)\n"
"mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n"
"mp.messaging.incoming.fruit-in.topic=fruit-in\n"
"mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jsonb.FruitDeserializer\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1201
#, no-wrap
msgid ""
"# Configure the Kafka sink (we write to it)\n"
"mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n"
"mp.messaging.outgoing.fruit-out.topic=fruit-out\n"
"mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1204
#, fuzzy
msgid "Now, your Kafka messages will contain a JSON-B serialized representation of your `Fruit` data object."
msgstr "Ahora, sus mensajes Kafka contarán con una representación serializada JSON-B de su objeto de datos `Fruit`."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1207
#, fuzzy
msgid "If you don't want to create a deserializer for each data object, you can use the generic `io.vertx.kafka.client.serialization.JsonObjectDeserializer` that will deserialize to a `io.vertx.core.json.JsonObject`. The corresponding serializer can also be used: `io.vertx.kafka.client.serialization.JsonObjectSerializer`."
msgstr "Si no desea crear un deserializador para cada objeto de datos, puede utilizar el genérico `io.vertx.kafka.client.serialization.JsonObjectDeserializer` que deserializará a un `io.vertx.core.json.JsonObject` . También se puede utilizar el serializador correspondiente: `io.vertx.kafka.client.serialization.JsonObjectSerializer` ."

#. type: Title ==
#: upstream/_versions/2.2/guides/kafka.adoc:1208
#, fuzzy, no-wrap
msgid "Avro Serialization"
msgstr "Serialización Avro"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1211
#: upstream/_versions/2.2/guides/kafka.adoc:1283
msgid "This is described in a dedicated guide: link:kafka-schema-registry-avro[Using Apache Kafka with Schema Registry and Avro]."
msgstr ""

#. type: Title ==
#: upstream/_versions/2.2/guides/kafka.adoc:1213
#, fuzzy, no-wrap
msgid "Serializer/deserializer autodetection"
msgstr "Autodetección del serializador/deserializador"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1217
msgid "When using SmallRye Reactive Messaging with Kafka, Quarkus can often automatically detect the correct serializer and deserializer class.  This autodetection is based on declarations of `@Incoming` and `@Outgoing` methods, as well as injected ``@Channel``s."
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1219
#, fuzzy
msgid "For example, if you declare"
msgstr "Por ejemplo, si declara"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1226
#, no-wrap
msgid ""
"@Outgoing(\"generated-price\")\n"
"public Multi<Integer> generate() {\n"
"    ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1229
#, fuzzy
msgid "and your configuration indicates that the `generated-price` channel uses the `smallrye-kafka` connector, then Quarkus will automatically set the `value.serializer` to Kafka's built-in `IntegerSerializer`."
msgstr "y su configuración indica que el canal `generated-price` utiliza el conector `smallrye-kafka`, entonces Quarkus configurará automáticamente el `value.serializer` con el `IntegerSerializer` incorporado de Kafka."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1231
#, fuzzy
msgid "Similarly, if you declare"
msgstr "Del mismo modo, si se declara"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1238
#, no-wrap
msgid ""
"@Incoming(\"my-kafka-records\")\n"
"public void consume(KafkaRecord<Long, byte[]> record) {\n"
"    ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1241
#, fuzzy
msgid "and your configuration indicates that the `my-kafka-records` channel uses the `smallrye-kafka` connector, then Quarkus will automatically set the `key.deserializer` to Kafka's built-in `LongDeserializer`, as well as the `value.deserializer` to `ByteArrayDeserializer`."
msgstr "y su configuración indica que el canal `my-kafka-records` utiliza el conector `smallrye-kafka`, entonces Quarkus configurará automáticamente el `key.deserializer` al `LongDeserializer` incorporado de Kafka, así como el `value.deserializer` a `ByteArrayDeserializer`."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1243
#, fuzzy
msgid "Finally, if you declare"
msgstr "Por último, si declara"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1249
#, no-wrap
msgid ""
"@Inject\n"
"@Channel(\"price-create\")\n"
"Emitter<Double> priceEmitter;\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1252
#, fuzzy
msgid "and your configuration indicates that the `price-create` channel uses the `smallrye-kafka` connector, then Quarkus will automatically set the `value.serializer` to Kafka's built-in `DoubleSerializer`."
msgstr "y su configuración indica que el canal `price-create` utiliza el conector `smallrye-kafka`, entonces Quarkus configurará automáticamente el `value.serializer` con el `DoubleSerializer` incorporado de Kafka."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1254
#, fuzzy
msgid "The full set of types supported by the serializer/deserializer autodetection is:"
msgstr "El conjunto completo de tipos soportados por la autodetección del serializador/deserializador es:"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1256
#, fuzzy
msgid "`short` and `java.lang.Short`"
msgstr "`short` y `java.lang.Short`"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1257
#, fuzzy
msgid "`int` and `java.lang.Integer`"
msgstr "`int` y `java.lang.Integer`"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1258
#, fuzzy
msgid "`long` and `java.lang.Long`"
msgstr "`long` y `java.lang.Long`"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1259
#, fuzzy
msgid "`float` and `java.lang.Float`"
msgstr "`float` y `java.lang.Float`"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1260
#, fuzzy
msgid "`double` and `java.lang.Double`"
msgstr "`double` y `java.lang.Double`"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1261
msgid "`byte[]`"
msgstr "`byte[]`"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1262
#, fuzzy
msgid "`java.lang.String`"
msgstr "`java.lang.String`"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1263
#, fuzzy
msgid "`java.util.UUID`"
msgstr "`java.util.UUID`"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1264
#, fuzzy
msgid "`java.nio.ByteBuffer`"
msgstr "`java.nio.ByteBuffer`"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1265
#, fuzzy
msgid "`org.apache.kafka.common.utils.Bytes`"
msgstr "`org.apache.kafka.common.utils.Bytes`"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1266
#, fuzzy
msgid "`io.vertx.core.buffer.Buffer`"
msgstr "`io.vertx.core.buffer.Buffer`"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1267
#, fuzzy
msgid "`io.vertx.core.json.JsonObject`"
msgstr "`io.vertx.core.json.JsonObject`"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1268
#, fuzzy
msgid "`io.vertx.core.json.JsonArray`"
msgstr "`io.vertx.core.json.JsonArray`"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1269
#, fuzzy
msgid "classes generated from Avro schemas, as well as Avro `GenericRecord`, if Confluent or Apicurio Registry _serde_ is present"
msgstr "clases generadas a partir de esquemas Avro, así como Avro `GenericRecord`, si Confluent o Apicurio Registry _serde_ está presente"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1270
msgid "see link:kafka-schema-registry-avro[Using Apache Kafka with Schema Registry and Avro] for more information about using Confluent or Apicurio Registry libraries"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1271
#, fuzzy
msgid "classes for which a subclass of `ObjectMapperSerializer` / `ObjectMapperDeserializer` is present, as described in <<jackson-serialization>>"
msgstr "clases para las que existe una subclase de `ObjectMapperSerializer` / `ObjectMapperDeserializer` , como se describe en <<jackson-serialization>>"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1272
#, fuzzy
msgid "it is technically not needed to subclass `ObjectMapperSerializer`, but in such case, autodetection isn't possible"
msgstr "técnicamente no es necesario subclasificar `ObjectMapperSerializer`, pero en tal caso, la autodetección no es posible"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1273
#, fuzzy
msgid "classes for which a subclass of `JsonbSerializer` / `JsonbDeserializer` is present, as described in <<jsonb-serialization>>"
msgstr "clases para las que existe una subclase de `JsonbSerializer` / `JsonbDeserializer` , como se describe en <<jsonb-serialization>>"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1274
#, fuzzy
msgid "it is technically not needed to subclass `JsonbSerializer`, but in such case, autodetection isn't possible"
msgstr "técnicamente no es necesario subclasificar `JsonbSerializer`, pero en tal caso, la autodetección no es posible"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1276
#, fuzzy
msgid "If a serializer/deserializer is set by configuration, it won't be replaced by the autodetection."
msgstr "Si se establece un serializador/deserializador por configuración, no será reemplazado por la autodetección."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1279
#, fuzzy
msgid "In case you have any issues with serializer autodetection, you can switch it off completely by setting `quarkus.reactive-messaging.kafka.serializer-autodetection.enabled=false`.  If you find you need to do this, please file a bug in the link:https://github.com/quarkusio/quarkus/issues[Quarkus issue tracker] so we can fix whatever problem you have."
msgstr "En caso de que tenga algún problema con la autodetección del serializador, puede desactivarla completamente configurando `quarkus.reactive-messaging.kafka.serializer-autodetection.enabled=false` . Si encuentra que necesita hacer esto, por favor archive un error en el link:https://github.com/quarkusio/quarkus/issues[rastreador de problemas de Quarkus] para que podamos solucionar el problema que tenga."

#. type: Title ==
#: upstream/_versions/2.2/guides/kafka.adoc:1280
#, fuzzy, no-wrap
msgid "Using Schema Registry"
msgstr "Uso del registro de esquemas"

#. type: Title ==
#: upstream/_versions/2.2/guides/kafka.adoc:1285
#, fuzzy, no-wrap
msgid "Health Checks"
msgstr "Controles de salud"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1289
#, fuzzy
msgid "Quarkus provides several health checks for Kafka.  These checks are used in combination with the `quarkus-smallrye-health` extension."
msgstr "Quarkus proporciona varias comprobaciones de salud para Kafka. Estas comprobaciones se utilizan en combinación con la extensión `quarkus-smallrye-health` ."

#. type: Title ===
#: upstream/_versions/2.2/guides/kafka.adoc:1290
#, fuzzy, no-wrap
msgid "Kafka Broker Readiness Check"
msgstr "Comprobación de la disponibilidad del corredor Kafka"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1295
#, fuzzy
msgid "When using the `quarkus-kafka-client` extension, you can enable _readiness_ health check by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.  This check reports the status of the interaction with a _default_ Kafka broker (configured using `kafka.bootstrap.servers`).  It requires an _admin connection_ with the Kafka broker, and it is disabled by default.  If enabled, when you access the `/q/health/ready` endpoint of your application, you will have information about the connection validation status."
msgstr "Si utiliza la extensión `quarkus-kafka-client` , puede habilitar la comprobación del estado de _disponibilidad_ estableciendo la propiedad `quarkus.kafka.health.enabled` en `true` en su `application.properties` . Esta comprobación informa del estado de la interacción con un corredor Kafka _predeterminado_ (configurado mediante `kafka.bootstrap.servers` ). Requiere una _conexión de administrador_ con el corredor Kafka y está desactivada por defecto. Si está habilitada, cuando acceda al endpoint `/q/health/ready` de su aplicación, dispondrá de información sobre el estado de validación de la conexión."

#. type: Title ===
#: upstream/_versions/2.2/guides/kafka.adoc:1296
#, fuzzy, no-wrap
msgid "Kafka Reactive Messaging Health Checks"
msgstr "Comprobaciones de salud de la mensajería reactiva de Kafka"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1298
#, fuzzy
msgid "When using Reactive Messaging and the Kafka connector, each configured channel (incoming or outgoing) provides _startup_, _liveness_ and _readiness_ checks."
msgstr "Cuando se utiliza la Mensajería Reactiva y el conector Kafka, cada canal configurado (entrante o saliente) proporciona comprobaciones de _inicio_, _capacidad_ y _disponibilidad_."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1300
#, fuzzy
msgid "The _startup_ check verifies that the communication with Kafka cluster is established."
msgstr "La comprobación de _inicio_ verifica que se ha establecido la comunicación con el clúster Kafka."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1301
#, fuzzy
msgid "The _liveness_ check captures any unrecoverable failure happening during the communication with Kafka."
msgstr "La comprobación _de la vitalidad_ captura cualquier fallo irrecuperable que se produzca durante la comunicación con Kafka."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1302
#, fuzzy
msgid "The _readiness_ check verifies that the Kafka connector is ready to consume/produce messages to the configured Kafka topics."
msgstr "La comprobación _de disponibilidad_ verifica que el conector Kafka está listo para consumir/producir mensajes a los temas Kafka configurados."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1304
#, fuzzy
msgid "For each channel, you can disable the checks using:"
msgstr "Para cada canal, puede desactivar las comprobaciones mediante:"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1308
#, no-wrap
msgid "# Disable both liveness and readiness checks with `health-enabled=false`:\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1313
#, no-wrap
msgid ""
"# Incoming channel (receiving records form Kafka)\n"
"mp.messaging.incoming.your-channel.health-enabled=false\n"
"# Outgoing channel (writing records to Kafka)\n"
"mp.messaging.outgoing.your-channel.health-enabled=false\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1315
#, no-wrap
msgid "# Disable only the readiness check with `health-readiness-enabled=false`:\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1318
#, no-wrap
msgid ""
"mp.messaging.incoming.your-channel.health-readiness-enabled=false\n"
"mp.messaging.outgoing.your-channel.health-readiness-enabled=false\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1322
#, fuzzy
msgid "You can configure the `bootstrap.servers` for each channel using `mp.messaging.incoming|outgoing.$channel.bootstrap.servers` property.  Default is `kafka.bootstrap.servers`."
msgstr "Puede configurar el `bootstrap.servers` para cada canal utilizando la propiedad `mp.messaging.incoming|outgoing.$channel.bootstrap.servers` . Por defecto es `kafka.bootstrap.servers` ."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1326
#, fuzzy
msgid "Reactive Messaging _startup_ and _readiness_ checks offer two strategies.  The default strategy verifies that an active connection is established with the broker.  This approach is not intrusive as it's based on built-in Kafka client metrics."
msgstr "Las comprobaciones de _inicio_ y _preparación de_ la mensajería reactiva ofrecen dos estrategias. La estrategia por defecto verifica que se establece una conexión activa con el broker. Este enfoque no es intrusivo, ya que se basa en las métricas incorporadas del cliente Kafka."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1330
#, fuzzy
msgid "Using the `health-topic-verification-enabled=true` attribute, _startup_ probe uses an _admin client_ to check for the list of topics.  Whereas the _readiness_ probe for an incoming channel checks that at least one partition is assigned for consumption, and for an outgoing channel checks that the topic used by the producer exist in the broker."
msgstr "Utilizando el atributo `health-topic-verification-enabled=true` , la sonda de puesta en _marcha_ utiliza un _cliente admin_ para comprobar la lista de temas. Mientras que la sonda de _preparación_ para un canal entrante comprueba que al menos una partición está asignada para el consumo, y para un canal saliente comprueba que el tema utilizado por el productor existe en el corredor."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1333
#, fuzzy
msgid "Note that to achieve this, an _admin connection_ is required.  You can adjust the timeout for topic verification calls to the broker using the `health-topic-verification-timeout` configuration."
msgstr "Tenga en cuenta que para ello se necesita una _conexión de administrador_ . Puede ajustar el tiempo de espera de las llamadas de verificación de temas al agente mediante la configuración de `health-topic-verification-timeout` ."

#. type: Title ==
#: upstream/_versions/2.2/guides/kafka.adoc:1334
#, fuzzy, no-wrap
msgid "Kafka Streams"
msgstr "Kafka Streams"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1337
msgid "This is described in a dedicated guide: link:kafka-streams[Using Apache Kafka Streams]."
msgstr ""

#. type: Title ==
#: upstream/_versions/2.2/guides/kafka.adoc:1338
#, fuzzy, no-wrap
msgid "Using Snappy for message compression"
msgstr "Uso de Snappy para la compresión de mensajes"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1341
#, fuzzy
msgid "On _outgoing_ channels, you can enable Snappy compression by setting the `compression.type` attribute to `snappy`:"
msgstr "En los canales de _salida_, puedes activar la compresión Snappy configurando el atributo `compression.type` como `snappy`:"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1345
#, no-wrap
msgid "mp.messaging.outgoing.fruit-out.compression.type=snappy\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1349
#, fuzzy
msgid "In JVM mode, it will work out of the box.  However, to compile your application to a native executable, you need to:"
msgstr "En modo JVM, funcionará de forma inmediata. Sin embargo, para compilar su aplicación a un ejecutable nativo, necesita:"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1351
#, fuzzy
msgid "Uses GraalVM 21.+"
msgstr "Utiliza GraalVM 21.+"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1352
#, fuzzy
msgid "Add `quarkus.kafka.snappy.enabled=true` to your `application.properties`"
msgstr "Añada `quarkus.kafka.snappy.enabled=true` a su `application.properties`"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1354
#, fuzzy
msgid "In native mode, Snappy is disabled by default as the use of Snappy requires embedding a native library and unpacking it when the application starts."
msgstr "En el modo nativo, Snappy está desactivado por defecto, ya que el uso de Snappy requiere incrustar una biblioteca nativa y desempaquetarla cuando se inicia la aplicación."

#. type: Title ==
#: upstream/_versions/2.2/guides/kafka.adoc:1355
#, fuzzy, no-wrap
msgid "Authentication with OAuth"
msgstr "Autenticación con OAuth"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1359
#, fuzzy
msgid "If your Kafka broker uses OAuth as authentication mechanism, you need to configure the Kafka consumer to enable this authentication process.  First, add the following dependency to your application:"
msgstr "Si su corredor Kafka utiliza OAuth como mecanismo de autenticación, deberá configurar el consumidor Kafka para habilitar este proceso de autenticación. En primer lugar, añada la siguiente dependencia a su aplicación:"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1366
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.strimzi</groupId>\n"
"    <artifactId>kafka-oauth-client</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1370
#, fuzzy
msgid "This dependency provides the callback handler required to handle the OAuth workflow.  Then, in the `application.properties`, add:"
msgstr "Esta dependencia proporciona el controlador de devolución de llamada necesario para manejar el flujo de trabajo OAuth. A continuación, en el `application.properties` , añada:"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1380
#, no-wrap
msgid ""
"mp.messaging.connector.smallrye-kafka.security.protocol=SASL_PLAINTEXT\n"
"mp.messaging.connector.smallrye-kafka.sasl.mechanism=OAUTHBEARER\n"
"mp.messaging.connector.smallrye-kafka.sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n"
"  oauth.client.id=\"team-a-client\" \\\n"
"  oauth.client.secret=\"team-a-client-secret\" \\\n"
"  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n"
"mp.messaging.connector.smallrye-kafka.sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1382
#, no-wrap
msgid "quarkus.ssl.native=true\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1385
#, fuzzy
msgid "Update the `oauth.client.id`, `oauth.client.secret` and `oauth.token.endpoint.uri` values."
msgstr "Actualice los valores de `oauth.client.id`, `oauth.client.secret` y `oauth.token.endpoint.uri`."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1387
#, fuzzy
msgid "OAuth authentication works for both JVM and native modes. Since SSL in not enabled by default in native mode, `quarkus.ssl.native=true` must be added to support JaasClientOauthLoginCallbackHandler, which uses SSL. (See the xref:native-and-ssl.adoc[Using SSL with Native Executables] guide for more details.)"
msgstr "La autenticación OAuth funciona tanto en el modo JVM como en el nativo. Dado que SSL no está habilitado por defecto en el modo nativo, se debe añadir `quarkus.ssl.native=true` para soportar JaasClientOauthLoginCallbackHandler, que utiliza SSL. (Para más detalles, consulte la guía  link:native-and-ssl.html[Using SSL with Native Executables] )."

#. type: Title ==
#: upstream/_versions/2.2/guides/kafka.adoc:1388
#, fuzzy, no-wrap
msgid "Testing a Kafka application"
msgstr "Probar una aplicación Kafka"

#. type: Title ===
#: upstream/_versions/2.2/guides/kafka.adoc:1390
#, fuzzy, no-wrap
msgid "Testing without a broker"
msgstr "Pruebas sin intermediario"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1394
#, fuzzy
msgid "It can be useful to test the application without having to start a Kafka broker.  To achieve this, you can _switch_ the channels managed by the Kafka connector to _in-memory_."
msgstr "Puede ser útil para probar la aplicación sin tener que iniciar un corredor Kafka. Para conseguirlo, puede _cambiar_ los canales gestionados por el conector Kafka a _in-memory_ ."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1396
#, fuzzy
msgid "This approach only works for JVM tests. It cannot be used for native tests (because they do not support injection)."
msgstr "Este enfoque sólo funciona para las pruebas de la JVM. No se puede utilizar para las pruebas nativas (porque no soportan la inyección)."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1398
#, fuzzy
msgid "First, add the following dependency to your application:"
msgstr "En primer lugar, añada la siguiente dependencia a su aplicación:"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1406
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.smallrye.reactive</groupId>\n"
"    <artifactId>smallrye-reactive-messaging-in-memory</artifactId>\n"
"    <scope>test</scope>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1409
#, fuzzy
msgid "Then, create a Quarkus Test Resource as follows:"
msgstr "A continuación, cree un recurso de prueba de Quarkus de la siguiente manera:"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1413
#, no-wrap
msgid "public class KafkaTestResourceLifecycleManager implements QuarkusTestResourceLifecycleManager {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1423
#, no-wrap
msgid ""
"    @Override\n"
"    public Map<String, String> start() {\n"
"        Map<String, String> env = new HashMap<>();\n"
"        Map<String, String> props1 = InMemoryConnector.switchIncomingChannelsToInMemory(\"orders\");  // <1>\n"
"        Map<String, String> props2 = InMemoryConnector.switchOutgoingChannelsToInMemory(\"queue\");   // <2>\n"
"        env.putAll(props1);\n"
"        env.putAll(props2);\n"
"        return env;  // <3>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1429
#, no-wrap
msgid ""
"    @Override\n"
"    public void stop() {\n"
"        InMemoryConnector.clear();  // <4>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1431
msgid "Switch the incoming channel \"orders\" (expecting messages from Kafka) to in-memory."
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1432
msgid "Switch the outgoing channel \"queue\" (writing messages to Kafka) to in-memory."
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1433
#, fuzzy
msgid "Builds and returns a `Map` containing all the properties required to configure the application to use in-memory channels."
msgstr "Construye y devuelve un `Map` que contiene todas las propiedades necesarias para configurar la aplicación para utilizar canales en memoria."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1434
#, fuzzy
msgid "When the test stops, clear the `InMemoryConnector` (discard all the received and sent messages)"
msgstr "Cuando la prueba se detenga, borre el `InMemoryConnector` (descarte todos los mensajes recibidos y enviados)"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1436
#, fuzzy
msgid "Create a Quarkus Test using the test resource created above:"
msgstr "Cree una prueba de Quarkus utilizando el recurso de prueba creado anteriormente:"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1442
#, no-wrap
msgid ""
"@QuarkusTest\n"
"@QuarkusTestResource(KafkaTestResourceLifecycleManager.class)\n"
"class BaristaTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1445
#, no-wrap
msgid ""
"    @Inject\n"
"    InMemoryConnector connector; // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1450
#, no-wrap
msgid ""
"    @Test\n"
"    void testProcessOrder() {\n"
"        InMemorySource<Order> orders = connector.source(\"orders\"); // <2>\n"
"        InMemorySink<Beverage> queue = connector.sink(\"queue\");    // <3>\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1455
#, no-wrap
msgid ""
"        Order order = new Order();\n"
"        order.setProduct(\"coffee\");\n"
"        order.setName(\"Coffee lover\");\n"
"        order.setOrderId(\"1234\");\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1457
#, no-wrap
msgid "        orders.send(order);  // <4>\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1459
#, no-wrap
msgid "        await().<List<? extends Message<Beverage>>>until(queue::received, t -> t.size() == 1); // <5>\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1466
#, no-wrap
msgid ""
"        Beverage queuedBeverage = queue.received().get(0).getPayload();\n"
"        Assertions.assertEquals(Beverage.State.READY, queuedBeverage.getPreparationState());\n"
"        Assertions.assertEquals(\"coffee\", queuedBeverage.getBeverage());\n"
"        Assertions.assertEquals(\"Coffee lover\", queuedBeverage.getCustomer());\n"
"        Assertions.assertEquals(\"1234\", queuedBeverage.getOrderId());\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1470
#, fuzzy
msgid "Inject the in-memory connector in your test class."
msgstr "Inyecte el conector en memoria en su clase de prueba."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1471
#, fuzzy
msgid "Retrieve the incoming channel (`orders`) - the channel must have been switched to in-memory in the test resource."
msgstr "Recuperar el canal de entrada ( `orders`) - el canal debe haber sido cambiado a la memoria en el recurso de prueba."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1472
msgid "Retrieve the outgoing channel (`queue`) - the channel must have been switched to in-memory in the test resource."
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1473
msgid "Use the `send` method to send a message to the `orders` channel. So, the application will process this message."
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1474
msgid "Use the `received` method to check the messages produced by the application."
msgstr ""

#. type: Title ===
#: upstream/_versions/2.2/guides/kafka.adoc:1475
#, fuzzy, no-wrap
msgid "Starting Kafka in a test resource"
msgstr "Iniciar Kafka en un recurso de prueba"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1479
#, fuzzy
msgid "Alternatively, you can start a Kafka broker in a test resource.  The following snippet shows a test resource starting a Kafka broker using https://www.testcontainers.org/modules/kafka/[Testcontainers]:"
msgstr "Como alternativa, puede iniciar un corredor Kafka en un recurso de prueba. El siguiente fragmento muestra un recurso de prueba que inicia un corredor Kafka utilizando link:https://www.testcontainers.org/modules/kafka/[Testcontainers] :"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1483
#, no-wrap
msgid "public class KafkaResource implements QuarkusTestResourceLifecycleManager {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1485
#, no-wrap
msgid "    private final KafkaContainer kafka = new KafkaContainer();\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1491
#, no-wrap
msgid ""
"    @Override\n"
"    public Map<String, String> start() {\n"
"        kafka.start();\n"
"        return Collections.singletonMap(\"kafka.bootstrap.servers\", kafka.getBootstrapServers());  // <1>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1497
#, no-wrap
msgid ""
"    @Override\n"
"    public void stop() {\n"
"        kafka.close();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1499
#, fuzzy
msgid "Configure the Kafka bootstrap location, so the application connects to this broker."
msgstr "Configurar la ubicación del bootstrap de Kafka, para que la aplicación se conecte a este broker."

#. type: Title ==
#: upstream/_versions/2.2/guides/kafka.adoc:1503
#, fuzzy, no-wrap
msgid "Kubernetes Service Bindings"
msgstr "Enlaces de servicio Kubernetes"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1508
msgid "Quarkus Kafka extension supports link:deploying-to-kubernetes[Service Binding Specification for Kubernetes].  You can enable this by adding the `quarkus-kubernetes-service-binding` extension to your application."
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1510
#, fuzzy
msgid "When running in appropriately configured Kubernetes clusters, Kafka extension will pull its Kafka broker connection configuration from the service binding available inside the cluster, without the need for user configuration."
msgstr "Cuando se ejecuta en clústeres de Kubernetes debidamente configurados, la extensión de Kafka extraerá su configuración de conexión del broker de Kafka del enlace de servicio disponible dentro del clúster, sin necesidad de configuración por parte del usuario."

#. type: Title ==
#: upstream/_versions/2.2/guides/kafka.adoc:1511
#, fuzzy, no-wrap
msgid "Execution model"
msgstr "Modelo de ejecución"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1516
#, fuzzy
msgid "Reactive Messaging invokes user's methods on an I/O thread.  Thus, by default, the methods must not block.  As described in <<blocking-processing>>, you need to add the `@Blocking` annotation on the method if this method will block the caller thread."
msgstr "La mensajería reactiva invoca los métodos del usuario en un hilo de E/S. Así, por defecto, los métodos no deben bloquearse. Como se describe en <<blocking-processing>> , es necesario añadir la anotación `@Blocking` en el método si éste va a bloquear el hilo de la llamada."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1518
#, fuzzy
msgid "See the xref:quarkus-reactive-architecture.adoc[Quarkus Reactive Architecture documentation] for further details on this topic."
msgstr "Consulte la  link:quarkus-reactive-architecture.html[documentación de la Arquitectura Reactiva de Quarkus] para obtener más detalles sobre este tema."

#. type: Title ==
#: upstream/_versions/2.2/guides/kafka.adoc:1520
#, fuzzy, no-wrap
msgid "Configuration Reference"
msgstr "Referencia de configuración"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1524
msgid "More details about the SmallRye Reactive Messaging configuration can be found in the https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.6/kafka/kafka.html[SmallRye Reactive Messaging - Kafka Connector Documentation].  The most important attributes are listed in the tables below:"
msgstr ""

#. type: Title ===
#: upstream/_versions/2.2/guides/kafka.adoc:1525
#, fuzzy, no-wrap
msgid "Incoming channel configuration (polling from Kafka)"
msgstr "Configuración del canal de entrada (polling desde Kafka)"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1528
#: upstream/_versions/2.2/guides/kafka.adoc:1546
#, fuzzy
msgid "The following attributes are configured using:"
msgstr "Los siguientes atributos se configuran utilizando:"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1532
#, no-wrap
msgid "mp.messaging.incoming.your-channel-name.attribute=value\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1535
#: upstream/_versions/2.2/guides/kafka.adoc:1554
#, fuzzy
msgid "Some properties have aliases which can be configured globally:"
msgstr "Algunas propiedades tienen alias que pueden configurarse globalmente:"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1539
#: upstream/_versions/2.2/guides/kafka.adoc:1558
#, no-wrap
msgid "kafka.bootstrap.servers=...\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/2.2/guides/kafka.adoc:1543
#, fuzzy, no-wrap
msgid "Outgoing channel configuration (writing to Kafka)"
msgstr "Configuración del canal de salida (escritura en Kafka)"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1551
#, no-wrap
msgid "mp.messaging.outgoing.your-channel-name.attribute=value\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/2.2/guides/kafka.adoc:1562
#, fuzzy, no-wrap
msgid "Integrating with Kafka - Common patterns"
msgstr "Integración con Kafka - Patrones comunes"

#. type: Title ===
#: upstream/_versions/2.2/guides/kafka.adoc:1564
#, fuzzy, no-wrap
msgid "Writing to Kafka from an HTTP endpoint"
msgstr "Escribir en Kafka desde un punto final HTTP"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1567
#, fuzzy
msgid "To send messages to Kafka from an HTTP endpoint, inject an `Emitter` (or a `MutinyEmitter`) in your endpoint:"
msgstr "Para enviar mensajes a Kafka desde un endpoint HTTP, inyecte un `Emitter` (o un `MutinyEmitter`) en su endpoint:"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1571
#: upstream/_versions/2.2/guides/kafka.adoc:1619
#: upstream/_versions/2.2/guides/kafka.adoc:1660
#: upstream/_versions/2.2/guides/kafka.adoc:1678
#: upstream/_versions/2.2/guides/kafka.adoc:1709
#: upstream/_versions/2.2/guides/kafka.adoc:1741
#: upstream/_versions/2.2/guides/kafka.adoc:1760
#: upstream/_versions/2.2/guides/kafka.adoc:1795
#: upstream/_versions/2.2/guides/kafka.adoc:1838
#: upstream/_versions/2.2/guides/kafka.adoc:1879
#, no-wrap
msgid "package org.acme;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1573
#: upstream/_versions/2.2/guides/kafka.adoc:1621
#: upstream/_versions/2.2/guides/kafka.adoc:1840
#, no-wrap
msgid "import java.util.concurrent.CompletionStage;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1578
#: upstream/_versions/2.2/guides/kafka.adoc:1626
#, no-wrap
msgid ""
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1584
#: upstream/_versions/2.2/guides/kafka.adoc:1634
#: upstream/_versions/2.2/guides/kafka.adoc:1850
#, no-wrap
msgid ""
"@Path(\"/\")\n"
"public class ResourceSendingToKafka {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1586
#, no-wrap
msgid "    @Channel(\"kafka\") Emitter<String> emitter;          // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1593
#, no-wrap
msgid ""
"    @POST\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public CompletionStage<Void> send(String payload) { // <2>\n"
"        return emitter.send(payload);                   // <3>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1595
#, fuzzy
msgid "Inject an `Emitter<String>`"
msgstr "Inyectar un `Emitter&amp;lt;String&amp;gt;`"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1596
#, fuzzy
msgid "The HTTP method receives the payload and returns a `CompletionStage` completed when the message is written to Kafka"
msgstr "El método HTTP recibe la carga útil y devuelve un `CompletionStage` completado cuando el mensaje se escribe en Kafka"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1597
#, fuzzy
msgid "Send the message to Kafka, the `send` method returns a `CompletionStage`"
msgstr "Enviar el mensaje a Kafka, el método `send` devuelve un `CompletionStage`"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1600
#, fuzzy
msgid "The endpoint sends the passed payload (from a `POST` HTTP request) to the emitter.  The emitter's channel is mapped to a Kafka topic in the `application.properties` file:"
msgstr "El punto final envía la carga útil pasada (de una solicitud HTTP `POST` ) al emisor. El canal del emisor se asigna a un tema Kafka en el archivo `application.properties` :"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1605
#, no-wrap
msgid ""
"mp.messaging.outgoing.kafka.connector=smallrye-kafka\n"
"mp.messaging.outgoing.kafka.topic=my-topic\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1611
#, fuzzy
msgid "The endpoint returns a `CompletionStage` indicating the asynchronous nature of the method.  The `emitter.send` method returns a `CompletionStage<Void>` .  The returned future is completed when the message has been written to Kafka.  If the writing fails, the returned `CompletionStage` is completed exceptionally."
msgstr "El punto final devuelve un `CompletionStage` que indica la naturaleza asíncrona del método. El método `emitter.send` devuelve un `CompletionStage<Void>` . El futuro devuelto se completa cuando el mensaje se ha escrito en Kafka. Si la escritura falla, el `CompletionStage` devuelto se completa excepcionalmente."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1613
#, fuzzy
msgid "If the endpoint does not return a `CompletionStage`, the HTTP response may be written before the message is sent to Kafka, and so failures won't be reported to the user."
msgstr "Si el endpoint no devuelve un `CompletionStage`, la respuesta HTTP puede escribirse antes de que el mensaje se envíe a Kafka, por lo que los fallos no se comunicarán al usuario."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1615
#, fuzzy
msgid "If you need to send a Kafka record, use:"
msgstr "Si necesita enviar un registro Kafka, utilice"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1631
#, no-wrap
msgid "import io.smallrye.reactive.messaging.kafka.Record;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1636
#, no-wrap
msgid "    @Channel(\"kafka\") Emitter<Record<String,String>> emitter;  // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1644
#, no-wrap
msgid ""
"    @POST\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public CompletionStage<Void> send(String payload) {\n"
"        return emitter.send(Record.of(\"my-key\", payload));    // <2>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1646
#, fuzzy
msgid "Note the usage of an `Emitter<Record<K, V>>`"
msgstr "Obsérvese el uso de un `Emitter&amp;lt;Record&amp;lt;K, V&amp;gt;&amp;gt;`"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1647
#, fuzzy
msgid "Create the record using `Record.of(k, v)`"
msgstr "Cree el registro utilizando `Record.of(k, v)`"

#. type: Title ===
#: upstream/_versions/2.2/guides/kafka.adoc:1648
#, fuzzy, no-wrap
msgid "Persisting Kafka messages with Hibernate with Panache"
msgstr "Persistencia de mensajes Kafka con Hibernate con Panache"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1651
#, fuzzy
msgid "To persist objects received from Kafka into a database, you can use Hibernate with Panache."
msgstr "Para persistir los objetos recibidos de Kafka en una base de datos, puede utilizar Hibernate con Panache."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1653
#, fuzzy
msgid "If you use Hibernate Reactive, look at <<persisting-kafka-messages-with-hibernate-reactive>>."
msgstr "Si utiliza Hibernate Reactive, consulte <<persisting-kafka-messages-with-hibernate-reactive>> ."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1656
#: upstream/_versions/2.2/guides/kafka.adoc:1737
#, fuzzy
msgid "Let's imagine you receive `Fruit` objects.  For simplicity purposes, our `Fruit` class is pretty simple:"
msgstr "Imaginemos que recibe objetos `Fruit` . Para simplificar, nuestra clase `Fruit` es bastante sencilla:"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1662
#: upstream/_versions/2.2/guides/kafka.adoc:1743
#, no-wrap
msgid "import javax.persistence.Entity;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1664
#, no-wrap
msgid "import io.quarkus.hibernate.orm.panache.PanacheEntity;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1667
#: upstream/_versions/2.2/guides/kafka.adoc:1748
#, no-wrap
msgid ""
"@Entity\n"
"public class Fruit extends PanacheEntity {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1669
#: upstream/_versions/2.2/guides/kafka.adoc:1750
#, no-wrap
msgid "    public String name;\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1674
#: upstream/_versions/2.2/guides/kafka.adoc:1756
#, fuzzy
msgid "To consume `Fruit` instances stored on a Kafka topic, and persist them into a database, you can use the following approach:"
msgstr "Para consumir instancias de `Fruit` almacenadas en un tema de Kafka, y persistirlas en una base de datos, puede utilizar el siguiente enfoque:"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1685
#, no-wrap
msgid "import io.smallrye.common.annotation.Blocking;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1688
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class FruitConsumer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1696
#, no-wrap
msgid ""
"    @Incoming(\"fruits\")                                     // <1>\n"
"    @Transactional                                          // <2>\n"
"    @Blocking                                               // <3>\n"
"    public void persistFruits(Fruit fruit) {                // <4>\n"
"        fruit.persist();                                    // <5>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1698
#, fuzzy
msgid "Configuring the incoming channel. This channel reads from Kafka."
msgstr "Configurar el canal de entrada. Este canal lee de Kafka."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1699
msgid "As we are writing in a database, we must be in a transaction. This annotation starts a new transaction and commits it when the method returns."
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1700
msgid "Writing to a database using classic Hibernate is blocking. So, you must tell to Quarkus that the method must be called on a worker thread you can block (and not an I/O thread)."
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1701
#, fuzzy
msgid "The method receives each Fruit. Note that you would need a deserializer to reconstruct the Fruit instances from the Kafka records."
msgstr "El método recibe cada Fruta. Tenga en cuenta que necesitaría un deserializador para reconstruir las instancias de Fruit a partir de los registros de Kafka."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1702
#, fuzzy
msgid "Persist the received `fruit` object."
msgstr "Persiste el objeto `fruit` recibido."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1705
#, fuzzy
msgid "As mentioned in <4>, you need a deserializer that can create a `Fruit` from the record.  This can be done using a Jackson deserializer:"
msgstr "Como se mencionó en <4>, necesita un deserializador que pueda crear un `Fruit` a partir del registro. Esto puede hacerse utilizando un deserializador Jackson:"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1720
#: upstream/_versions/2.2/guides/kafka.adoc:1806
#, fuzzy
msgid "The associated configuration would be:"
msgstr "La configuración asociada sería:"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1725
#: upstream/_versions/2.2/guides/kafka.adoc:1811
#, no-wrap
msgid ""
"mp.messaging.incoming.fruits.connector=smallrye-kafka\n"
"mp.messaging.incoming.fruits.value.deserializer=org.acme.FruitDeserializer\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1729
#: upstream/_versions/2.2/guides/kafka.adoc:1815
#, fuzzy
msgid "Check <<jackson-serialization>> for more detail about the usage of Jackson with Kafka.  You can also use Avro."
msgstr "Consulte <<jackson-serialization>> para obtener más detalles sobre el uso de Jackson con Kafka. También puede utilizar Avro."

#. type: Title ===
#: upstream/_versions/2.2/guides/kafka.adoc:1731
#, fuzzy, no-wrap
msgid "Persisting Kafka messages with Hibernate Reactive"
msgstr "Persistencia de mensajes Kafka con Hibernate Reactive"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1734
#, fuzzy
msgid "To persist objects received from Kafka into a database, you can use Hibernate Reactive with Panache."
msgstr "Para persistir los objetos recibidos de Kafka en una base de datos, puede utilizar Hibernate Reactive con Panache."

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1745
#, no-wrap
msgid "import io.quarkus.hibernate.reactive.panache.PanacheEntity;  // <1>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1754
#, fuzzy
msgid "Make sure to use the reactive variant"
msgstr "Asegúrese de utilizar la variante reactiva"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1767
#, no-wrap
msgid ""
"import io.quarkus.hibernate.reactive.panache.Panache;\n"
"import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1770
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class FruitStore {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1778
#, no-wrap
msgid ""
"    @Incoming(\"fruits\")\n"
"    public Uni<Void> persist(Fruit fruit) {\n"
"        return Panache.withTransaction(() ->  // <1>\n"
"            fruit.persist()                   // <2>\n"
"                .map(persisted -> null)       // <3>\n"
"        );\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1782
#, fuzzy
msgid "Instruct Panache to run the given (asynchronous) action in a transaction. The transaction completes when the action completes."
msgstr "Indica a Panache que ejecute la acción dada (asíncrona) en una transacción. La transacción se completa cuando finaliza la acción."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1783
#, fuzzy
msgid "Persist the entity. It returns a `Uni<Fruit>`."
msgstr "Persiste la entidad. Devuelve un `Uni&amp;lt;Fruit&amp;gt;`."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1784
#, fuzzy
msgid "Switch back to a `Uni<Void>`."
msgstr "Vuelve a cambiar a un `Uni&amp;lt;Void&amp;gt;`."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1788
#, fuzzy
msgid "Unlike with _classic_ Hibernate, you can't use `@Transactional`.  Instead, we use `Panache.withTransaction` and persist our entity.  The `map` is used to return a `Uni<Void>` and not a `Uni<Fruit>`."
msgstr "A diferencia de lo que ocurre con Hibernate _clásico_ , no se puede utilizar `@Transactional` . En su lugar, utilizamos `Panache.withTransaction` y persistimos nuestra entidad. El `map` se utiliza para devolver un `Uni<Void>` y no un `Uni<Fruit>` ."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1791
#, fuzzy
msgid "You need a deserializer that can create a `Fruit` from the record.  This can be done using a Jackson deserializer:"
msgstr "Necesita un deserializador que pueda crear un `Fruit` a partir del registro. Esto puede hacerse utilizando un deserializador Jackson:"

#. type: Title ===
#: upstream/_versions/2.2/guides/kafka.adoc:1816
#, fuzzy, no-wrap
msgid "Writing entities managed by Hibernate to Kafka"
msgstr "Escritura de entidades gestionadas por Hibernate en Kafka"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1819
#, fuzzy
msgid "Let's imagine the following process:"
msgstr "Imaginemos el siguiente proceso:"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1821
#, fuzzy
msgid "You receive an HTTP request with a payload,"
msgstr "Recibe una petición HTTP con una carga útil,"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1822
#, fuzzy
msgid "You create an Hibernate entity instance from this payload,"
msgstr "Se crea una instancia de entidad Hibernate a partir de esta carga útil,"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1823
#, fuzzy
msgid "You persist that entity into a database,"
msgstr "Se persiste esa entidad en una base de datos,"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1824
#, fuzzy
msgid "You send the entity to a Kafka topic"
msgstr "Se envía la entidad a un tema Kafka"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1826
#, fuzzy
msgid "If you use Hibernate Reactive, look at <<writing-entities-managed-by-hibernate-reactive-to-kafka>>."
msgstr "Si utiliza Hibernate Reactive, consulte <<writing-entities-managed-by-hibernate-reactive-to-kafka>> ."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1832
#, fuzzy
msgid "Because we write to a database, we must run this method in a transaction.  Yet, sending the entity to Kafka happens asynchronously.  The operation returns a `CompletionStage` (or a `Uni` if you use a `MutinyEmitter`) reporting when the operation completes.  We must be sure that the transaction is still running until the object is written.  Otherwise, you may access the object outside the transaction, which is not allowed."
msgstr "Dado que escribimos en una base de datos, debemos ejecutar este método en una transacción. Sin embargo, el envío de la entidad a Kafka se produce de forma asíncrona. La operación devuelve un `CompletionStage` (o un `Uni` si utiliza un `MutinyEmitter` ) que informa cuando la operación finaliza. Debemos asegurarnos de que la transacción sigue en marcha hasta que se escribe el objeto. De lo contrario, se podría acceder al objeto fuera de la transacción, lo que no está permitido."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1834
#, fuzzy
msgid "To implement this process, you need the following approach:"
msgstr "Para llevar a cabo este proceso, es necesario el siguiente enfoque:"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1844
#, no-wrap
msgid ""
"import javax.transaction.Transactional;\n"
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.Path;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1852
#, no-wrap
msgid "    @Channel(\"kafka\") Emitter<Fruit> emitter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1861
#, no-wrap
msgid ""
"    @POST\n"
"    @Path(\"/fruits\")\n"
"    @Transactional                                                      // <1>\n"
"    public CompletionStage<Void> storeAndSendToKafka(Fruit fruit) {     // <2>\n"
"        fruit.persist();\n"
"        return emitter.send(fruit);                                     // <3>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1863
#, fuzzy
msgid "As we are writing to the database, make sure we run inside a transaction"
msgstr "Como estamos escribiendo en la base de datos, asegúrese de que se ejecuta dentro de una transacción"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1864
#, fuzzy
msgid "The method receives the fruit instance to persist. It returns a `CompletionStage` which is used for the transaction demarcation. The transaction is committed when the return `CompletionStage` completes. In our case, it's when the message is written to Kafka."
msgstr "El método recibe la instancia de la fruta a persistir. Devuelve un `CompletionStage` que se utiliza para la demarcación de la transacción. La transacción se compromete cuando se completa el retorno `CompletionStage`. En nuestro caso, es cuando el mensaje se escribe en Kafka."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1865
#, fuzzy
msgid "Send the managed instance to Kafka. Make sure we wait for the message to complete before closing the transaction."
msgstr "Envíe la instancia gestionada a Kafka. Asegúrese de que esperamos a que se complete el mensaje antes de cerrar la transacción."

#. type: Title ===
#: upstream/_versions/2.2/guides/kafka.adoc:1867
#, fuzzy, no-wrap
msgid "Writing entities managed by Hibernate Reactive to Kafka"
msgstr "Escritura de entidades gestionadas por Hibernate Reactive en Kafka"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1870
#, fuzzy
msgid "To send to Kafka entities managed by Hibernate Reactive, we recommend using:"
msgstr "Para enviar a las entidades de Kafka gestionadas por Hibernate Reactive, se recomienda utilizar:"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1872
#, fuzzy
msgid "RESTEasy Reactive to serve HTTP requests"
msgstr "RESTEasy Reactive para servir peticiones HTTP"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1873
#, fuzzy
msgid "A `MutinyEmitter` to send message to a channel, so it can be easily integrated with the Mutiny API exposed by Hibernate Reactive or Hibernate Reactive with Panache."
msgstr "Un `MutinyEmitter` para enviar mensajes a un canal, por lo que se puede integrar fácilmente con la API Mutiny expuesta por Hibernate Reactive o Hibernate Reactive con Panache."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1875
#, fuzzy
msgid "The following example demonstrates how to receive a payload, store it in the database using Hibernate Reactive with Panache, and send the persisted entity to Kafka:"
msgstr "El siguiente ejemplo demuestra cómo recibir una carga útil, almacenarla en la base de datos utilizando Hibernate Reactive con Panache, y enviar la entidad persistente a Kafka:"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1882
#, no-wrap
msgid ""
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.Path;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1888
#, no-wrap
msgid ""
"import io.quarkus.hibernate.reactive.panache.Panache;\n"
"import io.smallrye.mutiny.Uni;\n"
"import io.smallrye.reactive.messaging.MutinyEmitter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1891
#, no-wrap
msgid ""
"@Path(\"/\")\n"
"public class ReactiveGreetingResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1893
#, no-wrap
msgid "    @Channel(\"kafka\") MutinyEmitter<Fruit> emitter;     // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1903
#, no-wrap
msgid ""
"    @POST\n"
"    @Path(\"/fruits\")\n"
"    public Uni<Void> sendToKafka(Fruit fruit) {         // <2>\n"
"        return Panache.withTransaction(() ->            // <3>\n"
"            fruit.<Fruit>persist()\n"
"        )\n"
"            .chain(f -> emitter.send(f));               // <4>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1905
#, fuzzy
msgid "Inject a `MutinyEmitter` which exposes a Mutiny API. It simplifies the integration with the Mutiny API exposed by Hibernate Reactive with Panache."
msgstr "Inyecta un `MutinyEmitter` que expone una API Mutiny. Simplifica la integración con la API Mutiny expuesta por Hibernate Reactive con Panache."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1906
#, fuzzy
msgid "The HTTP method receiving the payload returns a `Uni<Void>`. The HTTP response is written when the operation completes (the entity is persisted and written to Kafka)."
msgstr "El método HTTP que recibe la carga útil devuelve un `Uni&amp;lt;Void&amp;gt;`. La respuesta HTTP se escribe cuando la operación se completa (la entidad se persiste y se escribe en Kafka)."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1907
#, fuzzy
msgid "We need to write the entity into the database in a transaction."
msgstr "Necesitamos escribir la entidad en la base de datos en una transacción."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1908
#, fuzzy
msgid "Once the persist operation completes, we send the entity to Kafka. The `send` method returns a `Uni<Void>`."
msgstr "Una vez completada la operación de persistencia, enviamos la entidad a Kafka. El método `send` devuelve un `Uni&amp;lt;Void&amp;gt;`."

#. type: Title ===
#: upstream/_versions/2.2/guides/kafka.adoc:1910
#, fuzzy, no-wrap
msgid "Streaming Kafka topics as server-sent events"
msgstr "Transmisión de temas Kafka como eventos enviados por el servidor"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1913
#, fuzzy
msgid "Streaming a Kafka topic as server-sent events (SSE) is straightforward:"
msgstr "La transmisión de un tema de Kafka como eventos enviados por el servidor (SSE) es sencilla:"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1915
#, fuzzy
msgid "You inject the channel representing the Kafka topic in your HTTP endpoint"
msgstr "Se inyecta el canal que representa el tema de Kafka en su punto final HTTP"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1916
#, fuzzy
msgid "You return that channel as a `Publisher` or a `Multi` from the HTTP method"
msgstr "Se devuelve ese canal como un `Publisher` o un `Multi` desde el método HTTP"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1918
#, fuzzy
msgid "The following code provides an example:"
msgstr "El siguiente código proporciona un ejemplo:"

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1923
#: upstream/_versions/2.2/guides/kafka.adoc:1938
#, no-wrap
msgid ""
"@Channel(\"fruits\")\n"
"Multi<Fruit> fruits;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1929
#, no-wrap
msgid ""
"@GET\n"
"@Produces(MediaType.SERVER_SENT_EVENTS)\n"
"public Multi<Fruit> stream() {\n"
"    return fruits;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1933
#, fuzzy
msgid "Some environment cuts the SSE connection when there is not enough activity.  The workaround consists of sending _ping_ messages (or empty objects) periodically."
msgstr "Algunos entornos cortan la conexión SSE cuando no hay suficiente actividad. La solución consiste en enviar mensajes _ping_ (u objetos vacíos) periódicamente."

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1941
#, no-wrap
msgid ""
"@Inject\n"
"ObjectMapper mapper;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1951
#, no-wrap
msgid ""
"@GET\n"
"@Produces(MediaType.SERVER_SENT_EVENTS)\n"
"public Multi<String> stream() {\n"
"    return Multi.createBy().merging()\n"
"            .streams(\n"
"                    fruits.map(this::toJson),\n"
"                    getPingStream()\n"
"            );\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1956
#, no-wrap
msgid ""
"Multi<String> emitAPeriodicPing() {\n"
"    return Multi.createFrom().ticks().every(Duration.ofSeconds(10))\n"
"            .onItem().transform(x -> \"{}\");\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/2.2/guides/kafka.adoc:1964
#, no-wrap
msgid ""
"private String toJson(Fruit f) {\n"
"    try {\n"
"        return mapper.writeValueAsString(f);\n"
"    } catch (JsonProcessingException e) {\n"
"        throw new RuntimeException(e);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1968
#, fuzzy
msgid "The workaround is a bit more complex as besides sending the fruits coming from Kafka, we need to send pings periodically.  To achieve this we merge the stream coming from Kafka and a periodic stream emitting `{}` every 10 seconds."
msgstr "La solución es un poco más compleja, ya que además de enviar los frutos procedentes de Kafka, necesitamos enviar pings periódicamente. Para ello fusionamos el flujo procedente de Kafka y un flujo periódico que emite `{}` cada 10 segundos."

#. type: Title ==
#: upstream/_versions/2.2/guides/kafka.adoc:1969
#, fuzzy, no-wrap
msgid "Going further"
msgstr "Ir más allá"

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1973
#, fuzzy
msgid "This guide has shown how you can interact with Kafka using Quarkus.  It utilizes SmallRye Reactive Messaging to build data streaming applications."
msgstr "Esta guía ha mostrado cómo se puede interactuar con Kafka utilizando Quarkus. Utiliza SmallRye Reactive Messaging para construir aplicaciones de flujo de datos."

#. type: Plain text
#: upstream/_versions/2.2/guides/kafka.adoc:1974
#, fuzzy
msgid "If you want to go further, check the documentation of https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging], the implementation used in Quarkus."
msgstr "Si quieres ir más allá, consulta la documentación de  link:https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging], la implementación utilizada en Quarkus."
