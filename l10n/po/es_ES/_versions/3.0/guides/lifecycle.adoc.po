# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-01-20 14:16+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: es_ES\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_versions/3.0/guides/lifecycle.adoc:6
#, fuzzy, no-wrap
msgid "Application Initialization and Termination"
msgstr "Inicialización y finalización de la aplicación"

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:13
#, fuzzy
msgid "You often need to execute custom actions when the application starts and clean up everything when the application stops.  This guide explains how to:"
msgstr "A menudo necesita ejecutar acciones personalizadas cuando se inicia la aplicación y limpiarlo todo cuando ésta se detiene. Esta guía le explica cómo hacerlo:"

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:15
#, fuzzy
msgid "Write a Quarkus application with a main method"
msgstr "Escribir una aplicación Quarkus con un método main"

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:16
#, fuzzy
msgid "Write command mode applications that run a task and then terminate"
msgstr "Escribir aplicaciones en modo comando que ejecutan una tarea y luego terminan"

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:17
#, fuzzy
msgid "Be notified when the application starts"
msgstr "Recibir una notificación cuando se inicie la aplicación"

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:18
#, fuzzy
msgid "Be notified when the application stops"
msgstr "Recibir una notificación cuando la aplicación se detenga"

#. type: Title ==
#: upstream/_versions/3.0/guides/lifecycle.adoc:19
#, fuzzy, no-wrap
msgid "Prerequisites"
msgstr "Requisitos previos"

#. type: Title ==
#: upstream/_versions/3.0/guides/lifecycle.adoc:23
#, fuzzy, no-wrap
msgid "Solution"
msgstr "Solución"

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:27
msgid "We recommend that you follow the instructions in the next sections and create the application step by step.  However, you can go right to the completed example."
msgstr "Le recomendamos que siga las instrucciones de las siguientes secciones y cree la aplicación paso a paso. Sin embargo, puede ir directamente al ejemplo completado."

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:29
msgid "Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive]."
msgstr "Clone el repositorio Git: `git clone {quickstarts-clone-url}` o descargue un {quickstarts-archive-url}[archivo]."

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:31
#, fuzzy
msgid "The solution is located in the `lifecycle-quickstart` {quickstarts-tree-url}/lifecycle-quickstart[directory]."
msgstr "La solución se encuentra en `lifecycle-quickstart` {quickstarts-tree-url}/lifecycle-quickstart[directorio]."

#. type: Title ==
#: upstream/_versions/3.0/guides/lifecycle.adoc:32
#, fuzzy, no-wrap
msgid "Creating the Maven project"
msgstr "Creación del proyecto Maven"

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:35
#, fuzzy
msgid "First, we need a new project. Create a new project with the following command:"
msgstr "En primer lugar, necesitamos un nuevo proyecto. Cree un nuevo proyecto con el siguiente comando:"

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:40
#, fuzzy
msgid "It generates:"
msgstr "Genera:"

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:42
#, fuzzy
msgid "the Maven structure"
msgstr "la estructura de Maven"

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:43
#, fuzzy
msgid "example `Dockerfile` files for both `native` and `jvm` modes"
msgstr "ejemplo de archivos `Dockerfile` para los modos `native` y `jvm`"

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:44
#, fuzzy
msgid "the application configuration file"
msgstr "el archivo de configuración de la aplicación"

#. type: Title ==
#: upstream/_versions/3.0/guides/lifecycle.adoc:45
#, fuzzy, no-wrap
msgid "The main method"
msgstr "El método principal"

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:49
#, fuzzy
msgid "By default, Quarkus will automatically generate a main method, that will bootstrap Quarkus and then just wait for shutdown to be initiated. Let's provide our own main method:"
msgstr "Por defecto, Quarkus generará automáticamente un método main, que arrancará Quarkus y luego sólo esperará a que se inicie el apagado. Proporcionemos nuestro propio método main:"

#. type: delimited block -
#: upstream/_versions/3.0/guides/lifecycle.adoc:52
#: upstream/_versions/3.0/guides/lifecycle.adoc:88
#, no-wrap
msgid "package com.acme;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/3.0/guides/lifecycle.adoc:55
#, no-wrap
msgid ""
"import io.quarkus.runtime.annotations.QuarkusMain;\n"
"import io.quarkus.runtime.Quarkus;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/3.0/guides/lifecycle.adoc:58
#, no-wrap
msgid ""
"@QuarkusMain  <1>\n"
"public class Main {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/3.0/guides/lifecycle.adoc:64
#, no-wrap
msgid ""
"    public static void main(String ... args) {\n"
"        System.out.println(\"Running main method\");\n"
"        Quarkus.run(args); <2>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:66
#, fuzzy
msgid "This annotation tells Quarkus to use this as the main method, unless it is overridden in the config"
msgstr "Esta anotación le dice a Quarkus que use este método como el principal, a menos que sea anulado en la configuración"

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:67
#, fuzzy
msgid "This launches Quarkus"
msgstr "Esto lanza a Quarkus"

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:71
#, fuzzy
msgid "This main class will bootstrap Quarkus and run it until it stops. This is no different to the automatically generated main class, but has the advantage that you can just launch it directly from the IDE without needing to run a Maven or Gradle command."
msgstr "Esta clase principal arrancará Quarkus y lo ejecutará hasta que se detenga. Esto no difiere de la clase principal generada automáticamente, pero tiene la ventaja de que puede lanzarla directamente desde el IDE sin necesidad de ejecutar un comando de Maven o Gradle."

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:75
#, fuzzy
msgid "It is not recommenced to do any business logic in this main method, as Quarkus has not been set up yet, and Quarkus may run in a different ClassLoader. If you want to perform logic on startup use an `io.quarkus.runtime.QuarkusApplication` as described below."
msgstr "No se recomienda realizar ninguna lógica de negocio en este método principal, ya que Quarkus no se ha configurado todavía, y Quarkus puede ejecutarse en un ClassLoader diferente. Si desea realizar lógica en el arranque utilice un `io.quarkus.runtime.QuarkusApplication` como se describe a continuación."

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:79
#, fuzzy
msgid "If we want to actually perform business logic on startup (or write applications that complete a task and then exit)  we need to supply a `io.quarkus.runtime.QuarkusApplication` class to the run method. After Quarkus has been started the `run` method of the application will be invoked. When this method returns the Quarkus application will exit."
msgstr "Si queremos realizar realmente lógica de negocio al arrancar (o escribir aplicaciones que completen una tarea y luego salgan) necesitamos suministrar una clase `io.quarkus.runtime.QuarkusApplication` al método de ejecución. Una vez iniciado Quarkus, se invocará al método `run` de la aplicación. Cuando este método retorne, la aplicación Quarkus saldrá."

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:82
#, fuzzy
msgid "If you want to perform logic on startup you should call `Quarkus.waitForExit()`, this method will wait until a shutdown is requested (either from an external signal like when you press `Ctrl+C` or because a thread has called `Quarkus.asyncExit()`)."
msgstr "Si desea realizar una lógica en el arranque deberá llamar a `Quarkus.waitForExit()` , este método esperará hasta que se solicite el cierre (ya sea desde una señal externa como cuando se pulsa `Ctrl+C` o porque un hilo ha llamado a `Quarkus.asyncExit()` )."

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:84
#, fuzzy
msgid "An example of what this looks like is below:"
msgstr "A continuación se muestra un ejemplo de este aspecto:"

#. type: delimited block -
#: upstream/_versions/3.0/guides/lifecycle.adoc:92
#, no-wrap
msgid ""
"import io.quarkus.runtime.Quarkus;\n"
"import io.quarkus.runtime.QuarkusApplication;\n"
"import io.quarkus.runtime.annotations.QuarkusMain;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/3.0/guides/lifecycle.adoc:98
#, no-wrap
msgid ""
"@QuarkusMain\n"
"public class Main {\n"
"    public static void main(String... args) {\n"
"        Quarkus.run(MyApp.class, args);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/3.0/guides/lifecycle.adoc:100
#, no-wrap
msgid "    public static class MyApp implements QuarkusApplication {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/3.0/guides/lifecycle.adoc:109
#, no-wrap
msgid ""
"        @Override\n"
"        public int run(String... args) throws Exception {\n"
"            System.out.println(\"Do startup logic here\");\n"
"            Quarkus.waitForExit();\n"
"            return 0;\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/3.0/guides/lifecycle.adoc:111
#, fuzzy, no-wrap
msgid "Injecting the command line arguments"
msgstr "Inyección de los argumentos de la línea de comandos"

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:114
#, fuzzy
msgid "It is possible to inject the arguments that were passed in on the command line:"
msgstr "Es posible inyectar los argumentos que se pasaron en la línea de comandos:"

#. type: delimited block -
#: upstream/_versions/3.0/guides/lifecycle.adoc:120
#, no-wrap
msgid ""
"@Inject\n"
"@CommandLineArguments\n"
"String[] args;\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:123
#, fuzzy
msgid "Command line arguments can be passed to the application through the `-D` flag with the property `quarkus.args`:"
msgstr "Los argumentos de la línea de comandos se pueden pasar a la aplicación a través de la bandera `-D` con la propiedad `quarkus.args`:"

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:129
#, fuzzy
msgid "For Quarkus dev mode:"
msgstr "Para el modo Quarkus dev:"

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:133
#, fuzzy
msgid "For a runner jar: `java -Dquarkus.args=<cmd-args> -jar target/quarkus-app/quarkus-run.jar`"
msgstr "Para una jarra de corredor: `java -Dquarkus.args=&amp;lt;cmd-args&amp;gt; -jar target/quarkus-app/quarkus-run.jar`"

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:134
#, fuzzy
msgid "For a native executable: `./target/lifecycle-quickstart-1.0-SNAPSHOT-runner -Dquarkus.args=<cmd-args>`"
msgstr "Para un ejecutable nativo: `./target/lifecycle-quickstart-1.0-SNAPSHOT-runner -Dquarkus.args=&amp;lt;cmd-args&amp;gt;`"

#. type: Title ==
#: upstream/_versions/3.0/guides/lifecycle.adoc:138
#, fuzzy, no-wrap
msgid "Listening for startup and shutdown events"
msgstr "Escucha de eventos de arranque y apagado"

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:142
#, fuzzy
msgid "Create a new class named `AppLifecycleBean` (or pick another name) in the `org.acme.lifecycle` package, and copy the following content:"
msgstr "Cree una nueva clase llamada `AppLifecycleBean` (o elija otro nombre) en el paquete `org.acme.lifecycle` , y copie el siguiente contenido:"

#. type: delimited block -
#: upstream/_versions/3.0/guides/lifecycle.adoc:146
#: upstream/_versions/3.0/guides/lifecycle.adoc:192
#, no-wrap
msgid "package org.acme.lifecycle;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/3.0/guides/lifecycle.adoc:149
#, no-wrap
msgid ""
"import jakarta.enterprise.context.ApplicationScoped;\n"
"import jakarta.enterprise.event.Observes;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/3.0/guides/lifecycle.adoc:153
#, no-wrap
msgid ""
"import io.quarkus.runtime.ShutdownEvent;\n"
"import io.quarkus.runtime.StartupEvent;\n"
"import org.jboss.logging.Logger;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/3.0/guides/lifecycle.adoc:156
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class AppLifecycleBean {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/3.0/guides/lifecycle.adoc:158
#, no-wrap
msgid "    private static final Logger LOGGER = Logger.getLogger(\"ListenerBean\");\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/3.0/guides/lifecycle.adoc:162
#, no-wrap
msgid ""
"    void onStart(@Observes StartupEvent ev) {               // <1>\n"
"        LOGGER.info(\"The application is starting...\");\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/3.0/guides/lifecycle.adoc:166
#, no-wrap
msgid ""
"    void onStop(@Observes ShutdownEvent ev) {               // <2>\n"
"        LOGGER.info(\"The application is stopping...\");\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/3.0/guides/lifecycle.adoc:168
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:170
#, fuzzy
msgid "Method called when the application is starting"
msgstr "Método llamado cuando la aplicación se está iniciando"

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:171
#, fuzzy
msgid "Method called when the application is terminating"
msgstr "Método llamado cuando la aplicación está terminando"

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:173
#, fuzzy
msgid "The events are also called in _dev mode_ between each redeployment."
msgstr "Los eventos también se llaman en _modo dev_ entre cada redistribución."

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:175
#, fuzzy
msgid "The methods can access injected beans. Check the {quickstarts-blob-url}/lifecycle-quickstart/src/main/java/org/acme/lifecycle/AppLifecycleBean.java[AppLifecycleBean.java] class for details."
msgstr "Los métodos pueden acceder a beans inyectados. Consulte la clase {quickstarts-blob-url}/lifecycle-quickstart/src/main/java/org/acme/lifecycle/AppLifecycleBean.java[AppLifecycleBean.java] para más detalles."

#. type: Title ===
#: upstream/_versions/3.0/guides/lifecycle.adoc:176
#, fuzzy, no-wrap
msgid "What is the difference from `@Initialized(ApplicationScoped.class)` and `@Destroyed(ApplicationScoped.class)`"
msgstr "¿Cuál es la diferencia entre `@Initialized(ApplicationScoped.class)` y `@Destroyed(ApplicationScoped.class)`"

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:181
#, fuzzy
msgid "In the JVM mode, there is no real difference, except that `StartupEvent` is always fired *after* `@Initialized(ApplicationScoped.class)` and `ShutdownEvent` is fired *before* `@Destroyed(ApplicationScoped.class)`.  For a native executable build, however, `@Initialized(ApplicationScoped.class)` is fired as *part of the native build process*, whereas `StartupEvent` is fired when the native image is executed.  See xref:writing-extensions.adoc#bootstrap-three-phases[Three Phases of Bootstrap and Quarkus Philosophy] for more details."
msgstr "En el modo JVM, no hay ninguna diferencia real, excepto que `StartupEvent` siempre se dispara *después de* `@Initialized(ApplicationScoped.class)` y `ShutdownEvent` se dispara *antes que* `@Destroyed(ApplicationScoped.class)` . Para una construcción ejecutable nativa, sin embargo, `@Initialized(ApplicationScoped.class)` se dispara como parte *del proceso de construcción nativa* , mientras que `StartupEvent` se dispara cuando se ejecuta la imagen nativa. Consulte xref:writing-extensions.adoc#bootstrap-three-phases[Tres fases de Bootstrap y Filosofía Quarkus] para obtener más detalles."

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:183
#, fuzzy
msgid "In CDI applications, an event with qualifier `@Initialized(ApplicationScoped.class)` is fired when the application context is initialized. See https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#application_context[the spec, window=\"_blank\"] for more info."
msgstr "En las aplicaciones CDI, se dispara un evento con el calificador `@Initialized(ApplicationScoped.class)` cuando se inicializa el contexto de la aplicación. Consulte  link:https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#application_context[la especificación, window=_blank] para obtener más información."

#. type: Title ===
#: upstream/_versions/3.0/guides/lifecycle.adoc:185
#, fuzzy, no-wrap
msgid "Using `@Startup` to initialize a CDI bean at application startup"
msgstr "Uso de `@Startup` para inicializar un bean CDI al inicio de la aplicación"

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:188
#, fuzzy
msgid "A bean represented by a class, producer method or field annotated with `@Startup` is initialized at application startup:"
msgstr "Un bean representado por una clase, método productor o campo anotado con `@Startup` se inicializa al iniciar la aplicación:"

#. type: delimited block -
#: upstream/_versions/3.0/guides/lifecycle.adoc:194
#, no-wrap
msgid "import jakarta.enterprise.context.ApplicationScoped;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/3.0/guides/lifecycle.adoc:198
#, no-wrap
msgid ""
"@Startup // <1> \n"
"@ApplicationScoped\n"
"public class EagerAppBean {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/3.0/guides/lifecycle.adoc:200
#, no-wrap
msgid "   private final String name;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/3.0/guides/lifecycle.adoc:205
#, no-wrap
msgid ""
"   EagerAppBean(NameGenerator generator) { // <2>\n"
"     this.name = generator.createName();\n"
"   }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:207
#, fuzzy
msgid "For each bean annotated with `@Startup` a synthetic observer of `StartupEvent` is generated. The default priority is used."
msgstr "Para cada frijol anotado con `@Startup` se genera un observador sintético de `StartupEvent`. Se utiliza la prioridad por defecto."

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:208
#, fuzzy
msgid "The bean constructor is called when the application starts and the resulting contextual instance is stored in the application context."
msgstr "El constructor del bean se llama cuando la aplicación se inicia y la instancia contextual resultante se almacena en el contexto de la aplicación."

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:210
#, fuzzy
msgid "`@Dependent` beans are destroyed immediately afterwards to follow the behavior of observers declared on `@Dependent` beans."
msgstr "`@Dependent` se destruyen inmediatamente después para seguir el comportamiento de los observadores declarados en `@Dependent` beans."

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:212
#, fuzzy
msgid "If a class is annotated with `@Startup` but with no scope annotation then `@ApplicationScoped` is added automatically."
msgstr "Si una clase está anotada con `@Startup` pero sin anotación de alcance, entonces `@ApplicationScoped` se añade automáticamente."

#. type: Title ==
#: upstream/_versions/3.0/guides/lifecycle.adoc:213
#, fuzzy, no-wrap
msgid "Package and run the application"
msgstr "Empaquetar y ejecutar la aplicación"

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:216
#, fuzzy
msgid "Run the application with:"
msgstr "Ejecuta la aplicación con:"

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:221
#, fuzzy
msgid "The logged message is printed.  When the application is stopped, the second log message is printed."
msgstr "Se imprime el mensaje de registro. Cuando se detiene la aplicación, se imprime el segundo mensaje de registro."

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:223
#, fuzzy
msgid "As usual, the application can be packaged using:"
msgstr "Como es habitual, la aplicación se puede empaquetar utilizando:"

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:227
#, fuzzy
msgid "and executed using `java -jar target/quarkus-app/quarkus-run.jar`."
msgstr "y ejecutado mediante `java -jar target/quarkus-app/quarkus-run.jar`."

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:229
#, fuzzy
msgid "You can also generate the native executable using:"
msgstr "También puede generar el ejecutable nativo utilizando:"

#. type: Title ==
#: upstream/_versions/3.0/guides/lifecycle.adoc:232
#, fuzzy, no-wrap
msgid "Launch Modes"
msgstr "Modos de lanzamiento"

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:236
#, fuzzy
msgid "Quarkus has 3 different launch modes, `NORMAL` (i.e. production), `DEVELOPMENT` and `TEST`. If you are running `quarkus:dev` then the mode will be `DEVELOPMENT`, if you are running a JUnit test it will be `TEST`, otherwise it will be `NORMAL`."
msgstr "Quarkus tiene 3 modos de lanzamiento diferentes, `NORMAL` (es decir, producción), `DEVELOPMENT` y `TEST` . Si está ejecutando `quarkus:dev` entonces el modo será `DEVELOPMENT` , si está ejecutando una prueba JUnit será `TEST` , de lo contrario será `NORMAL` ."

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:239
#, fuzzy
msgid "Your application can get the launch mode by injecting the `io.quarkus.runtime.LaunchMode` enum into a CDI bean, or by invoking the static method `io.quarkus.runtime.LaunchMode.current()`."
msgstr "Su aplicación puede obtener el modo de lanzamiento inyectando el enum `io.quarkus.runtime.LaunchMode` en un bean CDI, o invocando el método estático `io.quarkus.runtime.LaunchMode.current()` ."

#. type: Title ==
#: upstream/_versions/3.0/guides/lifecycle.adoc:240
#, fuzzy, no-wrap
msgid "Graceful Shutdown"
msgstr "Apagado gradual"

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:247
#, fuzzy
msgid "Quarkus includes support for graceful shutdown, this allows Quarkus to wait for running requests to finish, up till a set timeout. By default, this is disabled, however you can configure this by setting the `quarkus.shutdown.timeout` config property. When this is set shutdown will not happen until all running requests have completed, or until this timeout has elapsed. This config property is a duration, and can be set using the standard `java.time.Duration` format, if only a number is specified it is interpreted as seconds."
msgstr "Quarkus incluye soporte para graceful shutdown, esto permite a Quarkus esperar a que las peticiones en ejecución terminen, hasta un tiempo de espera establecido. Por defecto, esto está desactivado, sin embargo, puede configurarlo estableciendo la propiedad `quarkus.shutdown.timeout` config. Cuando esto se establece el cierre no se producirá hasta que todas las solicitudes en ejecución han terminado, o hasta que este tiempo de espera ha transcurrido. Esta propiedad config es una duración, y puede establecerse utilizando el formato estándar `java.time.Duration` , si sólo se especifica un número se interpreta como segundos."

#. type: Plain text
#: upstream/_versions/3.0/guides/lifecycle.adoc:249
#, fuzzy
msgid "Extensions that accept requests need to add support for this on an individual basis. At the moment only the HTTP extension supports this, so shutdown may still happen when messaging requests are active."
msgstr "Las extensiones que aceptan peticiones necesitan añadir soporte para esto de forma individual. Por el momento sólo la extensión HTTP soporta esto, por lo que el cierre puede seguir ocurriendo cuando las solicitudes de mensajería están activas."
