# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-10-29 08:10+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/transaction.adoc:6
#, fuzzy, no-wrap
msgid "Using Transactions in Quarkus"
msgstr "Uso de las transacciones en Quarkus"

#. type: Plain text
#: upstream/_guides/transaction.adoc:17
#, fuzzy
msgid "Quarkus comes with a Transaction Manager and uses it to coordinate and expose transactions to your applications.  Each extension dealing with persistence will integrate with it for you.  And you will explicitly interact with transactions via CDI.  This guide will walk you through all that."
msgstr "Quarkus viene con un Gestor de Transacciones y lo utiliza para coordinar y exponer las transacciones a sus aplicaciones. Cada extensión que se ocupe de la persistencia se integrará con ella por ti. Y usted interactuará explícitamente con las transacciones a través de CDI. Esta guía le guiará a través de todo esto."

#. type: Title ==
#: upstream/_guides/transaction.adoc:18
#, fuzzy, no-wrap
msgid "Setting it up"
msgstr "Cómo se prepara"

#. type: Plain text
#: upstream/_guides/transaction.adoc:22
#, fuzzy
msgid "You don't need to worry about setting it up most of the time as extensions needing it will simply add it as a dependency.  Hibernate ORM for example will include the transaction manager and set it up properly."
msgstr "La mayoría de las veces no hay que preocuparse por configurarlo, ya que las extensiones que lo necesitan simplemente lo añaden como dependencia. Hibernate ORM, por ejemplo, incluirá el gestor de transacciones y lo configurará adecuadamente."

#. type: Plain text
#: upstream/_guides/transaction.adoc:25
#, fuzzy
msgid "You might need to add it as a dependency explicitly if you are using transactions directly without Hibernate ORM for example.  Add the following to your build file:"
msgstr "Es posible que tenga que añadirlo como dependencia explícitamente si está utilizando transacciones directamente sin Hibernate ORM, por ejemplo. Añade lo siguiente a tu archivo de compilación:"

#. type: Block title
#: upstream/_guides/transaction.adoc:27
#, fuzzy, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: delimited block -
#: upstream/_guides/transaction.adoc:33
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-narayana-jta</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Block title
#: upstream/_guides/transaction.adoc:36
#, fuzzy, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#. type: delimited block -
#: upstream/_guides/transaction.adoc:39
#, no-wrap
msgid "implementation(\"io.quarkus:quarkus-narayana-jta\")\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/transaction.adoc:41
#, fuzzy, no-wrap
msgid "Starting and stopping transactions: defining your boundaries"
msgstr "Iniciar y detener las transacciones: definir los límites"

#. type: Plain text
#: upstream/_guides/transaction.adoc:45
#, fuzzy
msgid "You can define your transaction boundaries either declaratively with `@Transactional` or programmatically with `QuarkusTransaction`. You can also use the JTA `UserTransaction` API directly, however this is less user-friendly than `QuarkusTransaction`."
msgstr "Se pueden definir los límites de las transacciones de forma declarativa con `@Transactional` o de forma programada con `QuarkusTransaction`. También se puede utilizar directamente la API de JTA `UserTransaction`, aunque es menos fácil de usar que `QuarkusTransaction`."

#. type: Title ===
#: upstream/_guides/transaction.adoc:46
#, fuzzy, no-wrap
msgid "Declarative approach"
msgstr "Enfoque declarativo"

#. type: Plain text
#: upstream/_guides/transaction.adoc:49
#, fuzzy
msgid "The easiest way to define your transaction boundaries is to use the `@Transactional` annotation on your entry method (`jakarta.transaction.Transactional`)."
msgstr "La forma más sencilla de definir los límites de la transacción es utilizar la anotación `@Transactional` en su método de entrada ( `javax.transaction.Transactional`)."

#. type: delimited block -
#: upstream/_guides/transaction.adoc:54 upstream/_guides/transaction.adoc:102
#: upstream/_guides/transaction.adoc:261
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class SantaClausService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/transaction.adoc:57
#, no-wrap
msgid ""
"    @Inject ChildDAO childDAO;\n"
"    @Inject SantaClausDAO santaDAO;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/transaction.adoc:70
#, no-wrap
msgid ""
"    @Transactional // <1>\n"
"    public void getAGiftFromSanta(Child child, String giftDescription) {\n"
"        // some transaction work\n"
"        Gift gift = childDAO.addToGiftList(child, giftDescription);\n"
"        if (gift == null) {\n"
"            throw new OMGGiftNotRecognizedException(); // <2>\n"
"        }\n"
"        else {\n"
"            santaDAO.addToSantaTodoList(gift);\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/transaction.adoc:73
#, fuzzy
msgid "This annotation defines your transaction boundaries and will wrap this call within a transaction."
msgstr "Esta anotación define los límites de su transacción y envolverá esta llamada dentro de una transacción."

#. type: Plain text
#: upstream/_guides/transaction.adoc:74
#, fuzzy
msgid "A `RuntimeException` crossing the transaction boundaries will roll back the transaction."
msgstr "Un `RuntimeException` que cruce los límites de la transacción revertirá la transacción."

#. type: Plain text
#: upstream/_guides/transaction.adoc:77
#, fuzzy
msgid "`@Transactional` can be used to control transaction boundaries on any CDI bean at the method level or at the class level to ensure every method is transactional.  That includes REST endpoints."
msgstr "`@Transactional` se puede utilizar para controlar los límites de las transacciones en cualquier frijol CDI a nivel de método o a nivel de clase para asegurar que cada método es transaccional. Esto incluye los puntos finales REST."

#. type: Plain text
#: upstream/_guides/transaction.adoc:79
#, fuzzy
msgid "You can control whether and how the transaction is started with parameters on `@Transactional`:"
msgstr "Puede controlar si la transacción se inicia, y cómo, con parámetros en `@Transactional`:"

#. type: Plain text
#: upstream/_guides/transaction.adoc:81
#, fuzzy
msgid "`@Transactional(REQUIRED)` (default): starts a transaction if none was started, stays with the existing one otherwise."
msgstr "`@Transactional(REQUIRED)` (por defecto): inicia una transacción si no se ha iniciado ninguna, se queda con la existente en caso contrario."

#. type: Plain text
#: upstream/_guides/transaction.adoc:82
#, fuzzy
msgid "`@Transactional(REQUIRES_NEW)`: starts a transaction if none was started ; if an existing one was started, suspends it and starts a new one for the boundary of that method."
msgstr "`@Transactional(REQUIRES_NEW)`: inicia una transacción si no se ha iniciado ninguna; si se ha iniciado una existente, la suspende e inicia una nueva para el límite de ese método."

#. type: Plain text
#: upstream/_guides/transaction.adoc:83
#, fuzzy
msgid "`@Transactional(MANDATORY)`: fails if no transaction was started ; works within the existing transaction otherwise."
msgstr "`@Transactional(MANDATORY)`falla si no se ha iniciado ninguna transacción; en caso contrario, funciona dentro de la transacción existente."

#. type: Plain text
#: upstream/_guides/transaction.adoc:84
#, fuzzy
msgid "`@Transactional(SUPPORTS)`: if a transaction was started, joins it ; otherwise works with no transaction."
msgstr "`@Transactional(SUPPORTS)`Si se ha iniciado una transacción, se une a ella; en caso contrario, funciona sin transacción."

#. type: Plain text
#: upstream/_guides/transaction.adoc:85
#, fuzzy
msgid "`@Transactional(NOT_SUPPORTED)`: if a transaction was started, suspends it and works with no transaction for the boundary of the method ; otherwise works with no transaction."
msgstr "`@Transactional(NOT_SUPPORTED)`Si se ha iniciado una transacción, la suspende y trabaja sin transacción durante el tiempo que dure el método; en caso contrario, trabaja sin transacción."

#. type: Plain text
#: upstream/_guides/transaction.adoc:86
#, fuzzy
msgid "`@Transactional(NEVER)`: if a transaction was started, raises an exception ; otherwise works with no transaction."
msgstr "`@Transactional(NEVER)`Si se ha iniciado una transacción, lanza una excepción; en caso contrario, funciona sin transacción."

#. type: Plain text
#: upstream/_guides/transaction.adoc:90
#, fuzzy
msgid "`REQUIRED` or `NOT_SUPPORTED` are probably the most useful ones.  This is how you decide whether a method is to be running within or outside a transaction.  Make sure to check the JavaDoc for the precise semantic."
msgstr "`REQUIRED` o `NOT_SUPPORTED` son probablemente los más útiles. Así se decide si un método debe ejecutarse dentro o fuera de una transacción. Asegúrese de consultar el JavaDoc para conocer la semántica precisa."

#. type: Plain text
#: upstream/_guides/transaction.adoc:94
#, fuzzy
msgid "The transaction context is propagated to all calls nested in the `@Transactional` method as you would expect (in this example `childDAO.addToGiftList()` and `santaDAO.addToSantaTodoList()`).  The transaction will commit unless a runtime exception crosses the method boundary.  You can override whether an exception forces the rollback or not by using `@Transactional(dontRollbackOn=SomeException.class)` (or `rollbackOn`)."
msgstr "El contexto de la transacción se propaga a todas las llamadas anidadas en el método `@Transactional` como es de esperar (en este ejemplo `childDAO.addToGiftList()` y `santaDAO.addToSantaTodoList()`). La transacción se confirmará a menos que una excepción en tiempo de ejecución cruce el límite del método. Puede anular si una excepción fuerza la reversión o no utilizando `@Transactional(dontRollbackOn=SomeException.class)` (o `rollbackOn`)."

#. type: Plain text
#: upstream/_guides/transaction.adoc:97
#, fuzzy
msgid "You can also programmatically ask for a transaction to be marked for rollback.  Inject a `TransactionManager` for this."
msgstr "También se puede pedir mediante programación que se marque una transacción para su reversión. Inyecte un `TransactionManager` para esto."

#. type: delimited block -
#: upstream/_guides/transaction.adoc:106
#, no-wrap
msgid ""
"    @Inject TransactionManager tm; // <1>\n"
"    @Inject ChildDAO childDAO;\n"
"    @Inject SantaClausDAO santaDAO;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/transaction.adoc:119
#, no-wrap
msgid ""
"    @Transactional\n"
"    public void getAGiftFromSanta(Child child, String giftDescription) {\n"
"        // some transaction work\n"
"        Gift gift = childDAO.addToGiftList(child, giftDescription);\n"
"        if (gift == null) {\n"
"            tm.setRollbackOnly(); // <2>\n"
"        }\n"
"        else {\n"
"            santaDAO.addToSantaTodoList(gift);\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/transaction.adoc:122
#, fuzzy
msgid "Inject the `TransactionManager` to be able to activate `setRollbackOnly` semantic."
msgstr "Inyectar la `TransactionManager` para poder activar la semántica `setRollbackOnly`."

#. type: Plain text
#: upstream/_guides/transaction.adoc:123
#, fuzzy
msgid "Programmatically decide to set the transaction for rollback."
msgstr "Decide programar la transacción para su reversión."

#. type: Title ===
#: upstream/_guides/transaction.adoc:125
#, fuzzy, no-wrap
msgid "Transaction Configuration"
msgstr "Configuración de las transacciones"

#. type: Plain text
#: upstream/_guides/transaction.adoc:128
#, fuzzy
msgid "Advanced configuration of the transaction is possible with the use of the `@TransactionConfiguration` annotation that is set in addition to the standard `@Transactional` annotation on your entry method or at the class level."
msgstr "La configuración avanzada de la transacción es posible con el uso de la anotación `@TransactionConfiguration` que se establece además de la anotación estándar `@Transactional` en su método de entrada o a nivel de clase."

#. type: Plain text
#: upstream/_guides/transaction.adoc:130
#, fuzzy
msgid "The `@TransactionConfiguration` annotation allows to set a timeout property, in seconds, that applies to transactions created within the annotated method."
msgstr "La anotación `@TransactionConfiguration` permite establecer una propiedad de tiempo de espera, en segundos, que se aplica a las transacciones creadas dentro del método anotado."

#. type: Plain text
#: upstream/_guides/transaction.adoc:133
#, fuzzy
msgid "This annotation may only be placed on the top level method delineating the transaction.  Annotated nested methods once a transaction has started will throw an exception."
msgstr "Esta anotación sólo puede colocarse en el método de nivel superior que delimita la transacción. Los métodos anidados con esta anotación, una vez iniciada la transacción, lanzarán una excepción."

#. type: Plain text
#: upstream/_guides/transaction.adoc:136
#, fuzzy
msgid "If defined on a class, it is equivalent to defining it on all the methods of the class marked with `@Transactional`.  The configuration defined on a method takes precedence over the configuration defined on a class."
msgstr "Si se define sobre una clase, equivale a definirla sobre todos los métodos de la clase marcados con `@Transactional`. La configuración definida en un método tiene prioridad sobre la configuración definida en una clase."

#. type: Title ===
#: upstream/_guides/transaction.adoc:137
#, fuzzy, no-wrap
msgid "Reactive extensions"
msgstr "Extensiones reactivas"

#. type: Plain text
#: upstream/_guides/transaction.adoc:140
#, fuzzy
msgid "If your `@Transactional`-annotated method returns a reactive value, such as:"
msgstr "Si su método `@Transactional`-anotado devuelve un valor reactivo, como:"

#. type: Plain text
#: upstream/_guides/transaction.adoc:142
#, fuzzy
msgid "`CompletionStage` (from the JDK)"
msgstr "`CompletionStage` (del JDK)"

#. type: Plain text
#: upstream/_guides/transaction.adoc:143
#, fuzzy
msgid "`Publisher` (from Reactive-Streams)"
msgstr "`Publisher` (de Reactive-Streams)"

#. type: Plain text
#: upstream/_guides/transaction.adoc:144
#, fuzzy
msgid "Any type which can be converted to one of the two previous types using Reactive Type Converters"
msgstr "Cualquier tipo que se pueda convertir en uno de los dos tipos anteriores mediante los convertidores de tipos reactivos"

#. type: Plain text
#: upstream/_guides/transaction.adoc:149
#, fuzzy
msgid "then the behaviour is a bit different, because the transaction will not be terminated until the returned reactive value is terminated. In effect, the returned reactive value will be listened to and if it terminates exceptionally the transaction will be marked for rollback, and will be committed or rolled-back only at termination of the reactive value."
msgstr "entonces el comportamiento es un poco diferente, porque la transacción no se terminará hasta que el valor reactivo devuelto se termine. En efecto, el valor reactivo devuelto será escuchado y si termina excepcionalmente la transacción será marcada para rollback, y será comprometida o rollback sólo a la terminación del valor reactivo."

#. type: Plain text
#: upstream/_guides/transaction.adoc:152
#, fuzzy
msgid "This allows your reactive methods to keep on working on the transaction asynchronously until their work is really done, and not just until the reactive method returns."
msgstr "Esto permite que tus métodos reactivos sigan trabajando en la transacción de forma asíncrona hasta que su trabajo esté realmente hecho, y no sólo hasta que el método reactivo regrese."

#. type: Plain text
#: upstream/_guides/transaction.adoc:155
#, fuzzy
msgid "If you need to propagate your transaction context across your reactive pipeline, please see the xref:context-propagation.adoc[Context Propagation guide]."
msgstr "Si necesita propagar su contexto de transacción a través de su canalización reactiva, por favor, consulte la  link:context-propagation.html[guía de Propagación de Contexto]."

#. type: Title ===
#: upstream/_guides/transaction.adoc:156
#, fuzzy, no-wrap
msgid "Programmatic Approach"
msgstr "Enfoque programático"

#. type: Plain text
#: upstream/_guides/transaction.adoc:161
#, fuzzy
msgid "You can use static methods on `QuarkusTransaction` to define transaction boundaries. This provides two different options, a functional approach that allows you to run a lambda within the scope of a transaction, or by using explicit `begin`, `commit` and `rollback` methods."
msgstr "Puedes utilizar métodos estáticos en `QuarkusTransaction` para definir los límites de las transacciones. Esto proporciona dos opciones diferentes, un enfoque funcional que le permite ejecutar un lambda dentro del ámbito de una transacción, o mediante el uso de métodos explícitos `begin`, `commit` y `rollback`."

#. type: delimited block -
#: upstream/_guides/transaction.adoc:166
#, no-wrap
msgid ""
"import io.quarkus.narayana.jta.QuarkusTransaction;\n"
"import io.quarkus.narayana.jta.RunOptions;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/transaction.adoc:168
#, no-wrap
msgid "public class TransactionExample {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/transaction.adoc:173
#, no-wrap
msgid ""
"    public void beginExample() {\n"
"        QuarkusTransaction.begin();\n"
"        //do work\n"
"        QuarkusTransaction.commit();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/transaction.adoc:179
#, no-wrap
msgid ""
"        QuarkusTransaction.begin(QuarkusTransaction.beginOptions()\n"
"                .timeout(10));\n"
"        //do work\n"
"        QuarkusTransaction.rollback();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/transaction.adoc:187
#, no-wrap
msgid ""
"    public void runnerExample() {\n"
"        QuarkusTransaction.requiringNew().run(() -> {\n"
"            //do work\n"
"        });\n"
"        QuarkusTransaction.joiningExisting().run(() -> {\n"
"            //do work\n"
"        });\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/transaction.adoc:202
#, no-wrap
msgid ""
"        int result = QuarkusTransaction.requiringNew()\n"
"                .timeout(10)\n"
"                .exceptionHandler((throwable) -> {\n"
"                    if (throwable instanceof SomeException) {\n"
"                        return RunOptions.ExceptionResult.COMMIT;\n"
"                    }\n"
"                    return TransactionExceptionResult.ROLLBACK;\n"
"                })\n"
"                .call(() -> {\n"
"                    //do work\n"
"                    return 0;\n"
"                });\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/transaction.adoc:205
#, fuzzy
msgid "The above example shows a few different ways the API can be used."
msgstr "El ejemplo anterior muestra algunas formas diferentes de utilizar la API."

#. type: Plain text
#: upstream/_guides/transaction.adoc:211
#, fuzzy
msgid "The first method simply calls begin, does some work and commits it.  This created transaction is tied to the CDI request scope, so if it is still active when the request scope is destroyed then it will be automatically rolled back. This removes the need to explicitly catch exceptions and call `rollback`, and acts as a safety net against inadvertent transaction leaks, however it does mean that this can only be used when the request scope is active. The second example in the method calls begin with a timeout option, and then rolls back the transaction."
msgstr "El ejemplo anterior muestra algunas formas diferentes de utilizar la API. El primer método simplemente llama a begin, realiza algún trabajo y lo consigna. Esta transacción creada está ligada al ámbito de la solicitud del CDI, por lo que si todavía está activa cuando el ámbito de la solicitud se destruye, se revertirá automáticamente. Esto elimina la necesidad de capturar explícitamente las excepciones y llamar a `rollback`, y actúa como una red de seguridad contra las fugas inadvertidas de transacciones, sin embargo, significa que esto sólo se puede utilizar cuando el ámbito de la solicitud está activo. El segundo ejemplo en las llamadas al método comienza con una opción de tiempo de espera, y luego hace retroceder la transacción."

#. type: Plain text
#: upstream/_guides/transaction.adoc:217
#, fuzzy
msgid "The second method shows the use of lambda scoped transactions with `QuarkusTransaction.runner(...)`; the first example just runs a `Runnable` within a new transaction, the second does the same but joining the existing transaction (if any), and the third calls a `Callable` with some specific options.  In particular the `exceptionHandler` method can be used to control if the transaction is rolled back or not on exception."
msgstr "El segundo ejemplo muestra el uso de transacciones de ámbito lambda, el primero sólo ejecuta un `Runnable` dentro de una transacción, el segundo, ejecuta `Callable` con algunas opciones específicas. En particular, el método `exceptionHandler` puede ser utilizado para controlar si la transacción es revertida o no en caso de excepción, y el método `semantic` controla el comportamiento si una transacción existente ya está iniciada."

#. type: Plain text
#: upstream/_guides/transaction.adoc:219
#, fuzzy
msgid "The following semantics are supported:"
msgstr "Se admiten las siguientes semánticas:"

#. type: Labeled list
#: upstream/_guides/transaction.adoc:221
#, fuzzy, no-wrap
msgid "`QuarkusTransaction.disallowingExisting()`/`DISALLOW_EXISTING`"
msgstr "`QuarkusTransaction.disallowingExisting()`/ `DISALLOW_EXISTING`"

#. type: Plain text
#: upstream/_guides/transaction.adoc:225
#, fuzzy
msgid "If a transaction is already associated with the current thread a `QuarkusTransactionException` will be thrown, otherwise a new transaction is started, and follows all the normal lifecycle rules."
msgstr "Si una transacción ya está asociada con el hilo actual se lanzará un `QuarkusTransactionException`, de lo contrario se inicia una nueva transacción, y sigue todas las reglas normales del ciclo de vida."

#. type: Labeled list
#: upstream/_guides/transaction.adoc:226
#, fuzzy, no-wrap
msgid "`QuarkusTransaction.joiningExisting()`/`JOIN_EXISTING`"
msgstr "`QuarkusTransaction.joiningExisting()`/ `JOIN_EXISTING`"

#. type: Plain text
#: upstream/_guides/transaction.adoc:235
#, fuzzy
msgid "If no transaction is active then a new transaction will be started, and committed when the method ends.  If an exception is thrown the exception handler registered by `#exceptionHandler(Function)` will be called to decide if the TX should be committed or rolled back.  If an existing transaction is active then the method is run in the context of the existing transaction. If an exception is thrown the exception handler will be called, however a result of `ExceptionResult#ROLLBACK` will result in the TX marked as rollback only, while a result of `ExceptionResult#COMMIT` will result in no action being taken."
msgstr "Si no hay ninguna transacción activa, se iniciará una nueva transacción y se confirmará cuando el método finalice. Si se lanza una excepción, se llamará al manejador de excepciones registrado por `#exceptionHandler(Function)` para decidir si la transacción debe ser confirmada o revertida. Si hay una transacción activa, el método se ejecuta en el contexto de la transacción existente. Si se lanza una excepción se llamará al manejador de excepciones, sin embargo un resultado de `ExceptionResult#ROLLBACK` hará que la TX sea marcada como rollback solamente, mientras que un resultado de `ExceptionResult#COMMIT` hará que no se realice ninguna acción."

#. type: Labeled list
#: upstream/_guides/transaction.adoc:236
#, fuzzy, no-wrap
msgid "`QuarkusTransaction.requiringNew()`/`REQUIRE_NEW`"
msgstr "`QuarkusTransaction.requiringNew()`/ `REQUIRE_NEW`"

#. type: Plain text
#: upstream/_guides/transaction.adoc:242
#, fuzzy
msgid "If an existing transaction is already associated with the current thread then the transaction is suspended, then a new transaction is started which follows all the normal lifecycle rules, and when it's complete the original transaction is resumed.  Otherwise, a new transaction is started, and follows all the normal lifecycle rules."
msgstr "Esta es la semántica por defecto. Si una transacción existente ya está asociada con el hilo actual, entonces la transacción se suspende, y se reanuda una vez que la transacción actual se ha completado. Una nueva transacción se inicia después de que la transacción existente se suspende, y sigue todas las reglas normales del ciclo de vida."

#. type: Labeled list
#: upstream/_guides/transaction.adoc:243
#, fuzzy, no-wrap
msgid "`QuarkusTransaction.suspendingExisting()`/`SUSPEND_EXISTING`"
msgstr "`QuarkusTransaction.suspendingExisting()`/ `SUSPEND_EXISTING`"

#. type: Plain text
#: upstream/_guides/transaction.adoc:250
#, fuzzy
msgid "If no transaction is active then these semantics are basically a no-op.  If a transaction is active then it is suspended, and resumed after the task is run.  The exception handler will never be consulted when these semantics are in use, specifying both an exception handler and these semantics are considered an error.  These semantics allows for code to easily be run outside the scope of a transaction."
msgstr "Si no hay ninguna transacción activa, esta semántica es básicamente un no-op. Si hay una transacción activa, se suspende y se reanuda después de la ejecución de la tarea. El manejador de excepciones nunca será consultado cuando esta semántica esté en uso, especificar tanto un manejador de excepciones como esta semántica se considera un error. Esta semántica permite que el código se ejecute fácilmente fuera del ámbito de una transacción."

#. type: Title ===
#: upstream/_guides/transaction.adoc:253
#, fuzzy, no-wrap
msgid "Legacy API approach"
msgstr "Enfoque de la API heredada"

#. type: Plain text
#: upstream/_guides/transaction.adoc:256
#, fuzzy
msgid "The less easy way is to inject a `UserTransaction` and use the various transaction demarcation methods."
msgstr "La forma menos fácil es inyectar un `UserTransaction` y utilizar los distintos métodos de demarcación de transacciones."

#. type: delimited block -
#: upstream/_guides/transaction.adoc:265
#, no-wrap
msgid ""
"    @Inject ChildDAO childDAO;\n"
"    @Inject SantaClausDAO santaDAO;\n"
"    @Inject UserTransaction transaction;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/transaction.adoc:280
#, no-wrap
msgid ""
"    public void getAGiftFromSanta(Child child, String giftDescription) {\n"
"        // some transaction work\n"
"        try {\n"
"            transaction.begin();\n"
"            Gift gift = childDAO.addToGiftList(child, giftDescription);\n"
"            santaDAO.addToSantaTodoList(gift);\n"
"            transaction.commit();\n"
"        }\n"
"        catch(SomeException e) {\n"
"            // do something on Tx failure\n"
"            transaction.rollback();\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/transaction.adoc:285
#, fuzzy
msgid "You cannot use `UserTransaction` in a method having a transaction started by a `@Transactional` call."
msgstr "No se puede utilizar `UserTransaction` en un método que tenga una transacción iniciada por una llamada a `@Transactional`."

#. type: Title ==
#: upstream/_guides/transaction.adoc:287
#, fuzzy, no-wrap
msgid "Configuring the transaction timeout"
msgstr "Configurar el tiempo de espera de la transacción"

#. type: Plain text
#: upstream/_guides/transaction.adoc:289
#, fuzzy
msgid "You can configure the default transaction timeout, the timeout that applies to all transactions managed by the transaction manager, via the property `quarkus.transaction-manager.default-transaction-timeout`, specified as a duration."
msgstr "Puede configurar el tiempo de espera de la transacción por defecto, el tiempo de espera que se aplica a todas las transacciones gestionadas por el gestor de transacciones, a través de la propiedad `quarkus.transaction-manager.default-transaction-timeout`, especificada como una duración."

#. type: Plain text
#: upstream/_guides/transaction.adoc:293
#, fuzzy
msgid "The default value is 60 seconds."
msgstr "El valor por defecto es de 60 segundos."

#. type: Title ==
#: upstream/_guides/transaction.adoc:294
#, fuzzy, no-wrap
msgid "Configuring transaction node name identifier"
msgstr "Configuración del identificador del nombre del nodo de la transacción"

#. type: Plain text
#: upstream/_guides/transaction.adoc:298
#, fuzzy
msgid "Narayana, as the underlying transaction manager, has a concept of a unique node identifier.  This is important if you consider using XA transactions that involve multiple resources."
msgstr "Narayana, como gestor de transacciones subyacente, tiene un concepto de identificador de nodo único. Esto es importante si se considera el uso de transacciones XA que involucran múltiples recursos."

#. type: Plain text
#: upstream/_guides/transaction.adoc:304
#, fuzzy
msgid "The node name identifier plays a crucial part in the identification of a transaction.  The node name identifier is forged into the transaction id when the transaction is created.  Based on the node name identifier, the transaction manager is capable of recognizing the XA transaction counterparts created in database or JMS broker. The identifier makes possible for the transaction manager to roll back the transaction counterparts during recovery."
msgstr "El identificador del nombre del nodo juega un papel crucial en la identificación de una transacción. El identificador de nombre de nodo se forja en el identificador de transacción cuando se crea la transacción. Basándose en el identificador de nombre de nodo, el gestor de transacciones es capaz de reconocer las contrapartes de las transacciones XA creadas en la base de datos o en el broker JMS. El identificador hace posible que el gestor de transacciones haga retroceder las contrapartes de la transacción durante la recuperación."

#. type: Plain text
#: upstream/_guides/transaction.adoc:307
#, fuzzy
msgid "The node name identifier needs to be unique per transaction manager deployment.  And the node identifier needs to be stable over the transaction manager restarts."
msgstr "El identificador del nombre del nodo debe ser único por cada despliegue del gestor de transacciones. Y el identificador de nodo debe ser estable durante los reinicios del gestor de transacciones."

#. type: Plain text
#: upstream/_guides/transaction.adoc:309
#, fuzzy
msgid "The node name identifier may be configured via the property `quarkus.transaction-manager.node-name`."
msgstr "El identificador del nombre del nodo puede configurarse mediante la propiedad `quarkus.transaction-manager.node-name`."

#. type: Title ==
#: upstream/_guides/transaction.adoc:311
#, fuzzy, no-wrap
msgid "Using `@TransactionScoped` to bind CDI beans to the transaction lifecycle"
msgstr "Uso de `@TransactionScoped` para vincular beans CDI al ciclo de vida de la transacción"

#. type: Plain text
#: upstream/_guides/transaction.adoc:315
#, fuzzy
msgid "You can define beans that live for as long as a transaction, and through CDI lifecycle events perform actions when a transaction starts and ends."
msgstr "Puedes definir beans que vivan tanto tiempo como una transacción, y a través de eventos de ciclo de vida CDI realizar acciones cuando una transacción comienza y termina."

#. type: Plain text
#: upstream/_guides/transaction.adoc:317
#, fuzzy
msgid "Just assign the transaction xref:cdi.adoc#bean-scope[scope] to such beans using the `@TransactionScoped` annotation:"
msgstr "Basta con asignar el  link:cdi.html#bean-scope[ámbito de] la transacción a dichos beans utilizando la anotación `@TransactionScoped`:"

#. type: delimited block -
#: upstream/_guides/transaction.adoc:322
#, no-wrap
msgid ""
"@TransactionScoped\n"
"public class MyTransactionScopedBean {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/transaction.adoc:326
#, no-wrap
msgid ""
"    // The bean's state is bound to a specific transaction,\n"
"    // and restored even after suspending then resuming the transaction.\n"
"    int myData;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/transaction.adoc:331
#, no-wrap
msgid ""
"    @PostConstruct\n"
"    void onBeginTransaction() {\n"
"        // This gets invoked after a transaction begins.\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/transaction.adoc:337
#, no-wrap
msgid ""
"    @PreDestroy\n"
"    void onBeforeEndTransaction() {\n"
"        // This gets invoked before a transaction ends (commit or rollback).\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/transaction.adoc:342
#, fuzzy
msgid "Alternatively, if you don't necessarily need to hold state during the transaction, and just want to react to transaction start/end events, you can simply declare event listeners in a differently scoped bean:"
msgstr "Alternativamente, si no necesitas necesariamente mantener el estado durante la transacción, y sólo quieres reaccionar a eventos de inicio/fin de transacción, puedes simplemente declarar escuchadores de eventos en un bean de ámbito diferente:"

#. type: delimited block -
#: upstream/_guides/transaction.adoc:347
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class MyTransactionEventListeningBean {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/transaction.adoc:351
#, no-wrap
msgid ""
"    void onBeginTransaction(@Observes @Initialized(TransactionScoped.class) Object event) {\n"
"        // This gets invoked when a transaction begins.\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/transaction.adoc:355
#, no-wrap
msgid ""
"    void onBeforeEndTransaction(@Observes @BeforeDestroyed(TransactionScoped.class) Object event) {\n"
"        // This gets invoked before a transaction ends (commit or rollback).\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/transaction.adoc:360
#, no-wrap
msgid ""
"    void onAfterEndTransaction(@Observes @Destroyed(TransactionScoped.class) Object event) {\n"
"        // This gets invoked after a transaction ends (commit or rollback).\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/transaction.adoc:363
#, fuzzy
msgid "The `event` object represents the transaction ID, and defines `toString()`/`equals()`/`hashCode()` accordingly."
msgstr "El objeto `event` representa el ID de la transacción, y define `toString()`/ `equals()`/ `hashCode()` en consecuencia."

#. type: Plain text
#: upstream/_guides/transaction.adoc:366
#, fuzzy
msgid "In listener methods, you can access more information about the transaction in progress by accessing the `TransactionManager`, which is a CDI bean and can be ``@Inject``ed."
msgstr "En los métodos de escucha, puede acceder a más información sobre la transacción en curso accediendo a `TransactionManager`, que es un bean CDI y puede ser `@Inject`ed."

#. type: Title ==
#: upstream/_guides/transaction.adoc:368
#, fuzzy, no-wrap
msgid "Configure storing of Quarkus transaction logs in a database"
msgstr "Configuración del identificador del nombre del nodo de la transacción"

#. type: Plain text
#: upstream/_guides/transaction.adoc:371
#, fuzzy
msgid "In cloud environments where persistent storage is not available, such as when application containers are unable to use persistent volumes, you can configure the transaction management to store transaction logs in a database by using a JDBC datasource."
msgstr "En entornos de nube donde el almacenamiento persistente no está disponible, como cuando los contenedores de aplicaciones no pueden utilizar volúmenes persistentes, puede configurar la gestión de transacciones para almacenar registros de transacciones en una base de datos mediante el uso de una fuente de datos JDBC."

#. type: Plain text
#: upstream/_guides/transaction.adoc:373
#, fuzzy
msgid "While there are several benefits to using a database to store transaction logs, you might notice a reduction in performance compared with using the file system to store the logs."
msgstr "Aunque el uso de una base de datos para almacenar los registros de transacciones tiene varias ventajas, es posible que note una reducción del rendimiento en comparación con el uso del sistema de archivos para almacenar los registros."

#. type: Plain text
#: upstream/_guides/transaction.adoc:375
#, fuzzy
msgid "Quarkus allows the following JDBC-specific configuration of the object store included in `quarkus.transaction-manager.object-store.<property>` properties, where <property> can be:"
msgstr "Quarkus permite la siguiente configuración específica JDBC del almacén de objetos incluida en las propiedades `quarkus.transacion-manager.object-store.&amp;lt;property&amp;gt;`, donde &lt;propiedad&gt; puede ser:"

#. type: Plain text
#: upstream/_guides/transaction.adoc:379
#, fuzzy
msgid "`type` (_string_): Configure this property to `jdbc` to enable usage of a Quarkus JDBC datasource for transaction logging.  The default value is `file-system`."
msgstr "`type` _(cadena_): Configure esta propiedad a `jdbc` para habilitar el uso de una fuente de datos JDBC de Quarkus para el registro de transacciones. El valor por defecto es `file-system`."

#. type: Plain text
#: upstream/_guides/transaction.adoc:381
#, fuzzy
msgid "`datasource` (_string_): Specify the name of the datasource for the transaction log storage.  If no value is provided for the `datasource` property, Quarkus uses the xref:datasource.adoc#configure-datasources[default datasource]."
msgstr "`datasource` _(cadena_): Especifique el nombre del origen de datos para el almacenamiento del registro de transacciones. Si no se proporciona ningún valor para la propiedad `datasource`, Quarkus utiliza la fuente de  link:datasource.html#configure-datasources[datos predeterminada]."

#. type: Plain text
#: upstream/_guides/transaction.adoc:383
#, fuzzy
msgid "`create-table` (_boolean_): When set to `true`, the transaction log table gets automatically created if it does not already exist.  The default value is `false`."
msgstr "`create-table` _(booleano_): Cuando se establece en `true`, la tabla de registro de transacciones se crea automáticamente si aún no existe. El valor por defecto es `false`."

#. type: Plain text
#: upstream/_guides/transaction.adoc:385
#, fuzzy
msgid "`drop-table` (_boolean_): When set to `true`, the tables are dropped on startup if they already exist.  The default value is `false`."
msgstr "`drop-table` _(booleano_): Cuando se establece en `true`, las tablas se descartan al inicio si ya existen. El valor por defecto es `false`."

#. type: Plain text
#: upstream/_guides/transaction.adoc:387
#, fuzzy
msgid "`table-prefix` (string): Specify the prefix for a related table name.  The default value is `quarkus_`."
msgstr "`table-prefix` (cadena): Especifica el prefijo para un nombre de tabla relacionado. El valor por defecto es `quarkus_`."

#.  This paragraph will differ from the RHBQ docs in the future since it is not supported in the product yet.
#. type: Plain text
#: upstream/_guides/transaction.adoc:390
msgid "Additional information:"
msgstr ""

#. type: Plain text
#: upstream/_guides/transaction.adoc:392
msgid "You can manually create the transaction log table during the initial setup by setting the `create-table` property to `true`."
msgstr ""

#. type: Plain text
#: upstream/_guides/transaction.adoc:394
msgid "JDBC datasources and ActiveMQ Artemis allow the enlistment and automatically register the `XAResourceRecovery`."
msgstr ""

#. type: Plain text
#: upstream/_guides/transaction.adoc:396
msgid "JDBC datasources is part of `quarkus-agroal`, and it needs to use `quarkus.datasource.jdbc.transactions=XA`."
msgstr ""

#. type: Plain text
#: upstream/_guides/transaction.adoc:397
msgid "ActiveMQ Artemis is part of `quarkus-pooled-jms`, and it needs to use `quarkus.pooled-jms.transaction=XA`."
msgstr ""

#. type: Plain text
#: upstream/_guides/transaction.adoc:399
msgid "For more information, see link:https://issues.redhat.com/browse/CEQ-4878[CEQ-4878]."
msgstr ""

#. type: Plain text
#: upstream/_guides/transaction.adoc:401
msgid "If your application employs eXtended Architecture (XA) transactions, enable the transaction crash recovery feature by using `quarkus.transaction-manager.enable-recovery=true`, to safeguard your data in the event of application crashes or failures. The default value for XA Recovery is `false`."
msgstr ""

#. type: delimited block =
#: upstream/_guides/transaction.adoc:405
#, fuzzy
msgid "To work around the current known issue of link:https://issues.redhat.com/browse/AG-209[Agroal having a different view on running transaction checks], set the datasource transaction type for the datasource responsible for writing the transaction logs to `disabled`:"
msgstr "Para solucionar el problema actual de  link:https://issues.redhat.com/browse/AG-209[Agroal, que tiene una visión diferente de la ejecución de comprobaciones de transacciones], establezca el tipo de transacción de la fuente de datos responsable de escribir los registros de transacciones en `disabled`:"

#. type: delimited block -
#: upstream/_guides/transaction.adoc:408
#, no-wrap
msgid "quarkus.datasource.TX_LOG.jdbc.transactions=disabled\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/transaction.adoc:411
#, fuzzy
msgid "This example uses TX_LOG as the datasource name."
msgstr "Este ejemplo utiliza TX_LOG como nombre de la fuente de datos."

#. type: Title ==
#: upstream/_guides/transaction.adoc:414
#, fuzzy, no-wrap
msgid "Why always having a transaction manager?"
msgstr "¿Por qué tener siempre un gestor de transacciones?"

#. type: Labeled list
#: upstream/_guides/transaction.adoc:416
#, fuzzy, no-wrap
msgid "Does it work everywhere I want to?"
msgstr "¿Funciona en todos los lugares que quiero?"

#. type: delimited block =
#: upstream/_guides/transaction.adoc:423
#, fuzzy
msgid "Yep, it works in your Quarkus application, in your IDE, in your tests, because all of these are Quarkus applications.  JTA has some bad press for some people.  I don't know why.  Let's just say that this is not your grandpa's JTA implementation.  What we have is perfectly embeddable and lean."
msgstr "Sí, funciona en tu aplicación Quarkus, en tu IDE, en tus pruebas, porque todas ellas son aplicaciones Quarkus. JTA tiene mala prensa para algunas personas. No sé por qué. Digamos que esta no es la implementación de JTA de tu abuelo. Lo que tenemos es perfectamente incrustado y magro."

#. type: Labeled list
#: upstream/_guides/transaction.adoc:424
#, fuzzy, no-wrap
msgid "Does it do 2 Phase Commit and slow down my app?"
msgstr "¿Hace 2 Phase Commit y ralentiza mi aplicación?"

#. type: delimited block =
#: upstream/_guides/transaction.adoc:428
#, fuzzy
msgid "No, this is an old folk tale.  Let's assume it essentially comes for free and let you scale to more complex cases involving several datasources as needed."
msgstr "No, esto es un viejo cuento popular. Supongamos que es gratis y que te permite escalar a casos más complejos que implican varias fuentes de datos según sea necesario."

#. type: Labeled list
#: upstream/_guides/transaction.adoc:429
#, fuzzy, no-wrap
msgid "I don't need transaction when I do read only operations, it's faster."
msgstr "No necesito la transacción cuando hago operaciones de sólo lectura, es más rápido."

#. type: delimited block =
#: upstream/_guides/transaction.adoc:441
#, fuzzy
msgid "Wrong. + First off, just disable the transaction by marking your transaction boundary with `@Transactional(NOT_SUPPORTED)` (or `NEVER` or `SUPPORTS` depending on the semantic you want). + Second, it's again fairy tale that not using transaction is faster.  The answer is, it depends on your DB and how many SQL SELECTs you are making.  No transaction means the DB does have a single operation transaction context anyway. + Third, when you do several SELECTs, it's better to wrap them in a single transaction because they will all be consistent with one another.  Say your DB represents your car dashboard, you can see the number of kilometers remaining and the fuel gauge level.  By reading it in one transaction, they will be consistent.  If you read one and the other from two different transactions, then they can be inconsistent.  It can be more dramatic if you read data related to rights and access management for example."
msgstr "No es así. + En primer lugar, basta con desactivar la transacción marcando el límite de la misma con `@Transactional(NOT_SUPPORTED)` (o `NEVER` o `SUPPORTS` dependiendo de la semántica que desee). + En segundo lugar, es de nuevo un cuento de hadas que no usar la transacción es más rápido. La respuesta es que depende de tu BD y de la cantidad de SELECTs SQL que estés haciendo. Sin transacción significa que la BD tiene un contexto de transacción de operación única de todos modos. + Tercero, cuando haces varios SELECTs, es mejor envolverlos en una sola transacción porque todos serán consistentes entre sí. Digamos que tu DB representa el tablero de tu coche, puedes ver el número de kilómetros restantes y el nivel del indicador de combustible. Al leerlo en una sola transacción, serán consistentes. Si lee uno y otro en dos transacciones diferentes, entonces pueden ser inconsistentes. Puede ser más dramático si lees datos relacionados con la gestión de derechos y accesos, por ejemplo."

#. type: Labeled list
#: upstream/_guides/transaction.adoc:442
#, fuzzy, no-wrap
msgid "Why do you prefer JTA vs Hibernate's transaction management API"
msgstr "¿Por qué prefiere JTA frente a la API de gestión de transacciones de Hibernate?"

#. type: delimited block =
#: upstream/_guides/transaction.adoc:446
#, fuzzy
msgid "Managing the transactions manually via `entityManager.getTransaction().begin()` and friends lead to a butt ugly code with tons of try catch finally that people get wrong.  Transactions are also about JMS and other database access, so one API makes more sense."
msgstr "Manejar las transacciones manualmente a través de `entityManager.getTransaction().begin()` y amigos lleva a un código feo con toneladas de try catch finalmente que la gente se equivoca. Las transacciones también tienen que ver con JMS y otros accesos a la base de datos, así que una API tiene más sentido."

#. type: Labeled list
#: upstream/_guides/transaction.adoc:447
#, fuzzy, no-wrap
msgid "It's a mess because I don't know if my Jakarta Persistence persistence unit is using `JTA` or `Resource-level` Transaction"
msgstr "Es un lío porque no sé si mi unidad de persistencia JPA está usando `JTA` o `Resource-level` Transaction"

#. type: delimited block =
#: upstream/_guides/transaction.adoc:452
#, fuzzy
msgid "It's not a mess in Quarkus :)  Resource-level was introduced to support Jakarta Persistence in a non managed environment.  But Quarkus is both lean and a managed environment, so we can safely always assume we are in JTA mode.  The end result is that the difficulties of running Hibernate ORM + CDI + a transaction manager in Java SE mode are solved by Quarkus."
msgstr "No es un lío en Quarkus :) El nivel de recursos se introdujo para soportar JPA en un entorno no gestionado. Pero Quarkus es a la vez un entorno no gestionado y gestionado, por lo que podemos asumir con seguridad que siempre estamos en modo JTA. El resultado final es que las dificultades de ejecutar Hibernate ORM + CDI + un gestor de transacciones en modo Java SE son resueltas por Quarkus."

#, fuzzy
#~ msgid "The Narayana project has the capability to store the transaction logs into a JDBC Datasource; this should be our recommendation for users needing transaction recovery capabilities, especially when running in volatile containers."
#~ msgstr "El proyecto Narayana tiene la capacidad de almacenar los registros de transacciones en un JDBC Datasource; esta debería ser nuestra recomendación para los usuarios que necesitan capacidades de recuperación de transacciones, especialmente cuando se ejecutan en contenedores volátiles."

#, fuzzy
#~ msgid "To enable this capability, you need to set `quarkus.transaction-manager.object-store.type` to `jdbc` explicitly. Also, you can specify a datasource name to be used for the transaction log storage by setting `quarkus.transaction-manager.object-store.datasource`. It will use the default datasource configuration if not specified."
#~ msgstr "Para activar esta función, es necesario configurar `quarkus.transaction-manager.object-store.type` a `jdbc` explícitamente. Además, puede especificar un nombre de fuente de datos que se utilizará para el almacenamiento del registro de transacciones configurando `quarkus.transaction-manager.object-store.datasource`. Si no se especifica, se utilizará la configuración de origen de datos por defecto."

#, fuzzy
#~ msgid "If you enable `quarkus.transaction-manager.object-store.create-table`, the transaction log table will be created automatically if it does not exist."
#~ msgstr "Si activa `quarkus.transaction-manager.object-store.create-table`, la tabla del registro de transacciones se creará automáticamente si no existe."

#, fuzzy
#~ msgid "When enabling this capability, the transaction node identifier must be set through `quarkus.transaction-manager.node-name`."
#~ msgstr "El identificador del nombre del nodo puede configurarse mediante la propiedad `quarkus.transaction-manager.node-name`."

#, fuzzy
#~ msgid "DISALLOW_EXISTING"
#~ msgstr "DISALLOW_EXISTING"

#, fuzzy
#~ msgid "JOIN_EXISTING"
#~ msgstr "JOIN_EXISTING"

#, fuzzy
#~ msgid "REQUIRE_NEW"
#~ msgstr "REQUERIR_NUEVO"

#, fuzzy
#~ msgid "SUSPEND_EXISTING"
#~ msgstr "SUSPENDER_EXISTENCIAS"
