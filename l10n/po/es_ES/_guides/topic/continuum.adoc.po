# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-05-02 07:15+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: es_ES\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: YAML Front Matter: layout
#: upstream/_guides/topic/continuum.adoc:1
#, fuzzy, no-wrap
msgid "vision"
msgstr "visión"

#. type: YAML Front Matter: permalink
#: upstream/_guides/topic/continuum.adoc:1
#, fuzzy, no-wrap
msgid "/vision/continuum"
msgstr "/visión/continuo"

#. type: Title =
#: upstream/_guides/topic/continuum.adoc:7
#, fuzzy, no-wrap
msgid "The Imperative and Reactive Continuum"
msgstr "El continuo imperativo y reactivo"

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:15
#, fuzzy
msgid "For years, the client-server architecture has been the de-facto standard to build applications.  But a major shift happened.  The _one model rules them all_ age is over.  A new range of applications and architecture styles has emerged and impacts how code is written and how applications are deployed and executed.  HTTP microservices, reactive applications, message-driven microservices and serverless are now central players in modern systems."
msgstr "Durante años, la arquitectura cliente-servidor ha sido el estándar de facto para construir aplicaciones. Pero se ha producido un cambio importante. La época en que _un modelo los gobierna a todos_ ha terminado. Ha surgido una nueva gama de aplicaciones y estilos de arquitectura que influyen en la forma de escribir el código y de desplegar y ejecutar las aplicaciones. Los microservicios HTTP, las aplicaciones reactivas, los microservicios impulsados por mensajes y la ausencia de servidor son ahora protagonistas de los sistemas modernos."

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:18
#, fuzzy
msgid "Quarkus has been designed with this new world in mind, and provides first-class support for these different paradigms.  Quarkus development model morphs to adapt itself to the type of application you are developing."
msgstr "Quarkus ha sido diseñado con este nuevo mundo en mente, y proporciona soporte de primera clase para estos diferentes paradigmas. El modelo de desarrollo de Quarkus se transforma para adaptarse al tipo de aplicación que estés desarrollando."

#. type: Title ==
#: upstream/_guides/topic/continuum.adoc:19
#, fuzzy, no-wrap
msgid "HTTP microservices"
msgstr "Microservicios HTTP"

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:24
#, fuzzy
msgid "Let’s start with the basic: HTTP microservices.  In this context, you need to develop an HTTP endpoint, often called REST or CRUD.  You process incoming HTTP requests, and to do so you often need to rely on others services, such as databases, or another HTTP service."
msgstr "Empecemos por lo básico: los microservicios HTTP. En este contexto, necesitas desarrollar un punto final HTTP, a menudo llamado REST o CRUD. Procesas las peticiones HTTP entrantes, y para ello a menudo necesitas apoyarte en otros servicios, como bases de datos, u otro servicio HTTP."

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:27
#, fuzzy
msgid "For this type of application, Quarkus relies on well-known standards such as JAX-RS, JPA and MicroProfile Rest Client.  Let's take a very simple application handling _fruits_. The code would be something like:"
msgstr "Para este tipo de aplicaciones, Quarkus se apoya en estándares conocidos como JAX-RS, JPA y MicroProfile Rest Client. Tomemos una aplicación muy sencilla que maneje _frutas_. El código sería algo así:"

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:34
#, no-wrap
msgid ""
"@Path(\"fruits\")\n"
"@Produces(\"application/json\")\n"
"@Consumes(\"application/json\")\n"
"public class FruitResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:37
#, no-wrap
msgid ""
"    @Inject\n"
"    EntityManager entityManager;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:43
#, no-wrap
msgid ""
"    @GET\n"
"    public List<Fruit> get() {\n"
"        return entityManager.createNamedQuery(\"Fruits.findAll\", Fruit.class)\n"
"              .getResultList();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:53
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"{id}\")\n"
"    public Fruit getSingle(@PathParam Integer id) {\n"
"        Fruit entity = entityManager.find(Fruit.class, id);\n"
"        if (entity == null) {\n"
"            throw new WebApplicationException(\"Fruit with id of \" + id + \" does not exist.\", 404);\n"
"        }\n"
"        return entity;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:60
#, no-wrap
msgid ""
"    @POST\n"
"    @Transactional\n"
"    public Response create(Fruit fruit) {\n"
"        if (fruit.getId() != null) {\n"
"            throw new WebApplicationException(\"Id was invalidly set on request.\", 422);\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:64
#, no-wrap
msgid ""
"        entityManager.persist(fruit);\n"
"        return Response.ok(fruit).status(201).build();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:67
#, no-wrap
msgid ""
"    // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:72
#, fuzzy
msgid "If you are a Java EE or Spring user, this development model should look familiar.  You expose a _resource_ containing methods annotated with `@GET`, `@POST`... to handle the different requests.  The _path_ is specified using the `@Path` annotation."
msgstr "Si eres un usuario de Java EE o Spring, este modelo de desarrollo debería resultarte familiar. Usted expone un _recurso_ que contiene métodos anotados con `@GET`, `@POST`... para manejar las diferentes solicitudes. La _ruta_ se especifica mediante la anotación `@Path`."

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:75
#, fuzzy
msgid "JPA users will recognize the `EntityManager` used to access the database.  Finally, methods requiring a transaction are simply annotated with `@Transactional`."
msgstr "Los usuarios de JPA reconocerán el `EntityManager` utilizado para acceder a la base de datos. Por último, los métodos que requieren una transacción se anotan simplemente con `@Transactional`."

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:79
#, fuzzy
msgid "Let's now imagine you need to access another HTTP endpoint.  You can use a HTTP client directly, this is nothing more than repeating boilerplate code.  Quarkus provides a way to call HTTP endpoints that return Rest based results easily using the MicroProfile Rest Client API."
msgstr "Imaginemos ahora que necesitas acceder a otro endpoint HTTP. Puedes usar un cliente HTTP directamente, esto no es más que repetir código boilerplate. Quarkus proporciona una manera de llamar a los puntos finales HTTP que devuelven resultados basados en Rest fácilmente utilizando la API de cliente Rest de MicroProfile."

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:81
#, fuzzy
msgid "First declare your service as follows:"
msgstr "Primero declare su servicio como sigue:"

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:87
#, no-wrap
msgid ""
"@Path(\"/v2\")\n"
"@RegisterRestClient\n"
"public interface CountriesService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:93
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/name/{name}\")\n"
"    @Produces(\"application/json\")\n"
"    Set<Country> getByName(@PathParam(\"name\") String name);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:96
#, fuzzy
msgid "For each call you are intending to do, add a method and use annotations to describe the behavior."
msgstr "Para cada llamada que pretendas hacer, añade un método y utiliza anotaciones para describir el comportamiento."

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:98
#, fuzzy
msgid "Then, in your resource, just use the `CountriesService`:"
msgstr "Entonces, en su recurso, sólo tiene que utilizar el `CountriesService`:"

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:103
#, no-wrap
msgid ""
"@Path(\"/country\")\n"
"public class CountriesResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:107
#, no-wrap
msgid ""
"    @Inject\n"
"    @RestClient\n"
"    CountriesService countriesService;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:115
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/name/{name}\")\n"
"    @Produces(MediaType.APPLICATION_JSON)\n"
"    public Set<Country> name(@PathParam(\"name\") String name) {\n"
"        return countriesService.getByName(name);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:120
#, fuzzy
msgid "But you may be wondering where the URL is configured as it's not in the code.  Remember, it must not be hard-coded because the url likely depends on the environment.  The URL is configured in the application configuration:"
msgstr "Pero puede que te preguntes dónde está configurada la URL, ya que no está en el código. Recuerda que no debe estar codificada porque la url probablemente depende del entorno. La URL se configura en la configuración de la aplicación:"

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:125
#, no-wrap
msgid ""
"# the format is interface-name/mp-rest/url=the-service-url\n"
"org.acme.restclient.CountriesService/mp-rest/url=https://restcountries.eu/rest\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:128
#, fuzzy
msgid "The url can now be updated during the deployment or at launch time using system properties or environment variables."
msgstr "La url puede ahora actualizarse durante el despliegue o en el momento del lanzamiento utilizando las propiedades del sistema o las variables de entorno."

#. type: Title ==
#: upstream/_guides/topic/continuum.adoc:129
#, fuzzy, no-wrap
msgid "Being reactive"
msgstr "Ser reactivo"

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:133
#, fuzzy
msgid "Application requirements have changed drastically over the last few years.  For any application to succeed in the era of cloud computing, big data or IoT, going reactive is increasingly becoming the architecture style to follow."
msgstr "Los requisitos de las aplicaciones han cambiado drásticamente en los últimos años. Para que cualquier aplicación tenga éxito en la era de la computación en la nube, el big data o el IoT, ser reactivo se está convirtiendo cada vez más en el estilo de arquitectura a seguir."

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:137
#, fuzzy
msgid "Today’s users embrace applications that have milliseconds of response time, 100% uptime, lower latency, push data instead of pull, higher throughput and elasticity.  However, these features are nearly impossible to achieve by using _yesterday’s software architecture_ without a huge investment in resources, infrastructure and tooling.  The world changed and having dozens of servers, long response time (> 500 ms), downtime due to maintenance or waterfalls of failures does not meet the expected user experience."
msgstr "Los usuarios de hoy en día prefieren aplicaciones con un tiempo de respuesta de milisegundos, un tiempo de actividad del 100%, menor latencia, datos push en lugar de pull, mayor rendimiento y elasticidad. Sin embargo, estas características son casi imposibles de conseguir utilizando _la arquitectura de software de ayer_ sin una enorme inversión en recursos, infraestructura y herramientas. El mundo ha cambiado y tener docenas de servidores, largos tiempos de respuesta (&gt; 500 ms), tiempos de inactividad por mantenimiento o cascadas de fallos no satisface la experiencia de usuario esperada."

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:140
#, fuzzy
msgid "Quarkus stands with you on your path to reactive.  First, you can implement asynchronous HTTP endpoint as follows:"
msgstr "Quarkus te acompaña en tu camino hacia la reactividad. En primer lugar, puedes implementar un endpoint HTTP asíncrono de la siguiente manera:"

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:148
#, no-wrap
msgid ""
"@GET\n"
"@Path(\"/greeting/{name}\")\n"
"public Uni<String> greetings(@PathParam(\"name\") String name) {\n"
"    return reactiveService.getAsyncGreetings(name);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:152
#, fuzzy
msgid "Method actions can compose asynchronous operations and complete the result when everything is done without blocking threads.  This greatly improves resource consumption and elasticity."
msgstr "Las acciones de los métodos pueden componer operaciones asíncronas y completar el resultado cuando todo está hecho sin bloquear hilos. Esto mejora enormemente el consumo de recursos y la elasticidad."

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:154
#, fuzzy
msgid "Thanks to a reactive core, an intuitive event-driven development model and a \"reactive-first\" strategy for all the Quarkus internals, Quarkus applications handles high concurrency, and uses resources efficiently."
msgstr "Gracias a un núcleo reactivo, un modelo de desarrollo intuitivo basado en eventos y una estrategia \"reactiva primero\" para todas las partes internas de Quarkus, las aplicaciones de Quarkus manejan una alta concurrencia y utilizan los recursos de manera eficiente."

#.  TODO Async rest client, but does not seem to be working.
#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:159
#, fuzzy
msgid "But, what about streams? Generating a _server-sent event_ response with Quarkus is just as simple:"
msgstr "Pero, ¿qué pasa con los flujos? Generar una respuesta de _evento enviada por el servidor_ con Quarkus es igual de sencillo:"

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:168
#, no-wrap
msgid ""
"@Produces(MediaType.SERVER_SENT_EVENTS)\n"
"@GET\n"
"@Path(\"/neo\")\n"
"public Multi<String> stream() {\n"
"    return service.getStream();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:171
#, fuzzy
msgid "This method returns a `Multi`, but you can use any Reactive Streams `Publisher` implementation."
msgstr "Este método devuelve un `Multi`, pero puede utilizar cualquier implementación de Reactive Streams `Publisher`."

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:181
#, no-wrap
msgid ""
"@Produces(MediaType.SERVER_SENT_EVENTS)\n"
"@GET\n"
"@Path(\"/neo\")\n"
"public Multi<String> stream() {\n"
"    return Multi.createFrom().items(\"a\", \"b\", \"c\")\n"
"           .onItem().transform(String::toUpperCase);\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/topic/continuum.adoc:183
#, fuzzy, no-wrap
msgid "Message-driven microservices"
msgstr "Microservicios basados en mensajes"

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:187
#, fuzzy
msgid "However, HTTP characteristics prohibit implementing https://www.reactivemanifesto.org/[reactive systems], where all the components interact using asynchronous messages passing.  But no worries, Quarkus is perfectly suited to implement message-driven microservices and reactive systems."
msgstr "Sin embargo, las características de HTTP prohíben la implementación de  link:https://www.reactivemanifesto.org/[sistemas reactivos], donde todos los componentes interactúan utilizando el paso de mensajes asíncronos. Pero no te preocupes, Quarkus es perfectamente adecuado para implementar microservicios orientados a mensajes y sistemas reactivos."

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:189
#, fuzzy
msgid "First, you can consume messages from various brokers such as AMQP or Kafka, and process these messages smoothly:"
msgstr "En primer lugar, puede consumir mensajes de varios brokers como AMQP o Kafka, y procesar estos mensajes sin problemas:"

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:194
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class HealthDataProcessor {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:201
#, no-wrap
msgid ""
"  @Incoming(\"health\")\n"
"  @Outgoing(\"heartbeat\")\n"
"  public double filtered(Health health) {\n"
"    return health.getHeartbeat();\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:206
#, fuzzy
msgid "The `@Incoming` and `@Outgoing` annotations are part of https://www.smallrye.io/smallrye-reactive-messaging[Reactive Messaging].  They are used to express from which _stream_ you are consuming and to which stream you are sending.  Thanks to Reactive Messaging you can consume and send messages from and to different brokers and transports such as HTTP, Kafka, or http://camel.apache.org[Apache Camel]."
msgstr "Las anotaciones `@Incoming` y `@Outgoing` forman parte de la  link:https://www.smallrye.io/smallrye-reactive-messaging[mensajería reactiva]. Se utilizan para expresar desde qué _flujo_ estás consumiendo y a qué flujo estás enviando. Gracias a Reactive Messaging puedes consumir y enviar mensajes desde y hacia diferentes brokers y transportes como HTTP, Kafka o  link:http://camel.apache.org[Apache Camel]."

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:209
#, fuzzy
msgid "Sometimes you need more than just handling messages one by one.  You can also express your message processing logic using reactive programming as illustrated in the following snippet:"
msgstr "A veces se necesita algo más que manejar los mensajes uno a uno. También puede expresar su lógica de procesamiento de mensajes utilizando la programación reactiva como se ilustra en el siguiente fragmento:"

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:221
#, no-wrap
msgid ""
"@Incoming(\"health\")\n"
"@Outgoing(\"output\")\n"
"public Multi<Record<String, JsonObject>> filterState(Multi<JsonObject> input) {\n"
"    return input\n"
"      .onItem().transform(json -> json.getJsonObject(\"state\"))\n"
"      .drop().repetitions()\n"
"      .onItem().invoke(json -> LOGGER.info(\"Forwarding new state '{}' to Kafka\", json.encode()))\n"
"      .onItem().transform(json -> Record.of(\"neo\", json));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:224
#, fuzzy
msgid "You can also use _imperative_ logic with Reactive Messaging:"
msgstr "También puede utilizar la lógica _imperativa_ con la Mensajería Reactiva:"

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:233
#, no-wrap
msgid ""
"@Incoming(\"orders\")\n"
"@Outgoing(\"queue\")\n"
"@Blocking\n"
"public Beverage process(Order order) {\n"
"    return prepare(order); // Block the caller thread.\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/topic/continuum.adoc:235
#, fuzzy, no-wrap
msgid "Functions as a Service and Serverless"
msgstr "Funciones como servicio y sin servidor"

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:239
#, fuzzy
msgid "Thanks to their stellar startup time and low memory usage, you can implement functions using Quarkus to be used in serverless environments.  If you are using AWS Lambda, your Quarkus function looks like:"
msgstr "Gracias a su tiempo de inicio estelar y su bajo uso de memoria, puedes implementar funciones con Quarkus para utilizarlas en entornos sin servidor. Si está utilizando AWS Lambda, su función de Quarkus tiene el aspecto siguiente:"

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:243
#, no-wrap
msgid "public class HelloLambda implements RequestHandler<HelloRequest, String> {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:246
#, no-wrap
msgid ""
"    @Inject\n"
"    HelloGreeter greeter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:252
#, no-wrap
msgid ""
"    @Override\n"
"    public String handleRequest(HelloRequest request, Context context) {\n"
"        return greeter.greet(request.firstName, request.lastName);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:254
#, fuzzy
msgid "You can use any of the Quarkus features in your function and benefit from the fast startup and low memory utilization. With Quarkus, you can embrace this new world without having to change your programming language."
msgstr "Puede utilizar cualquiera de las características de Quarkus en su función y beneficiarse de la rápida puesta en marcha y la baja utilización de la memoria. Con Quarkus, puedes abrazar este nuevo mundo sin tener que cambiar tu lenguaje de programación."

#, fuzzy
#~ msgid "---\n"
#~ msgstr "---\n"

#, fuzzy
#~ msgid ""
#~ "layout: vision\n"
#~ "permalink: /vision/continuum\n"
#~ "---\n"
#~ msgstr "diseño: visión permalink: /vision/continuum ---"
