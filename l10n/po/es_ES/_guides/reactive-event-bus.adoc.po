# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-12-10 08:08+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/reactive-event-bus.adoc:6
#, fuzzy, no-wrap
msgid "Using the event bus"
msgstr "Uso del bus de eventos"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:17
#, fuzzy
msgid "Quarkus allows different beans to interact using asynchronous events, thus promoting loose-coupling.  The messages are sent to _virtual addresses_.  It offers 3 types of delivery mechanism:"
msgstr "Quarkus permite que diferentes beans interactúen utilizando eventos asíncronos, promoviendo así el loose-coupling. Los mensajes se envían a _direcciones virtuales_. Ofrece 3 tipos de mecanismo de entrega:"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:19
#, fuzzy
msgid "point-to-point - send the message, one consumer receives it. If several consumers listen to the address, a round-robin is applied;"
msgstr "Punto a punto: se envía el mensaje, un consumidor lo recibe. Si varios consumidores escuchan la dirección, se aplica un round robin;"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:20
#, fuzzy
msgid "publish/subscribe - publish a message, all the consumers listening to the address are receiving the message;"
msgstr "publicar/suscribir - publicar un mensaje, todos los consumidores que escuchan la dirección reciben el mensaje;"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:21
#, fuzzy
msgid "request/reply - send the message and expect a response. The receiver can respond to the message in an asynchronous-fashion"
msgstr "request/reply - envía el mensaje y espera una respuesta. El receptor puede responder al mensaje de forma asíncrona"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:23
#, fuzzy
msgid "All these delivery mechanisms are non-blocking, and are providing one of the fundamental brick to build reactive applications."
msgstr "Todos estos mecanismos de entrega son no bloqueantes, y están proporcionando uno de los ladrillos fundamentales para construir aplicaciones reactivas."

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:26
#, fuzzy
msgid "The asynchronous message passing feature allows replying to messages which is not supported by Reactive Messaging.  However, it is limited to single-event behavior (no stream) and to local messages."
msgstr "La función de paso de mensajes asíncrono permite responder a los mensajes, lo que no está soportado por la mensajería reactiva. Sin embargo, está limitada al comportamiento de un solo evento (sin flujo) y a los mensajes locales."

#. type: Title ==
#: upstream/_guides/reactive-event-bus.adoc:27
#, fuzzy, no-wrap
msgid "Installing"
msgstr "Instalación de"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:31
#, fuzzy
msgid "This mechanism uses the Vert.x EventBus, so you need to enable the `vertx` extension to use this feature.  If you are creating a new project, set the `extensions` parameter as follows:"
msgstr "Este mecanismo utiliza el EventBus de Vert.x, por lo que es necesario habilitar la extensión `vertx` para utilizar esta función. Si está creando un nuevo proyecto, configure el parámetro `extensions` como sigue:"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:38
#, fuzzy
msgid "If you have an already created project, the `vertx` extension can be added to an existing Quarkus project with the `add-extension` command:"
msgstr "Si tiene un proyecto ya creado, la extensión `vertx` puede añadirse a un proyecto existente de Quarkus con el comando `add-extension`:"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:43
#, fuzzy
msgid "Otherwise, you can manually add this to the dependencies section of your build file:"
msgstr "Si no, puedes añadirlo manualmente a la sección de dependencias de tu archivo de compilación:"

#. type: Block title
#: upstream/_guides/reactive-event-bus.adoc:45
#, fuzzy, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:51
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-vertx</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Block title
#: upstream/_guides/reactive-event-bus.adoc:54
#, fuzzy, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:57
#, no-wrap
msgid "implementation(\"io.quarkus:quarkus-vertx\")\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/reactive-event-bus.adoc:59
#, fuzzy, no-wrap
msgid "Consuming events"
msgstr "Eventos de consumo"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:62
#, fuzzy
msgid "To consume events, use the `io.quarkus.vertx.ConsumeEvent` annotation:"
msgstr "Para consumir eventos, utilice la anotación `io.quarkus.vertx.ConsumeEvent`:"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:66
#: upstream/_guides/reactive-event-bus.adoc:115
#: upstream/_guides/reactive-event-bus.adoc:241
#: upstream/_guides/reactive-event-bus.adoc:313
#: upstream/_guides/reactive-event-bus.adoc:349
#, no-wrap
msgid "package org.acme.vertx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:68
#: upstream/_guides/reactive-event-bus.adoc:117
#: upstream/_guides/reactive-event-bus.adoc:351
#, no-wrap
msgid "import io.quarkus.vertx.ConsumeEvent;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:70
#: upstream/_guides/reactive-event-bus.adoc:353
#, no-wrap
msgid "import jakarta.enterprise.context.ApplicationScoped;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:73
#: upstream/_guides/reactive-event-bus.adoc:125
#: upstream/_guides/reactive-event-bus.adoc:356
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class GreetingService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:79
#, no-wrap
msgid ""
"    @ConsumeEvent                           // <1>\n"
"    public String consume(String name) {    // <2>\n"
"        return name.toUpperCase();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:81
#, fuzzy
msgid "If not set, the address is the fully qualified name of the bean, for instance, in this snippet it's `org.acme.vertx.GreetingService`."
msgstr "Si no se establece, la dirección es el nombre completo del bean, por ejemplo, en este fragmento es `org.acme.vertx.GreetingService`."

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:82
#, fuzzy
msgid "The method parameter is the message body. If the method returns _something_ it's the message response."
msgstr "El parámetro del método es el cuerpo del mensaje. Si el método devuelve _algo_ es la respuesta del mensaje."

#. type: delimited block =
#: upstream/_guides/reactive-event-bus.adoc:87
#, fuzzy
msgid "By default, the code consuming the event must be _non-blocking_, as it's called on the Vert.x event loop.  If your processing is blocking, use the `blocking` attribute:"
msgstr "Por defecto, el código que consume el evento debe ser _no bloque_ante, ya que es llamado en el bucle de eventos de Vert.x. Si su procesamiento es de bloqueo, utilice el atributo `blocking`:"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:94
#, no-wrap
msgid ""
"@ConsumeEvent(value = \"blocking-consumer\", blocking = true)\n"
"void consumeBlocking(String message) {\n"
"    // Something blocking\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:97
#, fuzzy
msgid "Alternatively, you can annotate your method with `@io.smallrye.common.annotation.Blocking`:"
msgstr "También puede anotar su método con `@io.smallrye.common.annotation.Blocking`:"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:104
#, no-wrap
msgid ""
"@ConsumeEvent(value = \"blocking-consumer\")\n"
"@Blocking\n"
"void consumeBlocking(String message) {\n"
"    // Something blocking\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:108
#, fuzzy
msgid "When using `@Blocking`, it ignores the value of the `blocking` attribute of `@ConsumeEvent`.  See the xref:quarkus-reactive-architecture.adoc[Quarkus Reactive Architecture documentation] for further details on this topic."
msgstr "Cuando se utiliza `@Blocking`, se ignora el valor del atributo `blocking` de `@ConsumeEvent`. Véase la  link:quarkus-reactive-architecture.html[documentación de Quarkus Reactive] Architecture para más detalles sobre este tema."

#. type: delimited block =
#: upstream/_guides/reactive-event-bus.adoc:111
#, fuzzy
msgid "Asynchronous processing is also possible by returning either an `io.smallrye.mutiny.Uni` or a `java.util.concurrent.CompletionStage`:"
msgstr "El procesamiento asíncrono también es posible devolviendo un `io.smallrye.mutiny.Uni` o un `java.util.concurrent.CompletionStage`:"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:122
#, no-wrap
msgid ""
"import jakarta.enterprise.context.ApplicationScoped;\n"
"import java.util.concurrent.CompletableFuture;\n"
"import java.util.concurrent.CompletionStage;\n"
"import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:131
#, no-wrap
msgid ""
"    @ConsumeEvent\n"
"    public CompletionStage<String> consume(String name) {\n"
"        // return a CompletionStage completed when the processing is finished.\n"
"        // You can also fail the CompletionStage explicitly\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:138
#, no-wrap
msgid ""
"    @ConsumeEvent\n"
"    public Uni<String> process(String name) {\n"
"        // return an Uni completed when the processing is finished.\n"
"        // You can also fail the Uni explicitly\n"
"    }\n"
"}\n"
msgstr ""

#. type: Block title
#: upstream/_guides/reactive-event-bus.adoc:141
#, fuzzy, no-wrap
msgid "Mutiny"
msgstr "Motín"

#. type: delimited block =
#: upstream/_guides/reactive-event-bus.adoc:145
#, fuzzy
msgid "The previous example uses Mutiny reactive types.  If you are not familiar with Mutiny, check xref:mutiny-primer.adoc[Mutiny - an intuitive reactive programming library]."
msgstr "El ejemplo anterior utiliza tipos reactivos Mutiny. Si no está familiarizado con Mutiny, consulte  link:mutiny-primer.html[Mutiny - una biblioteca de programación reactiva intuitiva]."

#. type: Title ===
#: upstream/_guides/reactive-event-bus.adoc:147
#, fuzzy, no-wrap
msgid "Configuring the address"
msgstr "Configuración de la dirección"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:150
#, fuzzy
msgid "The `@ConsumeEvent` annotation can be configured to set the address:"
msgstr "La anotación `@ConsumeEvent` se puede configurar para establecer la dirección:"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:157
#, no-wrap
msgid ""
"@ConsumeEvent(\"greeting\")               // <1>\n"
"public String consume(String name) {\n"
"    return name.toUpperCase();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:159
#, fuzzy
msgid "Receive the messages sent to the `greeting` address"
msgstr "Recibir los mensajes enviados a la dirección `greeting`"

#. type: Title ===
#: upstream/_guides/reactive-event-bus.adoc:160
#, fuzzy, no-wrap
msgid "Replying"
msgstr "Respondiendo a"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:164
#, fuzzy
msgid "The _return_ value of a method annotated with `@ConsumeEvent` is used as response to the incoming message.  For instance, in the following snippet, the returned `String` is the response."
msgstr "El valor de _retorno_ de un método anotado con `@ConsumeEvent` se utiliza como respuesta al mensaje entrante. Por ejemplo, en el siguiente fragmento, el `String` devuelto es la respuesta."

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:171
#, no-wrap
msgid ""
"@ConsumeEvent(\"greeting\")\n"
"public String consume(String name) {\n"
"    return name.toUpperCase();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:174
#, fuzzy
msgid "You can also return a `Uni<T>` or a `CompletionStage<T>` to handle asynchronous reply:"
msgstr "También puede devolver un `Uni&amp;lt;T&amp;gt;` o un `CompletionStage&amp;lt;T&amp;gt;` para manejar la respuesta asíncrona:"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:181
#, no-wrap
msgid ""
"@ConsumeEvent(\"greeting\")\n"
"public Uni<String> consume2(String name) {\n"
"    return Uni.createFrom().item(() -> name.toUpperCase()).emitOn(executor);\n"
"}\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/reactive-event-bus.adoc:186
#, fuzzy
msgid "You can inject an `executor` if you use the Context Propagation extension:"
msgstr "Puede inyectar un `executor` si utiliza la extensión de Propagación de Contexto:"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:189
#, no-wrap
msgid "@Inject ManagedExecutor executor;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:192
#, fuzzy
msgid "Alternatively, you can use the default Quarkus worker pool using:"
msgstr "Alternativamente, puede utilizar el grupo de trabajadores de Quarkus por defecto utilizando:"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:196
#, no-wrap
msgid "Executor executor = Infrastructure.getDefaultWorkerPool();\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/reactive-event-bus.adoc:199
#, fuzzy, no-wrap
msgid "Implementing fire and forget interactions"
msgstr "Aplicación de las interacciones de fuego y olvido"

#. type: delimited block =
#: upstream/_guides/reactive-event-bus.adoc:204
#, fuzzy
msgid "You don't have to reply to received messages.  Typically, for a _fire and forget_ interaction, the messages are consumed and the sender does not need to know about it.  To implement this, your consumer method just returns `void`"
msgstr "No es necesario responder a los mensajes recibidos. Normalmente, para una interacción de _disparar y olvidar_, los mensajes se consumen y el remitente no necesita saberlo. Para implementar esto, su método consumidor simplemente devuelve `void`"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:211
#, no-wrap
msgid ""
"@ConsumeEvent(\"greeting\")\n"
"public void consume(String event) {\n"
"    // Do something with the event\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/reactive-event-bus.adoc:213
#, fuzzy, no-wrap
msgid "Dealing with messages"
msgstr "Tratamiento de los mensajes"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:216
#, fuzzy
msgid "As said above, this mechanism is based on the Vert.x event bus. So, you can also use `Message` directly:"
msgstr "Como ya se ha dicho, este mecanismo se basa en el bus de eventos de Vert.x. Por lo tanto, también puede utilizar `Message` directamente:"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:224
#, no-wrap
msgid ""
"@ConsumeEvent(\"greeting\")\n"
"public void consume(Message<String> msg) {\n"
"    System.out.println(msg.address());\n"
"    System.out.println(msg.body());\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/reactive-event-bus.adoc:226
#, fuzzy, no-wrap
msgid "Handling Failures"
msgstr "Manejo de fallos"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:229
#, fuzzy
msgid "If a method annotated with `@ConsumeEvent` throws an exception then:"
msgstr "Si un método anotado con `@ConsumeEvent` lanza una excepción entonces:"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:231
#, fuzzy
msgid "if a reply handler is set then the failure is propagated back to the sender via an `io.vertx.core.eventbus.ReplyException` with code `ConsumeEvent#FAILURE_CODE` and the exception message,"
msgstr "si se establece un controlador de respuesta, el fallo se propaga de vuelta al remitente a través de un `io.vertx.core.eventbus.ReplyException` con el código `ConsumeEvent#FAILURE_CODE` y el mensaje de excepción,"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:232
#, fuzzy
msgid "if no reply handler is set then the exception is rethrown (and wrapped in a `RuntimeException` if necessary) and can be handled by the default exception handler, i.e. `io.vertx.core.Vertx#exceptionHandler()`."
msgstr "si no se establece un manejador de respuesta, la excepción se vuelve a lanzar (y se envuelve en un `RuntimeException` si es necesario) y puede ser manejada por el manejador de excepción por defecto, es decir, `io.vertx.core.Vertx#exceptionHandler()`."

#. type: Title ==
#: upstream/_guides/reactive-event-bus.adoc:233
#, fuzzy, no-wrap
msgid "Sending messages"
msgstr "Envío de mensajes"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:237
#, fuzzy
msgid "Ok, we have seen how to receive messages, let's now switch to the _other side_: the sender.  Sending and publishing messages use the Vert.x event bus:"
msgstr "Bien, ya hemos visto cómo recibir mensajes, ahora pasemos al _otro lado_: el emisor. El envío y la publicación de mensajes utilizan el bus de eventos de Vert.x:"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:245
#: upstream/_guides/reactive-event-bus.adoc:317
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Uni;\n"
"import io.vertx.mutiny.core.eventbus.EventBus;\n"
"import io.vertx.mutiny.core.eventbus.Message;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:251
#: upstream/_guides/reactive-event-bus.adoc:323
#, no-wrap
msgid ""
"import jakarta.inject.Inject;\n"
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.Produces;\n"
"import jakarta.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:254
#: upstream/_guides/reactive-event-bus.adoc:326
#, no-wrap
msgid ""
"@Path(\"/async\")\n"
"public class EventResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:257
#, no-wrap
msgid ""
"    @Inject\n"
"    EventBus bus;                                       // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:266
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    @Path(\"{name}\")\n"
"    public Uni<String> greeting(String name) {\n"
"        return bus.<String>request(\"greeting\", name)        // <2>\n"
"                .onItem().transform(Message::body);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:268
#, fuzzy
msgid "Inject the Event bus"
msgstr "Inyectar el bus de eventos"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:269
#, fuzzy
msgid "Send a message to the address `greeting`. Message payload is `name`"
msgstr "Envía un mensaje a la dirección `greeting`. El contenido del mensaje es `name`"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:271
#, fuzzy
msgid "The `EventBus` object provides methods to:"
msgstr "El objeto `EventBus` proporciona métodos para:"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:273
#, fuzzy
msgid "`send` a message to a specific address - one single consumer receives the message."
msgstr "`send` un mensaje a una dirección específica: un solo consumidor recibe el mensaje."

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:274
#, fuzzy
msgid "`publish` a message to a specific address - all consumers receive the messages."
msgstr "`publish` un mensaje a una dirección específica: todos los consumidores reciben los mensajes."

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:275
#, fuzzy
msgid "`send` a message and expect reply asynchronously"
msgstr "`send` un mensaje y esperar respuesta"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:276
#, fuzzy
msgid "`send` a message and expect reply in a blocking manner"
msgstr "`send` un mensaje y esperar respuesta"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:288
#, no-wrap
msgid ""
"// Case 1\n"
"bus.<String>requestAndForget(\"greeting\", name);\n"
"// Case 2\n"
"bus.publish(\"greeting\", name);\n"
"// Case 3\n"
"Uni<String> response = bus.<String>request(\"address\", \"hello, how are you?\")\n"
"        .onItem().transform(Message::body);\n"
"// Case 4\n"
"String response = bus.<String>requestAndAwait(\"greeting\", name).body();\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/reactive-event-bus.adoc:290
#, fuzzy, no-wrap
msgid "Putting things together - bridging HTTP and messages"
msgstr "Unir las cosas: puentear el HTTP y los mensajes"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:296
#, fuzzy
msgid "Let's revisit a greeting HTTP endpoint and use asynchronous message passing to delegate the call to a separated bean.  It uses the request/reply dispatching mechanism.  Instead of implementing the business logic inside the Jakarta REST endpoint, we are sending a message.  This message is consumed by another bean and the response is sent using the _reply_ mechanism."
msgstr "Volvamos a visitar un endpoint HTTP de saludo y utilicemos el paso asíncrono de mensajes para delegar la llamada a un bean separado. Utiliza el mecanismo de envío de solicitud/respuesta. En lugar de implementar la lógica de negocio dentro del endpoint JAX-RS, estamos enviando un mensaje. Este mensaje es consumido por otro bean y la respuesta es enviada usando el mecanismo de _respuesta_."

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:298
#, fuzzy
msgid "First create a new project using:"
msgstr "Primero cree un nuevo proyecto con:"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:304
#, fuzzy
msgid "You can already start the application in _dev mode_ using:"
msgstr "Ya puedes iniciar la aplicación en _modo dev_ con:"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:308
#, fuzzy
msgid "Then, creates a new Jakarta REST resource with the following content:"
msgstr "A continuación, crea un nuevo recurso JAX-RS con el siguiente contenido:"

#. type: Block title
#: upstream/_guides/reactive-event-bus.adoc:310
#, fuzzy, no-wrap
msgid "src/main/java/org/acme/vertx/EventResource.java"
msgstr "src/main/java/org/acme/vertx/EventResource.java"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:329
#, no-wrap
msgid ""
"    @Inject\n"
"    EventBus bus;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:338
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    @Path(\"{name}\")\n"
"    public Uni<String> greeting(String name) {\n"
"        return bus.<String>request(\"greeting\", name)            // <1>\n"
"                .onItem().transform(Message::body);            // <2>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:340
#, fuzzy
msgid "send the `name` to the `greeting` address and request a response"
msgstr "enviar el `name` a la dirección `greeting` y solicitar una respuesta"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:341
#, fuzzy
msgid "when we get the response, extract the body and send it to the user"
msgstr "cuando obtenemos la respuesta, extraemos el cuerpo y lo enviamos al usuario"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:344
#, fuzzy
msgid "If you call this endpoint, you will wait and get a timeout. Indeed, no one is listening.  So, we need a consumer listening on the `greeting` address. Create a `GreetingService` bean with the following content:"
msgstr "Si llama a este punto final, esperará y obtendrá un tiempo de espera. Efectivamente, nadie está escuchando. Por lo tanto, necesitamos un consumidor que escuche en la dirección `greeting`. Crea un bean `GreetingService` con el siguiente contenido:"

#. type: Block title
#: upstream/_guides/reactive-event-bus.adoc:346
#, fuzzy, no-wrap
msgid "src/main/java/org/acme/vertx/GreetingService.java"
msgstr "src/main/java/org/acme/vertx/GreetingService.java"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:361
#, no-wrap
msgid ""
"    @ConsumeEvent(\"greeting\")\n"
"    public String greeting(String name) {\n"
"        return \"Hello \" + name;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:363
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:366
#, fuzzy
msgid "This bean receives the name, and returns the greeting message."
msgstr "Este bean recibe el nombre, y devuelve el mensaje de saludo."

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:368
#, fuzzy
msgid "Now, open your browser to http://localhost:8080/async/Quarkus, and you should see:"
msgstr "Ahora, abre tu navegador en  http://localhost:8080/async/Quarkus , y deberías ver:"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:372
#, no-wrap
msgid "Hello Quarkus\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:375
#, fuzzy
msgid "To better understand, let's detail how the HTTP request/response has been handled:"
msgstr "Para entenderlo mejor, vamos a detallar cómo se ha gestionado la petición/respuesta HTTP:"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:377
#, fuzzy
msgid "The request is received by the `hello` method"
msgstr "La solicitud es recibida por el método `hello`"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:378
#, fuzzy
msgid "a message containing the _name_ is sent to the event bus"
msgstr "se envía un mensaje con el _nombre_ al bus de eventos"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:379
#, fuzzy
msgid "Another bean receives this message and computes the response"
msgstr "Otro frijol recibe este mensaje y calcula la respuesta"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:380
#, fuzzy
msgid "This response is sent back using the reply mechanism"
msgstr "Esta respuesta se devuelve mediante el mecanismo de respuesta"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:381
#, fuzzy
msgid "Once the reply is received by the sender, the content is written to the HTTP response"
msgstr "Una vez que el remitente recibe la respuesta, el contenido se escribe en la respuesta HTTP"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:383
#, fuzzy
msgid "This application can be packaged using:"
msgstr "Esta aplicación se puede empaquetar utilizando:"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:387
#, fuzzy
msgid "You can also compile it as a native executable with:"
msgstr "También puedes compilarlo como un ejecutable nativo con:"

#. type: Title ==
#: upstream/_guides/reactive-event-bus.adoc:390
#, fuzzy, no-wrap
msgid "Using codecs"
msgstr "Uso de códecs"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:395
#, fuzzy
msgid "The https://vertx.io/docs/vertx-core/java/#event_bus[Vert.x Event Bus] uses codecs to _serialize_ and _deserialize_ objects.  Quarkus provides a default codec for local delivery.  So you can exchange objects as follows:"
msgstr "El  link:https://vertx.io/docs/vertx-core/java/#event_bus[bus de eventos Vert.x] utiliza códecs para _serializar_ y _deserializar_ objetos. Quarkus proporciona un códec por defecto para la entrega local. Así que puede intercambiar objetos de la siguiente manera:"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:405
#, no-wrap
msgid ""
"@GET\n"
"@Produces(MediaType.TEXT_PLAIN)\n"
"@Path(\"{name}\")\n"
"public Uni<String> greeting(String name) {\n"
"    return bus.<String>request(\"greeting\", new MyName(name))\n"
"        .onItem().transform(Message::body);\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:410
#, no-wrap
msgid ""
"@ConsumeEvent(value = \"greeting\")\n"
"Uni<String> greeting(MyName name) {\n"
"    return Uni.createFrom().item(() -> \"Hello \" + name.getName());\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:413
#, fuzzy
msgid "If you want to use a specific codec, you need to explicitly set it on both ends:"
msgstr "Si quieres utilizar un códec específico, tienes que configurarlo explícitamente en ambos extremos:"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:424
#, no-wrap
msgid ""
"@GET\n"
"@Produces(MediaType.TEXT_PLAIN)\n"
"@Path(\"{name}\")\n"
"public Uni<String> greeting(String name) {\n"
"    return bus.<String>request(\"greeting\", name,\n"
"        new DeliveryOptions().setCodecName(MyNameCodec.class.getName())) // <1>\n"
"        .onItem().transform(Message::body);\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:429
#, no-wrap
msgid ""
"@ConsumeEvent(value = \"greeting\", codec = MyNameCodec.class)            // <2>\n"
"Uni<String> greeting(MyName name) {\n"
"    return Uni.createFrom().item(() -> \"Hello \"+name.getName());\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:431
#, fuzzy
msgid "Set the name of the codec to use to send the message"
msgstr "Establezca el nombre del códec que se utilizará para enviar el mensaje"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:431
#, fuzzy
msgid "Set the codec to use to receive the message"
msgstr "Establecer el códec que se utilizará para recibir el mensaje"
