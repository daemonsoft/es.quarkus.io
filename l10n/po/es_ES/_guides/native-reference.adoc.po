# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-12-03 08:16+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title =
#: upstream/_guides/native-reference.adoc:7
#, fuzzy, no-wrap
msgid "Native Reference Guide"
msgstr "Guía de referencia nativa"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:20
#, fuzzy
msgid "This guide is a companion to the xref:building-native-image.adoc[Building a Native Executable], xref:native-and-ssl.adoc[Using SSL With Native Images], and xref:writing-native-applications-tips.adoc[Writing Native Applications], guides.  It explores advanced topics that help users diagnose issues, increase the reliability and improve the runtime performance of native executables.  These are the high level sections to be found in this guide:"
msgstr "Esta guía es un complemento de las guías  link:building-native-image.html[Construcción de un ejecutable nativo],  link:native-and-ssl.html[Uso de SSL con imágenes na]tivas y  link:writing-native-applications-tips.html[Escritura de aplicaciones] nativas. Proporciona más detalles para depurar problemas en los ejecutables nativos de Quarkus que puedan surgir durante el desarrollo o la producción."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:22
#, fuzzy
msgid "xref:native-memory-management[Native Memory Management]"
msgstr "link:#native-memory-management[Gestión de memoria nativa]"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:23
#, fuzzy
msgid "xref:inspecting-and-debugging[Inspecting and Debugging Native Executables]"
msgstr "link:#inspecting-and-debugging[Inspección y depuración de ejecutables nativos]"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:24
#, fuzzy
msgid "xref:native-faq[Frequently Asked Questions]"
msgstr "Preguntas frecuentes"

#. type: Title ==
#: upstream/_guides/native-reference.adoc:26
#, fuzzy, no-wrap
msgid "Native Memory Management"
msgstr "Gestión de memoria nativa"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:28
#, fuzzy
msgid "Memory management for Quarkus native executables is enabled by GraalVM’s SubstrateVM runtime system."
msgstr "La gestión de memoria para los ejecutables nativos de Quarkus está habilitada por el sistema de ejecución SubstrateVM de GraalVM."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:30
#, fuzzy
msgid "For detailed explanations about the memory management component in GraalVM, see the link:https://www.graalvm.org/{graalvm-docs-version}/reference-manual/native-image/optimizations-and-performance/MemoryManagement[GraalVM Memory Management] guide."
msgstr "Para obtener explicaciones detalladas sobre el componente de gestión de memoria en GraalVM, consulte la guía de  link:https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/MemoryManagement[gestión de memoria de GraalVM]."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:32
#, fuzzy
msgid "This guide complements the information available in the GraalVM website with further observations particularly relevant to Quarkus applications."
msgstr "Esta guía complementa la información disponible en el sitio web de GraalVM con otras observaciones especialmente relevantes para las aplicaciones Quarkus."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:33
#, fuzzy, no-wrap
msgid "Garbage Collectors"
msgstr "Recolectores de basura"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:35
#, fuzzy
msgid "The garbage collectors available for Quarkus users are currently Serial GC and Epsilon GC."
msgstr "Los recolectores de basura disponibles para los usuarios de Quarkus son actualmente Serial GC y Epsilon GC."

#. type: Title ====
#: upstream/_guides/native-reference.adoc:36
#, fuzzy, no-wrap
msgid "Serial GC"
msgstr "Serie GC"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:40
#, fuzzy
msgid "Serial GC, the default option in GraalVM and Quarkus, is a single-threaded non-concurrent GC, just like HotSpot’s Serial GC.  The implementation in GraalVM however is different from the HotSpot one, and there can be significant differences in the runtime behavior."
msgstr "La GC en serie, la opción por defecto en GraalVM y Quarkus, es una GC no concurrente de un solo hilo, al igual que la GC en serie de HotSpot. Sin embargo, la implementación en GraalVM es diferente a la de HotSpot, y puede haber diferencias significativas en el comportamiento en tiempo de ejecución."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:51
#, fuzzy
msgid "One of the key differences between HotSpot’s Serial GC and GraalVM’s Serial GC is the way they perform full GC cycles.  In HotSpot the algorithm used is mark-sweep-compact whereas in GraalVM it is mark-copy.  Both need to traverse all live objects, but in mark-copy this traversal is also used to copy live objects to a secondary space or semi-space.  As objects are copied from one semi-space to another they’re also compacted.  In mark-sweep-compact, the compacting requires a second pass on the live objects.  This makes full GCs in mark-copy more time efficient (in terms of time spent in each GC cycle) than mark-sweep-compact.  The tradeoff mark-copy makes in order to make individual full GC cycles shorter is space.  The use of semi-spaces means that for an application to maintain the same GC performance that mark-sweep achieves (in terms of allocated MB per second), it requires double the amount of memory."
msgstr "Una de las principales diferencias entre la GC Serial de HotSpot y la GC Serial de GraalVM es la forma en que realizan los ciclos de GC completos. En HotSpot el algoritmo utilizado es mark-sweep-compact mientras que en GraalVM es mark-copy. Ambos necesitan recorrer todos los objetos vivos, pero en mark-copy este recorrido también se utiliza para copiar objetos vivos a un espacio secundario o semiespacio. A medida que los objetos se copian de un semiespacio a otro, también se compactan. En mark-sweep-compact, la compactación requiere una segunda pasada en los objetos vivos. Esto hace que las GC completas en mark-copy sean más eficientes en términos de tiempo (en términos de tiempo empleado en cada ciclo de GC) que en mark-sweep-compact. La compensación que hace mark-copy para acortar los ciclos individuales de GC completa es el espacio. El uso de semiespacios significa que para que una aplicación mantenga el mismo rendimiento de GC que consigue mark-sweep (en términos de MB asignados por segundo), necesita el doble de memoria."

#. type: Title =====
#: upstream/_guides/native-reference.adoc:52
#, fuzzy, no-wrap
msgid "GC Collection Policy"
msgstr "Política de recaudación de GC"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:55
#, fuzzy
msgid "GraalVM's Serial GC implementation offers a choice between two different collection policies, the default is called \"adaptive\" and the alternative is called \"space/time\"."
msgstr "La implementación de la GC en serie de GraalVM ofrece la posibilidad de elegir entre dos políticas de recolección diferentes, la predeterminada se llama \"adaptativa\" y la alternativa se llama \"espacio/tiempo\"."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:59
#, fuzzy
msgid "The “adaptive” collection policy is based on HotSpot's ParallelGC adaptive size policy.  The main difference with HotSpot is GraalVM's focus on memory footprint.  This means that GraalVM’s adaptive GC policy tries to aggressively trigger GCs in order to keep memory consumption down."
msgstr "La política de recogida \"adaptativa\" se basa en la política de tamaño adaptativo ParallelGC de HotSpot. La principal diferencia con HotSpot es que GraalVM se centra en la huella de memoria. Esto significa que la política de GC adaptable de GraalVM trata de activar agresivamente las GCs para mantener el consumo de memoria bajo."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:67
#, fuzzy
msgid "Up to version 2.13, Quarkus used the “space/time” GC collection policy by default, but starting with version 2.14, it switched to using the “adaptive” policy instead.  The reason why Quarkus initially chose to use \"space/time\" is because at that time it had considerable performance improvements over \"adaptive\".  Recent performance experiments, however, indicate that the \"space/time\" policy can result in worse out-of-the-box experience compared to the \"adaptive\" policy, while at the same time the benefits it used to offer have diminished considerably after improvements made to the \"adaptive\" policy.  As a result, the \"adaptive\" policy appears to be the best option for most, if not all, Quarkus applications.  Full details on this switch can be read in link:https://github.com/quarkusio/quarkus/issues/28267[this issue]."
msgstr "Hasta la versión 2.13, Quarkus utilizaba la política de recogida de GC \"espacio/tiempo\" por defecto, pero a partir de la versión 2.14, pasó a utilizar la política \"adaptativa\" en su lugar. La razón por la que Quarkus eligió inicialmente usar \"espacio/tiempo\" es porque en ese momento tenía considerables mejoras de rendimiento sobre \"adaptativo\". Sin embargo, recientes experimentos de rendimiento indican que la política \"espacio/tiempo\" puede dar lugar a una peor experiencia inicial en comparación con la política \"espacio/tiempo\", mientras que al mismo tiempo las ventajas que solía ofrecer han disminuido considerablemente tras las mejoras realizadas en la política \"adaptativa\". Como resultado, la política \"adaptativa\" parece ser la mejor opción para la mayoría, si no todas, las aplicaciones de Quarkus. Los detalles completos de este cambio pueden leerse en  link:https://github.com/quarkusio/quarkus/issues/28267[este número]."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:70
#, fuzzy
msgid "It is still possible to change the GC collection policy using GraalVM’s `-H:InitialCollectionPolicy` flag.  Switching to the \"space/time\" policy can be done by passing the following via command line:"
msgstr "Todavía es posible cambiar la política de recogida de GC utilizando la bandera `-H:InitialCollectionPolicy` de GraalVM. El cambio a la política de \"espacio/tiempo\" se puede hacer pasando lo siguiente a través de la línea de comandos:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:74
#, no-wrap
msgid "-Dquarkus.native.additional-build-args=-H:InitialCollectionPolicy=com.oracle.svm.core.genscavenge.CollectionPolicy\\$BySpaceAndTime\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:77
#, fuzzy
msgid "Or adding this to the `application.properties` file:"
msgstr "O añadiendo esto al archivo `application.properties`:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:81
#, no-wrap
msgid "quarkus.native.additional-build-args=-H:InitialCollectionPolicy=com.oracle.svm.core.genscavenge.CollectionPolicy$BySpaceAndTime\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:87
#, fuzzy
msgid "Escaping the `$` character is required to configure the \"space/time\" GC collection policy if passing via command line in Bash.  Other command line environments might have similar requirements."
msgstr "Es necesario escapar del carácter `$` para configurar la política de recogida de GC \"espacio/tiempo\" si se pasa por línea de comandos en Bash. Otros entornos de línea de comandos pueden tener requisitos similares."

#. type: Title ====
#: upstream/_guides/native-reference.adoc:89
#, fuzzy, no-wrap
msgid "Epsilon GC"
msgstr "Epsilon GC"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:93
#, fuzzy
msgid "Epsilon GC is a no-op garbage collector which does not do any memory reclamation.  From a Quarkus perspective, some of the most relevant use cases for this garbage collector are extremely short-lived jobs, e.g. serverless functions.  To build Quarkus native with epsilon GC, pass the following argument at build time:"
msgstr "Epsilon GC es un recolector de basura no-op que no hace ninguna recuperación de memoria. Desde la perspectiva de Quarkus, algunos de los casos de uso más relevantes para este recolector de basura son trabajos de muy corta duración, por ejemplo, funciones sin servidor. Para construir Quarkus nativo con epsilon GC, pasa el siguiente argumento en el momento de la construcción:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:97
#, no-wrap
msgid "-Dquarkus.native.additional-build-args=--gc=epsilon\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/native-reference.adoc:99
#, fuzzy, no-wrap
msgid "Memory Management Options"
msgstr "Opciones de gestión de la memoria"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:102
#, fuzzy
msgid "For information about options to control maximum heap size, young space, and other typical use cases found in the JVM, see the link:https://www.graalvm.org/{graalvm-docs-version}/reference-manual/native-image/optimizations-and-performance/MemoryManagement[GraalVM Memory Management] guide.  Setting the maximum heap size, either as a percentage or an explicit value, is generally recommended."
msgstr "Las opciones para controlar el tamaño máximo del heap, el espacio joven y otros casos de uso típicos encontrados en la JVM se pueden encontrar en  link:https://www.graalvm.org/{graalvm-version}/reference-manual/native-image/optimizations-and-performance/MemoryManagement[la guía de gestión de memoria de GraalVM]. En general, se recomienda establecer el tamaño máximo de la pila, ya sea como un porcentaje o un valor explícito."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:104
#, fuzzy, no-wrap
msgid "GC Logging"
msgstr "Registro GC"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:107
#, fuzzy
msgid "Multiple options exist to print information about garbage collection cycles, depending on the level of detail required.  The minimum detail is provided `-XX:+PrintGC`, which prints a message for each GC cycle that occurs:"
msgstr "Existen múltiples opciones para imprimir información sobre los ciclos de recolección de basura, dependiendo del nivel de detalle requerido. El detalle mínimo se proporciona `-XX:+PrintGC`, que imprime un mensaje por cada ciclo de GC que se produce:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:114
#, no-wrap
msgid ""
"$ quarkus-project-0.1-SNAPSHOT-runner -XX:+PrintGC -Xmx64m\n"
"...\n"
"[Incremental GC (CollectOnAllocation) 20480K->11264K, 0.0003223 secs]\n"
"[Full GC (CollectOnAllocation) 19456K->5120K, 0.0031067 secs]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:119
#, fuzzy
msgid "When you combine this option with `-XX:+VerboseGC` you still get a message per GC cycle, but it contains extra information.  Also, adding this option shows the sizing decisions made by the GC algorithm at startup:"
msgstr "Cuando se combina esta opción con `-XX:+VerboseGC` se sigue obteniendo un mensaje por ciclo de GC, pero contiene información extra. Además, al añadir esta opción se muestran las decisiones de tamaño tomadas por el algoritmo de GC al inicio:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:138
#, no-wrap
msgid ""
"$ quarkus-project-0.1-SNAPSHOT-runner -XX:+PrintGC -XX:+VerboseGC -Xmx64m\n"
"[Heap policy parameters:\n"
"YoungGenerationSize: 25165824\n"
"MaximumHeapSize: 67108864\n"
"MinimumHeapSize: 33554432\n"
"AlignedChunkSize: 1048576\n"
"LargeArrayThreshold: 131072]\n"
"...\n"
"[[5378479783321 GC: before  epoch: 8  cause: CollectOnAllocation]\n"
"[Incremental GC (CollectOnAllocation) 16384K->9216K, 0.0003847 secs]\n"
"[5378480179046 GC: after   epoch: 8  cause: CollectOnAllocation  policy: adaptive  type: incremental\n"
"collection time: 384755 nanoSeconds]]\n"
"[[5379294042918 GC: before  epoch: 9  cause: CollectOnAllocation]\n"
"[Full GC (CollectOnAllocation) 17408K->5120K, 0.0030556 secs]\n"
"[5379297109195 GC: after   epoch: 9  cause: CollectOnAllocation  policy: adaptive  type: complete\n"
"collection time: 3055697 nanoSeconds]]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:141
#, fuzzy
msgid "Beyond these two options, `-XX:+PrintHeapShape` and `-XX:+TraceHeapChunks` provide even lower level details about memory chunks on top of which the different memory regions are constructed."
msgstr "Más allá de estas dos opciones, `-XX:+PrintHeapShape` y `-XX:+TraceHeapChunks` proporcionan detalles de nivel aún más bajo sobre los trozos de memoria sobre los que se construyen las diferentes regiones de memoria."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:143
#, fuzzy
msgid "The most up-to-date information on GC logging flags can be obtained by printing the list of flags that can be passed to native executables:"
msgstr "La información más actualizada sobre los indicadores de registro de la GC puede obtenerse imprimiendo la lista de indicadores que pueden pasarse a los ejecutables nativos:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:156
#, no-wrap
msgid ""
"$ quarkus-project-0.1-SNAPSHOT-runner -XX:PrintFlags=\n"
"...\n"
"  -XX:±PrintGC                                 Print summary GC information after each collection. Default: - (disabled).\n"
"  -XX:±PrintGCSummary                          Print summary GC information after application main method returns. Default: - (disabled).\n"
"  -XX:±PrintGCTimeStamps                       Print a time stamp at each collection, if +PrintGC or +VerboseGC. Default: - (disabled).\n"
"  -XX:±PrintGCTimes                            Print the time for each of the phases of each collection, if +VerboseGC. Default: - (disabled).\n"
"  -XX:±PrintHeapShape                          Print the shape of the heap before and after each collection, if +VerboseGC. Default: - (disabled).\n"
"...\n"
"  -XX:±TraceHeapChunks                         Trace heap chunks during collections, if +VerboseGC and +PrintHeapShape. Default: - (disabled).\n"
"  -XX:±VerboseGC                               Print more information about the heap before and after each collection. Default: - (disabled).\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/native-reference.adoc:159
#, fuzzy, no-wrap
msgid "Resident Set Size (RSS)"
msgstr "Tamaño del conjunto residente (RSS)"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:166
#, fuzzy
msgid "As described in the xref:performance-measure.adoc[Measuring Performance guide], the footprint of Quarkus applications is measured using the resident set size (RSS).  This is also applicable to native applications, but the runtime engine that manages the footprint in this case is built in the native executable itself rather than the JVM."
msgstr "Como se describe en la  link:performance-measure.html[guía Medición del rendimiento], la huella de las aplicaciones Quarkus se mide utilizando el tamaño del conjunto residente (RSS). Esto también es aplicable a las aplicaciones nativas, pero el motor de tiempo de ejecución que gestiona la huella en este caso se construye en el propio ejecutable nativo en lugar de en la JVM."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:171
#, fuzzy
msgid "The reporting techniques specified in the xref:performance-measure.adoc[Measuring Performance guide] are applicable to native applications too, but what causes the RSS to be higher or lower is specific to how the generated native executables work."
msgstr "Las técnicas de elaboración de informes especificadas en la  link:performance-measure.html[guía Medición del rendimiento] también son aplicables a las aplicaciones nativas, pero lo que hace que el RSS sea mayor o menor es específico del funcionamiento de los ejecutables nativos generados."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:174
#, fuzzy
msgid "When the RSS is higher in one native version of the application versus another, the following checks should be carried out first:"
msgstr "Cuando el RSS es mayor en una versión nativa de la aplicación que en otra, deben realizarse primero las siguientes comprobaciones:"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:178
#, fuzzy
msgid "Check the xref:native-reports[native build time reports] and see if there are big discrepancies in the number of used packages, used classes or used methods.  A bigger universe will result in bigger memory footprint."
msgstr "Comprueba los  link:#native-reports[informes de tiempo de compilación nativos] y mira si hay grandes discrepancias en el número de paquetes usados, clases usadas o métodos usados. Un universo más grande se traducirá en una mayor huella de memoria."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:183
#, fuzzy
msgid "Check the size of the binary for differences.  Using `readelf` you can observe the size of different sections and compare them.  The `.text` section where code lives, and the `.svm_heap` section where heap produced at build time lives, are particularly interesting."
msgstr "Comprueba si hay diferencias en el tamaño del binario. Usando `readelf` puedes observar el tamaño de diferentes secciones y compararlas. La sección `.text` donde vive el código, y la sección `.svm_heap` donde vive el heap producido en tiempo de compilación, son particularmente interesantes."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:184
#, fuzzy
msgid "Generate xref:heap-dumps[heap dumps] and inspect them with tools such as VisualVM or Eclipse MAT."
msgstr "Generar  link:#heap-dumps[volcados de heap] e inspeccionarlos con herramientas como VisualVM o Eclipse MAT."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:192
#, fuzzy
msgid "Often profiling, instrumenting or tracing applications is the best way to figure out how things work.  In the case of RSS and native applications, the techniques that Brendan Gregg explains in the https://www.brendangregg.com/FlameGraphs/memoryflamegraphs.html[\"Memory Leak (and Growth) Flame Graphs\"] guide are particularly useful.  This section will apply the information in that article to show how to use `perf` and https://github.com/iovisor/bcc[bcc/eBPF] to understand what causes Quarkus native executables to consume memory on startup."
msgstr "A menudo, perfilar, instrumentar o rastrear aplicaciones es la mejor manera de averiguar cómo funcionan las cosas. En el caso de las aplicaciones RSS y nativas, las técnicas que Brendan Gregg explica en la guía  link:https://www.brendangregg.com/FlameGraphs/memoryflamegraphs.html[\"Memory Leak (and Growth) Flame Graphs\"] son particularmente útiles. En esta sección se aplicará la información de ese artículo para mostrar cómo usar `perf` y  link:https://github.com/iovisor/bcc[bcc/eBPF] para entender qué hace que los ejecutables nativos de Quarkus consuman memoria al iniciarse."

#. type: Title ====
#: upstream/_guides/native-reference.adoc:194
#, fuzzy, no-wrap
msgid "Perf"
msgstr "Perf"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:199
#, fuzzy
msgid "`perf` works in older Linux systems, whereas eBPF requires a newer Linux kernel.  The overhead of `perf` is higher than eBPF, but it can understand stack traces generated with DWARF debug symbols, which eBPF can't."
msgstr "`perf` funciona en sistemas Linux antiguos, mientras que eBPF requiere un kernel Linux más reciente. La sobrecarga de `perf` es mayor que la de eBPF, pero puede entender las trazas de pila generadas con símbolos de depuración DWARF, cosa que eBPF no puede."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:206
#, fuzzy
msgid "In the context of GraalVM, DWARF stack traces contain more detail and are easier to understand than those generated with frame pointers.  As first step, build a Quarkus native executable with debug info enabled and a couple of extra flags.  One flag to disable optimizations, and another to avoid inlined methods being omitted from the stack traces.  These two flags have been added to obtain stack traces that contain as much information as possible."
msgstr "En el contexto de GraalVM, las trazas de pila DWARF contienen más detalles y son más fáciles de entender que las generadas con punteros de trama. Como primer paso, construye un ejecutable nativo Quarkus con la información de depuración activada y un par de banderas adicionales. Una bandera para desactivar las optimizaciones, y otra para evitar que los métodos inline sean omitidos de las trazas de pila. Estas dos banderas se han añadido para obtener trazas de pila que contengan tanta información como sea posible."

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:212
#, no-wrap
msgid ""
"$ mvn package -DskipTests -Dnative \\\n"
"  -Dquarkus.native.debug.enabled \\\n"
"  -Dquarkus.native.additional-build-args=-O0,-H:-OmitInlinedMethodDebugLineInfo\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:225
#, fuzzy
msgid "Disabling optimizations makes it easier to learn how to use `perf` and get as detailed stack traces as possible, because it shows more info about what gets called where.  However, doing so might lead to more allocations happening which would not happen if optimizations would have been applied.  In other words, passing in `-O0` will change the allocation pattens for many applications, because it disables optimizations such as escape analysis or dead code elimination.  To properly assess the allocations made by an application deployed in production, run with default optimizations (`-O2`).  With default optimizations the stack traces obtained with `perf` maybe be harder to decipher."
msgstr "Desactivar las optimizaciones hace que sea más fácil aprender a utilizar `perf` y obtener trazas de pila tan detalladas como sea posible, ya que muestra más información sobre qué se llama y dónde. Sin embargo, hacerlo puede llevar a que se produzcan más asignaciones que no ocurrirían si se hubieran aplicado las optimizaciones. En otras palabras, pasar `-O0` cambiará los patrones de asignación de muchas aplicaciones, porque desactiva optimizaciones como el análisis de escapes o la eliminación de código muerto. Para evaluar adecuadamente las asignaciones realizadas por una aplicación desplegada en producción, ejecútela con las optimizaciones por defecto ( `-O2`). Con las optimizaciones por defecto las trazas de pila obtenidas con `perf` pueden ser más difíciles de descifrar."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:228
#, fuzzy
msgid "Let's measure how much RSS a Quarkus native executable takes on startup on this particular environment:"
msgstr "Midamos cuánto RSS necesita un ejecutable nativo de Quarkus al iniciarse en este entorno concreto:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:234
#, no-wrap
msgid ""
"$ ps -o pid,rss,command -p $(pidof code-with-quarkus-1.0.0-SNAPSHOT-runner)\n"
"      PID   RSS COMMAND\n"
"     1915 35472 ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner -Xmx128m\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:250
#, fuzzy
msgid "How come this Quarkus native executable consumes ~35MB RSS on startup? To get an understanding of this number, this section will use `perf` to trace calls to `syscalls:sys_enter_mmap`.  Assuming the default link:https://www.graalvm.org/{graalvm-docs-version}/reference-manual/native-image/optimizations-and-performance/MemoryManagement/#serial-garbage-collector[GraalVM Serial Garbage Collector] is in use, this system call is particularly interesting for native executables generated by GraalVM's `native-image` because of how it allocates heap.  In native executables generated by GraalVM's `native-image`, the heap is allocated using either aligned or unaligned heap chunks.  All non-array objects get allocated in thread local aligned chunks.  Each of these are 1MB in size by default.  For arrays, if they are bigger than 1/8 of the aligned chunk size, they will be allocated in unaligned heap chunks which have a size dependant on the object itself.  The very first time a thread allocates an object or small array, it will request an aligned heap chunk that it will use exclusively until it has run out of space in that chunk, in which case it will request another aligned heap chunk.  So by tracing these system calls, the code paths that end up requesting new aligned or unaligned heap chunks will be recorded.  Next, run the Quarkus native executable through `perf record` tracing the `mmap` system call:"
msgstr "¿Cómo es que este ejecutable nativo de Quarkus consume ~35 MB de RSS al iniciarse? Para entender este número, esta sección utilizará `perf` para rastrear las llamadas a `syscalls:sys_enter_mmap`. Asumiendo que el  link:https://www.graalvm.org/{graalvm-version}/reference-manual/native-image/MemoryManagement/#serial-garbage-collector[Serial Garbage Collector] por defecto está en uso, esta llamada al sistema es particularmente interesante para los ejecutables nativos generados por `native-image` de GraalVM debido a cómo asigna el heap. En los ejecutables nativos generados por GraalVM's `native-image`, el heap se asigna usando heap chunks alineados o no alineados. Todos los objetos que no son matrices se asignan en thread local aligned chunks. Por defecto, cada uno de ellos tiene un tamaño de 1MB. En el caso de las matrices, si su tamaño es superior a 1/8 del tamaño del chunk alineado, se asignarán en chunks no alineados, cuyo tamaño dependerá del propio objeto. La primera vez que un hilo asigna un objeto o un array pequeño, solicitará un chunk de heap alineado que utilizará exclusivamente hasta que se quede sin espacio en ese chunk, en cuyo caso solicitará otro chunk de heap alineado. Así que rastreando estas llamadas al sistema, se registrarán las rutas de código que terminan solicitando nuevos trozos de heap alineados o no alineados. A continuación, ejecuta el ejecutable nativo de Quarkus a través de `perf record` rastreando la llamada al sistema `mmap`:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:254
#, no-wrap
msgid "$ sudo perf record -e syscalls:sys_enter_mmap --call-graph dwarf -a -- target/code-with-quarkus-1.0.0-SNAPSHOT-runner -Xmx128m\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:261
#, fuzzy
msgid "The size of the aligned heap chunks can be changed during native build time.  A custom value (in number of bytes) can be passed via the `-H:AlignedHeapChunkSize` flag.  One caveat is that this value needs to be multiple of 4096 (4KB)."
msgstr "El tamaño de los trozos de montón alineados puede cambiarse durante la compilación nativa. Se puede pasar un valor personalizado (en número de bytes) a través de la bandera `-H:AlignedHeapChunkSize`. Una advertencia es que este valor debe ser múltiplo de 4096 (4KB)."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:264
#, fuzzy
msgid "Once the startup completes, stop the process and generate the stacks:"
msgstr "Una vez finalizada la puesta en marcha, detenga el proceso y genere las pilas:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:268
#, no-wrap
msgid "$ perf script > out.stacks\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:273
#, fuzzy
msgid "As a final step, generate a https://github.com/brendangregg/FlameGraph[flamegraph] with the generated stacks:"
msgstr "Como paso final, genere un  link:https://github.com/brendangregg/FlameGraph[flamegráfico] con las pilas generadas:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:279
#, no-wrap
msgid ""
"$ export FG_HOME=...\n"
"$ ${FG_HOME}/stackcollapse-perf.pl < out.stacks | ${FG_HOME}/flamegraph.pl \\\n"
"    --color=mem --title=\"mmap Flame Graph\" --countname=\"calls\" > out.svg\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:282
#, fuzzy
msgid "The flamegraph should look similar to this:"
msgstr "El flamegráfico debería parecerse a esto:"

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_guides/native-reference.adoc:283
#, fuzzy, no-wrap
msgid "mmap flamegraph"
msgstr "Hacer y abrir un flamograma:"

#. type: Target for macro image
#: upstream/_guides/native-reference.adoc:283
#, no-wrap
msgid "mmap.svg"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:286
#, fuzzy
msgid "There are several things of interest to notice there:"
msgstr "Hay varias cosas interesantes en las que fijarse:"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:291
#, fuzzy
msgid "First, the stack traces that contain method calls to `com.oracle.svm.core.genscavenge.ThreadLocalAllocation` are related to aligned or unaligned heap chunk allocations explained above.  As noted earlier, for the majority of allocations these chunks will be 1MB by default, so they're interesting because each allocated chunk has a considerable effect on the RSS consumption."
msgstr "En primer lugar, las trazas de pila que contienen llamadas de método a `com.oracle.svm.core.genscavenge.ThreadLocalAllocation` están relacionadas con las asignaciones de trozos de montón alineados o no alineados explicadas anteriormente. Como se ha señalado anteriormente, para la mayoría de las asignaciones estos trozos serán de 1 MB por defecto, por lo que son interesantes porque cada trozo asignado tiene un efecto considerable en el consumo de RSS."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:299
#, fuzzy
msgid "Second, of the thread allocation stacks, the ones under `start_thread` are particularly revealing.  In this environment, taking into account the `-Xmx` value passed in, Quarkus creates 12 event loop threads.  Aside from those, there are 6 extra threads.  The names of all those 18 threads exceed 16 characters.  This can be observed via the `ps` command:"
msgstr "En segundo lugar, de las pilas de asignación de hilos, las que están bajo `start_thread` son particularmente reveladoras. En este entorno, teniendo en cuenta el valor `-Xmx` pasado, Quarkus crea 12 hilos de bucle de eventos. Aparte de esos, hay 6 hilos adicionales. Los nombres de todos esos 18 hilos superan los 16 caracteres. Esto se puede observar a través del comando `ps`:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:321
#, no-wrap
msgid ""
"$ ps -e -T | grep $(pidof code-with-quarkus-1.0.0-SNAPSHOT-runner)\n"
"   2320    2320 pts/0    00:00:00 code-with-quark\n"
"   2320    2321 pts/0    00:00:00 ference Handler\n"
"   2320    2322 pts/0    00:00:00 gnal Dispatcher\n"
"   2320    2324 pts/0    00:00:00 ecutor-thread-0\n"
"   2320    2325 pts/0    00:00:00 -thread-checker\n"
"   2320    2326 pts/0    00:00:00 ntloop-thread-0\n"
"   2320    2327 pts/0    00:00:00 ntloop-thread-1\n"
"   2320    2328 pts/0    00:00:00 ntloop-thread-2\n"
"   2320    2329 pts/0    00:00:00 ntloop-thread-3\n"
"   2320    2330 pts/0    00:00:00 ntloop-thread-4\n"
"   2320    2331 pts/0    00:00:00 ntloop-thread-5\n"
"   2320    2332 pts/0    00:00:00 ntloop-thread-6\n"
"   2320    2333 pts/0    00:00:00 ntloop-thread-7\n"
"   2320    2334 pts/0    00:00:00 ntloop-thread-8\n"
"   2320    2335 pts/0    00:00:00 ntloop-thread-9\n"
"   2320    2336 pts/0    00:00:00 tloop-thread-10\n"
"   2320    2337 pts/0    00:00:00 tloop-thread-11\n"
"   2320    2338 pts/0    00:00:00 ceptor-thread-0\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:330
#, fuzzy
msgid "The very first allocation that all these threads do is taking the thread name and trimming it so that it can fall within the character limit enforced by kernels.  For each of those allocations, there are 2 `mmap` calls, one to reserve the memory and the other to commit it.  When recording `syscalls:sys_enter_mmap` system call, the `perf` implementation tracks calls to `__GI___mmap64`.  But this glibc `__GI___mmap64` implementation makes another call into `__GI___mmap64`:"
msgstr "La primera asignación que hacen todos estos hilos es tomar el nombre del hilo y recortarlo para que pueda entrar dentro del límite de caracteres impuesto por los núcleos. Para cada una de esas asignaciones, hay 2 llamadas a `mmap`, una para reservar la memoria y la otra para confirmarla. Al grabar la llamada al sistema `syscalls:sys_enter_mmap`, la implementación `perf` rastrea las llamadas a `_GI__mmap64`. Pero esta implementación glibc `_GI__mmap64` hace otra llamada a `_GI__mmap64`:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:360
#, no-wrap
msgid ""
"(gdb) break __GI___mmap64\n"
"(gdb) set scheduler-locking step\n"
"...\n"
"Thread 2 \"code-with-quark\" hit Breakpoint 1, __GI___mmap64 (offset=0, fd=-1, flags=16418, prot=0, len=2097152, addr=0x0) at ../sysdeps/unix/sysv/linux/mmap64.c:58\n"
"58\t  return (void *) MMAP_CALL (mmap, addr, len, prot, flags, fd, offset);\n"
"(gdb) bt\n"
"#0  __GI___mmap64 (offset=0, fd=-1, flags=16418, prot=0, len=2097152, addr=0x0) at ../sysdeps/unix/sysv/linux/mmap64.c:58\n"
"#1  __GI___mmap64 (addr=0x0, len=2097152, prot=0, flags=16418, fd=-1, offset=0) at ../sysdeps/unix/sysv/linux/mmap64.c:46\n"
"#2  0x00000000004f4033 in com.oracle.svm.core.posix.headers.Mman$NoTransitions::mmap (__0=<optimized out>, __1=<optimized out>, __2=<optimized out>, __3=<optimized out>, __4=<optimized out>, __5=<optimized out>)\n"
"#3  0x00000000004f194e in com.oracle.svm.core.posix.PosixVirtualMemoryProvider::reserve (this=0x7ffff7691220, nbytes=0x100000, alignment=0x100000, executable=false) at com/oracle/svm/core/posix/PosixVirtualMemoryProvider.java:126\n"
"#4  0x00000000004ef3b3 in com.oracle.svm.core.os.AbstractCommittedMemoryProvider::allocate (this=0x7ffff7658cb0, size=0x100000, alignment=0x100000, executable=false) at com/oracle/svm/core/os/AbstractCommittedMemoryProvider.java:124\n"
"#5  0x0000000000482f40 in com.oracle.svm.core.os.AbstractCommittedMemoryProvider::allocateAlignedChunk (this=0x7ffff7658cb0, nbytes=0x100000, alignment=0x100000) at com/oracle/svm/core/os/AbstractCommittedMemoryProvider.java:107\n"
"#6  com.oracle.svm.core.genscavenge.HeapChunkProvider::produceAlignedChunk (this=0x7ffff7444398) at com/oracle/svm/core/genscavenge/HeapChunkProvider.java:112\n"
"#7  0x0000000000489485 in com.oracle.svm.core.genscavenge.ThreadLocalAllocation::slowPathNewArrayLikeObject0 (hub=0x7ffff6ff6110, length=15, size=0x20, podReferenceMap=0x7ffff6700000) at com/oracle/svm/core/genscavenge/ThreadLocalAllocation.java:306\n"
"#8  0x0000000000489165 in com.oracle.svm.core.genscavenge.ThreadLocalAllocation::slowPathNewArrayLikeObject (objectHeader=0x8f6110 <io.smallrye.common.expression.ExpressionNode::toString+160>, length=15, podReferenceMap=0x7ffff6700000) at com/oracle/svm/core/genscavenge/ThreadLocalAllocation.java:279\n"
"#9  0x0000000000489066 in com.oracle.svm.core.genscavenge.ThreadLocalAllocation::slowPathNewArray (objectHeader=0x8f6110 <io.smallrye.common.expression.ExpressionNode::toString+160>, length=15) at com/oracle/svm/core/genscavenge/ThreadLocalAllocation.java:242\n"
"#10 0x0000000000d202a1 in java.util.Arrays::copyOfRange (original=0x7ffff6a33410, from=2, to=17) at java/util/Arrays.java:3819\n"
"#11 0x0000000000acf8e6 in java.lang.StringLatin1::newString (val=0x7ffff6a33410, index=2, len=15) at java/lang/StringLatin1.java:769\n"
"#12 0x0000000000acac59 in java.lang.String::substring (this=0x7ffff6dc0d48, beginIndex=2, endIndex=17) at java/lang/String.java:2712\n"
"#13 0x0000000000acaba2 in java.lang.String::substring (this=0x7ffff6dc0d48, beginIndex=2) at java/lang/String.java:2680\n"
"#14 0x00000000004f96cd in com.oracle.svm.core.posix.thread.PosixPlatformThreads::setNativeName (this=0x7ffff7658d10, thread=0x7ffff723fb30, name=0x7ffff6dc0d48) at com/oracle/svm/core/posix/thread/PosixPlatformThreads.java:163\n"
"#15 0x00000000004f9285 in com.oracle.svm.core.posix.thread.PosixPlatformThreads::beforeThreadRun (this=0x7ffff7658d10, thread=0x7ffff723fb30) at com/oracle/svm/core/posix/thread/PosixPlatformThreads.java:212\n"
"#16 0x00000000005237a2 in com.oracle.svm.core.thread.PlatformThreads::threadStartRoutine (threadHandle=0x1) at com/oracle/svm/core/thread/PlatformThreads.java:760\n"
"#17 0x00000000004f9627 in com.oracle.svm.core.posix.thread.PosixPlatformThreads::pthreadStartRoutine (data=0x2a06e20) at com/oracle/svm/core/posix/thread/PosixPlatformThreads.java:203\n"
"#18 0x0000000000462ab0 in com.oracle.svm.core.code.IsolateEnterStub::PosixPlatformThreads_pthreadStartRoutine_38d96cbc1a188a6051c29be1299afe681d67942e (__0=<optimized out>) at com/oracle/svm/core/code/IsolateEnterStub.java:1\n"
"#19 0x00007ffff7e4714d in start_thread (arg=<optimized out>) at pthread_create.c:442\n"
"#20 0x00007ffff7ec8950 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:366
#, fuzzy
msgid "Setting `set scheduler-locking step` when the Quarkus native executable is running through `gdb` makes it easier to debug multi-threaded applications.  It optimizes for single-stepping by stopping other threads from \"seizing the prompt\" by preempting the current thread is being stepped through."
msgstr "Configurar `set scheduler-locking step` cuando el ejecutable nativo de Quarkus se está ejecutando a través de `gdb` facilita la depuración de aplicaciones multihilo. Optimiza el paso único impidiendo que otros subprocesos \"se apoderen del prompt\" adelantándose al subproceso actual que se está ejecutando."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:370
#, fuzzy
msgid "This is how the above flamegraph shows a total of 72 calls to `__GI___mmap64` for the thread name abbreviation stack trace, given that Quarkus native executable runs 18 threads."
msgstr "Así es como el flamegráfico anterior muestra un total de 72 llamadas a `_GI__mmap64` para el rastreo de pila de la abreviatura del nombre del hilo, dado que el ejecutable nativo Quarkus ejecuta 18 hilos."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:380
#, fuzzy
msgid "A third, and final observation, is that if you capture the `syscalls:sys_enter_munmmap` event, you might observe that some allocations also result in calls to `munmap`.  When calculating the size to reserve, the requested size to allocate can be rounded up to the page size.  The maintain alignment, 1MB in case of aligned chunks or 1 byte for unaligned chunks, some of the reserved memory might be unreserved.  That is where these `munmap` calls would come from."
msgstr "Una tercera, y última observación, es que si capturas el evento `syscalls:sys_enter_munmmap`, podrías observar que algunas asignaciones también resultan en llamadas a `munmap`. Al calcular el tamaño a reservar, el tamaño solicitado para asignar puede redondearse al tamaño de la página. Al mantener la alineación, 1MB en caso de chunks alineados o 1 byte para chunks no alineados, parte de la memoria reservada podría quedar sin reservar. De ahí vendrían estas llamadas a `munmap`."

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:389
#, fuzzy
msgid "Just by looking at the flamegraph and counting the number of `mmap` calls that originate in thread local allocations, an approximate estimation can be made on the RSS a Quarkus native executable uses on startup.  This estimation can't be fully precise because for unaligned heap chunks, the stack trace doesn't record the size of the chunk.  Also, if the additional build args are removed, inlining optimizations might obscure the type of array allocation chunk requested, so it might not be possible to decipher if the allocation is for an aligned or unaligned chunk."
msgstr "Sólo con mirar el flamegraph y contar el número de llamadas a `mmap` que se originan en asignaciones locales de hilos, se puede hacer una estimación aproximada del RSS que un ejecutable nativo de Quarkus utiliza al arrancar. Esta estimación no puede ser totalmente precisa porque para los trozos de heap no alineados, la traza de la pila no registra el tamaño del trozo. Además, si se eliminan los argumentos de compilación adicionales, las optimizaciones de inlining podrían ocultar el tipo de trozo de asignación de array solicitado, por lo que podría no ser posible descifrar si la asignación es para un trozo alineado o no alineado."

#. type: Title ====
#: upstream/_guides/native-reference.adoc:392
#, fuzzy, no-wrap
msgid "bcc/eBPF"
msgstr "bcc/eBPF"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:402
#, fuzzy
msgid "A version of https://github.com/iovisor/bcc[bcc]/ https://ebpf.io/[eBPF] that can do stack traces is only available from Linux kernel 4.8 onwards.  It can do in-kernel summaries, which makes it more efficient and has lower overhead.  Unfortunately it doesn't understand DWARF debug symbols, so the information obtained might be harder to read and contain less detail."
msgstr "Una versión de  link:https://github.com/iovisor/bcc[bcc/]  link:https://ebpf.io/[eBPF] que puede hacer stack traces sólo está disponible a partir del kernel 4.8 de Linux. Puede hacer resúmenes dentro del núcleo, lo que lo hace más eficiente y tiene menos sobrecarga. Desafortunadamente no entiende los símbolos de depuración DWARF, por lo que la información obtenida puede ser más difícil de leer y contener menos detalles."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:411
#, fuzzy
msgid "bcc/eBPF is very extensible so it's easier to tailor make scripts to track specific metrics.  The `bcc` project contains a `stackcount` program that can be used to count stack traces in similar way to what `perf` did in the previous section.  But in some cases, it might be more useful to have other metrics other than number of calls to a system call.  `malloc` is one such example.  The number of `malloc` calls is not so important, but rather the size of the allocations.  So rather than having a flamegraph showing sample counts, a flamegraph can be generated that shows bytes allocated."
msgstr "bcc/eBPF es muy extensible por lo que es más fácil hacer scripts a medida para rastrear métricas específicas. El proyecto `bcc` contiene un programa `stackcount` que se puede utilizar para contar trazas de pila de forma similar a lo que hizo `perf` en la sección anterior. Pero en algunos casos, puede ser más útil tener otras métricas que no sean el número de llamadas a una llamada del sistema. `malloc` es un ejemplo de ello. El número de llamadas a `malloc` no es tan importante, sino el tamaño de las asignaciones. Así, en lugar de tener un flamegráfico que muestre el recuento de muestras, se puede generar un flamegráfico que muestre los bytes asignados."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:415
#, fuzzy
msgid "Aside from `mmap`, `malloc` system calls are also present in native executables generated by GraalVM.  Let's put bcc/eBPF in action to generate a flamegraph of bytes allocated using `malloc`."
msgstr "Además de `mmap`, las llamadas al sistema `malloc` también están presentes en los ejecutables nativos generados por GraalVM. Pongamos bcc/eBPF en acción para generar un flamegráfico de bytes asignados usando `malloc`."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:420
#, fuzzy
msgid "To do this, first re-generate a Quarkus native executable removing debug info, which bcc/eBPF does not understand, and instead use frame pointer with local symbols to get the stack traces:"
msgstr "Para hacer esto, primero re-generar un ejecutable nativo de Quarkus eliminando la información de depuración, que bcc/eBPF no entiende, y en su lugar usar frame pointer con símbolos locales para obtener las trazas de pila:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:425
#, no-wrap
msgid ""
"$ mvn package -DskipTests -Dnative \\\n"
"  -Dquarkus.native.additional-build-args=-H:-DeleteLocalSymbols,-H:+PreserveFramePointer\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:435
#, fuzzy
msgid "The link:mallocstacks.py[mallocstacks.py] bcc/eBPF script will be used to capture the `malloc` stacktraces with their allocated size.  This script, and other typical bcc/eBPF scripts (e.g. `stackcount`), need to be given a process ID (PID).  This makes a bit tricky when you want to trace startup, but you can use `gdb` (even if you haven't enabled debug info)  to get around this obstacle because it allows you to stop the application at the first instruction.  Let's start by running the native executable via `gdb`:"
msgstr "El script bcc/eBPF  link:mallocstacks.py[mallocstacks.] py se utilizará para capturar los stacktraces de `malloc` con su tamaño asignado. Este script, y otros scripts bcc/eBPF típicos (por ejemplo `stackcount`), necesitan que se les dé un ID de proceso (PID). Esto lo hace un poco complicado cuando quieres rastrear el inicio, pero puedes usar `gdb` (incluso si no has habilitado la información de depuración) para sortear este obstáculo porque te permite detener la aplicación en la primera instrucción. Empecemos ejecutando el ejecutable nativo a través de `gdb`:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:441
#, no-wrap
msgid ""
"$ gdb --args ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner -Xmx128m\n"
"...\n"
"(No debugging symbols found in ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner)\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:444
#, fuzzy
msgid "`starti` is a `gdb` command that sets a temporary breakpoint at the very first instruction of the program's execution."
msgstr "`starti` es un comando de `gdb` que establece un punto de interrupción temporal en la primera instrucción de la ejecución del programa."

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:451
#, no-wrap
msgid ""
"(gdb) starti\n"
"Starting program: <..>/code-with-quarkus/target/code-with-quarkus-1.0.0-SNAPSHOT-runner -Xmx128m\n"
"Program stopped.\n"
"0x00007ffff7fe4790 in _start () from /lib64/ld-linux-x86-64.so.2\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:456
#, fuzzy
msgid "Next invoke the bcc/eBPF script giving it the PID of the Quarkus process, so that it can track the `malloc` calls, capture stack traces and dump them to a file for post-processing:"
msgstr "A continuación, invoque el script bcc/eBPF dándole el PID del proceso Quarkus, para que pueda rastrear las llamadas a `malloc`, capturar las trazas de la pila y volcarlas a un archivo para su post-procesamiento:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:460
#, no-wrap
msgid "$ sudo ./mallocstacks.py -p $(pidof code-with-quarkus-1.0.0-SNAPSHOT-runner) -f > out.stacks\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:463
#, fuzzy
msgid "Then go back to the `gdb` shell and instruct it to continue the startup procedure after hitting the first instruction:"
msgstr "A continuación, vuelva al intérprete de comandos `gdb` e indíquele que continúe con el procedimiento de arranque tras pulsar la primera instrucción:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:480
#, no-wrap
msgid ""
"(gdb) continue\n"
"Continuing.\n"
"[Thread debugging using libthread_db enabled]\n"
"Using host libthread_db library \"/lib64/libthread_db.so.1\".\n"
"[New Thread 0x7ffff65ff6c0 (LWP 3342)]\n"
"...\n"
"[New Thread 0x7fffc6ffd6c0 (LWP 3359)]\n"
"__  ____  __  _____   ___  __ ____  ______\n"
" --/ __ \\/ / / / _ | / _ \\/ //_/ / / / __/\n"
" -/ /_/ / /_/ / __ |/ , _/ ,< / /_/ /\\ \\\n"
"--\\___\\_\\____/_/ |_/_/|_/_/|_|\\____/___/\n"
"2023-02-09 18:02:32,794 INFO  [io.quarkus] (main) code-with-quarkus 1.0.0-SNAPSHOT native (powered by Quarkus 2.16.1.Final) started in 0.011s. Listening on: http://0.0.0.0:8080\n"
"2023-02-09 18:02:32,794 INFO  [io.quarkus] (main) Profile prod activated.\n"
"2023-02-09 18:02:32,794 INFO  [io.quarkus] (main) Installed features: [cdi, resteasy-reactive, smallrye-context-propagation, vertx]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:484
#, fuzzy
msgid "Once the startup has complete, press `Ctrl-C` on the `stackcount` shell."
msgstr "Una vez finalizado el arranque, pulse `Ctrl-C` en el intérprete de comandos `stackcount`."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:488
#, fuzzy
msgid "Then process the stacks file as a flamegraph.  Note that the stacks generated by this script are already collapsed, so the flamegraph can be generated just like this:"
msgstr "A continuación, procese el archivo de pilas como un flamegráfico. Tenga en cuenta que las pilas generadas por este script ya están colapsadas, por lo que el flamegráfico se puede generar tal cual:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:492
#, no-wrap
msgid "$ cat out.stacks | ${FG_HOME}/flamegraph.pl --color=mem --title=\"malloc bytes Flame Graph\" --countname=\"bytes\" > out.svg\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:495
#, fuzzy
msgid "The flamegraph produced should look something like this:"
msgstr "El flamegráfico producido debería tener este aspecto:"

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_guides/native-reference.adoc:496
#, fuzzy, no-wrap
msgid "malloc bytes flamegraph"
msgstr "malloc bytes flamegraph"

#. type: Target for macro image
#: upstream/_guides/native-reference.adoc:496
#, no-wrap
msgid "malloc-bytes.svg"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:503
#, fuzzy
msgid "This shows that most of the memory requested using `malloc` comes from epoll in Java NIO, but the overall amount allocated via `malloc` is barely 268KB.  This amount of 274,269 bytes can be observed by hovering on top of `all` at the bottom of flamegraph (you might need to ask the browser to open the flamegraph in a different tab or window to observe this).  This is very small compared with the amount allocated for the heap with `mmap`."
msgstr "Esto muestra que la mayor parte de la memoria solicitada mediante `malloc` proviene de epoll en Java NIO, pero la cantidad total asignada mediante `malloc` es de apenas 268 KB. Esta cantidad de 274.269 bytes puede observarse haciendo hoovering sobre `all` en la parte inferior del flamegraph (puede que necesites pedir al navegador que abra el flamegraph en una pestaña o ventana diferente para observar esto). Esto es muy pequeño comparado con la cantidad asignada para el montón con `mmap`."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:506
#, fuzzy
msgid "Finally, just a brief mention about other bcc/eBPF commands, and how to transform them into flamegraphs."
msgstr "Por último, sólo una breve mención sobre otros comandos bcc/eBPF, y cómo transformarlos en flamegráficos."

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:511
#, no-wrap
msgid ""
"$ sudo /usr/share/bcc/tools/stackcount -P -p $(pidof code-with-quarkus-1.0.0-SNAPSHOT-runner) \\\n"
"  -U \"t:syscalls:sys_enter_m*\" # count stacks for mmap and munmap\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:514
#, no-wrap
msgid ""
"$ sudo /usr/share/bcc/tools/stackcount -P -p $(pidof code-with-quarkus-1.0.0-SNAPSHOT-runner) \\\n"
"  -U \"c:*alloc\" # count stacks for malloc, calloc and realloc\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:517
#, no-wrap
msgid ""
"$ sudo /usr/share/bcc/tools/stackcount -P -p $(pidof code-with-quarkus-1.0.0-SNAPSHOT-runner) \\\n"
"  -U \"c:free\" # count stacks for free\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:520
#, no-wrap
msgid ""
"$ sudo /usr/share/bcc/tools/stackcount -P -p $(pidof code-with-quarkus-1.0.0-SNAPSHOT-runner) \\\n"
"  -U \"t:exceptions:page_fault_*\" # count stacks for page faults\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:524
#, fuzzy
msgid "Stacks produced by `stackcount` need to be collapsed before they can be transformed into flamegraphs.  For example:"
msgstr "Las pilas producidas por `stackcount` deben colapsarse antes de transformarlas en flamegráficos. Por ejemplo:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:529
#, no-wrap
msgid ""
"${FG_HOME}/stackcollapse.pl < out.stacks | ${FG_HOME}/flamegraph.pl \\\n"
"  --color=mem --title=\"mmap munmap Flame Graph\" --countname=\"calls\" > out.svg\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/native-reference.adoc:532
#, fuzzy, no-wrap
msgid "Inspecting and Debugging Native Executables"
msgstr "Inspección de ejecutables nativos"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:534
#, fuzzy
msgid "This debugging guide provides further details on debugging issues in Quarkus native executables that might arise during development or production."
msgstr "Esta guía de depuración proporciona más detalles sobre los problemas de depuración en los ejecutables nativos de Quarkus que pueden surgir durante el desarrollo o la producción."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:537
#, fuzzy
msgid "It takes as input the application developed in the xref:getting-started.adoc[Getting Started Guide].  You can find instructions on how to quickly set up this application in this guide."
msgstr "Esta guía de referencia toma como entrada la aplicación desarrollada en la  link:getting-started.html[Guía de inicio]. En esta guía encontrará instrucciones sobre cómo configurar rápidamente esta aplicación."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:538
#, fuzzy, no-wrap
msgid "Requirements and Assumptions"
msgstr "Requisitos y supuestos"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:541
#, fuzzy
msgid "This debugging guide has the following requirements:"
msgstr "Esta guía tiene los siguientes requisitos:"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:543
#, fuzzy
msgid "JDK 11 installed with `JAVA_HOME` configured appropriately"
msgstr "JDK 11 instalado con `JAVA_HOME` configurado adecuadamente"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:544
#, fuzzy
msgid "Apache Maven {maven-version}"
msgstr "Apache Maven {versión de Maven}"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:545
#, fuzzy
msgid "A working container runtime (Docker, podman)"
msgstr "Un tiempo de ejecución de contenedores que funcione (Docker, podman)"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:550
#, fuzzy
msgid "This guide builds and executes Quarkus native executables within a Linux environment.  To offer a homogeneous experience across all environments, the guide relies on a container runtime environment to build and run the native executables.  The instructions below use Docker as example, but very similar commands should work on alternative container runtimes, e.g. podman."
msgstr "Esta guía construye y ejecuta los ejecutables nativos de Quarkus en un entorno Linux. Para ofrecer una experiencia homogénea en todos los entornos, la guía se basa en un entorno de ejecución de contenedores para construir y ejecutar los ejecutables nativos. Las instrucciones a continuación utilizan Docker como ejemplo, pero comandos muy similares deberían funcionar en tiempos de ejecución de contenedores alternativos, por ejemplo, podman."

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:556
#, fuzzy
msgid "Building native executables is an expensive process, so make sure the container runtime has enough CPU and memory to do this.  A minimum of 4 CPUs and 4GB of memory is required."
msgstr "La construcción de ejecutables nativos es un proceso costoso, así que asegúrate de que el tiempo de ejecución del contenedor tiene suficiente CPU y memoria para hacerlo. Se requiere un mínimo de 4 CPUs y 4GB de memoria."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:560
#, fuzzy
msgid "Finally, this guide assumes the use of the link:https://github.com/graalvm/mandrel[Mandrel distribution] of GraalVM for building native executables, and these are built within a container so there is no need for installing Mandrel on the host."
msgstr "Por último, esta guía asume el uso de la  link:https://github.com/graalvm/mandrel[distribución Mandrel] de GraalVM para la construcción de ejecutables nativos, y estos se construyen dentro de un contenedor por lo que no hay necesidad de instalar Mandrel en el host."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:561
#, fuzzy, no-wrap
msgid "Bootstrapping the project"
msgstr "Puesta en marcha del proyecto"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:565
#, fuzzy
msgid "Start by creating a new Quarkus project.  Open a terminal and run the following command:"
msgstr "Comience por crear un nuevo proyecto Quarkus. Abra un terminal y ejecute el siguiente comando:"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:567
#, fuzzy
msgid "For Linux & MacOS users"
msgstr "Para usuarios de Linux y MacOS"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:574
#, fuzzy
msgid "For Windows users"
msgstr "Para los usuarios de Windows"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:576
#, fuzzy
msgid "If using cmd , (don't use backward slash `\\` and put everything on the same line)"
msgstr "Si utiliza cmd , (no utilice la barra invertida `\\` y ponga todo en la misma línea)"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:577
#, fuzzy
msgid "If using Powershell , wrap `-D` parameters in double quotes e.g. `\"-DprojectArtifactId=debugging-native\"`"
msgstr "Si utiliza Powershell, envuelva los parámetros de `-D` entre comillas dobles, por ejemplo `\"-DprojectArtifactId=debugging-native\"`"

#. type: Title ===
#: upstream/_guides/native-reference.adoc:578
#, fuzzy, no-wrap
msgid "Configure Quarkus properties"
msgstr "Configurar las propiedades de Quarkus"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:584
#, fuzzy
msgid "Some Quarkus configuration options will be used constantly throughout this debugging guide, so to help declutter command line invocations, it's recommended to add these options to the `application.properties` file.  So, go ahead and add the following options to that file:"
msgstr "Algunas opciones de configuración de Quarkus se utilizarán constantemente a lo largo de esta guía, así que para ayudar a desordenar las invocaciones de la línea de comandos, se recomienda añadir estas opciones al archivo `application.properties`. Por lo tanto, sigue adelante y añade las siguientes opciones a ese archivo:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:591
#, no-wrap
msgid ""
"quarkus.native.container-build=true\n"
"quarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel-builder-image:{mandrel-flavor}\n"
"quarkus.container-image.build=true\n"
"quarkus.container-image.group=test\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:598
#, fuzzy
msgid "Starting with 22.3, Mandrel does not provide a `-java11` version anymore.  Note, however, that this doesn't mean that you may no longer produce native executables with Mandrel for Java 11 projects.  You can still compile your Java 11 projects using OpenJDK 11 and produce native executables from the resulting Java 11 bytecode using the `-java17` Mandrel builder images."
msgstr "A partir de la versión 22.3, Mandrel ya no proporciona una versión `-java11`. Tenga en cuenta, sin embargo, que esto no significa que ya no pueda producir ejecutables nativos con Mandrel para proyectos Java 11. Todavía puede compilar sus proyectos de Java 11 utilizando OpenJDK 11 y producir ejecutables nativos a partir del código de bytes de Java 11 resultante utilizando las imágenes de construcción de Mandrel de `-java17`."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:600
#, fuzzy, no-wrap
msgid "First Debugging Steps"
msgstr "Primeros pasos de depuración"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:603
#, fuzzy
msgid "As a first step, change to the project directory and build the native executable for the application:"
msgstr "Como primer paso, cambie al directorio del proyecto y construya el ejecutable nativo de la aplicación:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:607
#: upstream/_guides/native-reference.adoc:1072
#, no-wrap
msgid "./mvnw package -DskipTests -Dnative\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:610
#, fuzzy
msgid "Run the application to verify it works as expected. In one terminal:"
msgstr "Ejecute la aplicación para verificar que funciona como se espera. En un terminal:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:614
#: upstream/_guides/native-reference.adoc:1080
#, no-wrap
msgid "docker run -i --rm -p 8080:8080 test/debugging-native:1.0.0-SNAPSHOT\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:617
#, fuzzy
msgid "In another:"
msgstr "En otro:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:621
#, no-wrap
msgid "curl -w '\\n' http://localhost:8080/hello\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:626
#, fuzzy
msgid "The rest of this section explores ways to build the native executable with extra information, but first, stop the running application.  We can obtain this information while building the native executable by adding additional native-image build options using `-Dquarkus.native.additional-build-args`, e.g."
msgstr "El resto de esta sección explora las formas de construir el ejecutable nativo con información extra, pero primero, detenga la aplicación en ejecución. Podemos obtener esta información mientras se construye el ejecutable nativo añadiendo opciones adicionales de construcción de imágenes nativas utilizando `-Dquarkus.native.additional-build-args`, por ejemplo"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:631
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative \\\n"
"    -Dquarkus.native.additional-build-args=--native-image-info\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:634
#, fuzzy
msgid "Executing that will produce additional output lines like this:"
msgstr "Ejecutar eso producirá líneas de salida adicionales como esta:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:641
#, no-wrap
msgid ""
"...\n"
"# Printing compilation-target information to: /project/reports/target_info_20220223_100915.txt\n"
"…\n"
"# Printing native-library information to: /project/reports/native_library_info_20220223_100925.txt\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:649
#, fuzzy
msgid "Note that `/project` is a folder within the container that is building the native executable.  So, this is not a folder that you will find in the host environment.  `/project` folder is mapped to `target/debugging-native-1.0.0-SNAPSHOT-native-image-source-jar`, so you will find the files under the `reports` folder in that directory."
msgstr "Tenga en cuenta que `/project` es una carpeta dentro del contenedor que está construyendo el ejecutable nativo. Por lo tanto, no es una carpeta que se encuentre en el entorno anfitrión. La carpeta `/project` está asignada a `target/debugging-native-1.0.0-SNAPSHOT-native-image-source-jar`, por lo que encontrará los archivos bajo la carpeta `reports` en ese directorio."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:654
#, fuzzy
msgid "The target info file contains information such as the target platform, the toolchain used to compile the executable, and the C library in use:"
msgstr "El archivo de información de destino contiene información como la plataforma de destino, la cadena de herramientas utilizada para compilar el ejecutable y la biblioteca C en uso:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:666
#, no-wrap
msgid ""
"$ cat target/*/reports/target_info_*.txt\n"
"Building image for target platform: org.graalvm.nativeimage.Platform$LINUX_AMD64\n"
"Using native toolchain:\n"
"   Name: GNU project C and C++ compiler (gcc)\n"
"   Vendor: redhat\n"
"   Version: 8.5.0\n"
"   Target architecture: x86_64\n"
"   Path: /usr/bin/gcc\n"
"Using CLibrary: com.oracle.svm.core.posix.linux.libc.GLib\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:669
#, fuzzy
msgid "The native library info file contains information on the static libraries added to the binary and the other libraries dynamically linked to the executable:"
msgstr "El archivo de información de la biblioteca nativa contiene información sobre las bibliotecas estáticas añadidas al binario y las otras bibliotecas enlazadas dinámicamente al ejecutable:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:684
#, no-wrap
msgid ""
"$ cat target/*/reports/native_library_info_*.txt\n"
"Static libraries:\n"
"   ../opt/mandrel/lib/svm/clibraries/linux-amd64/liblibchelper.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libnet.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libextnet.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libnio.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libjava.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libfdlibm.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libsunec.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libzip.a\n"
"   ../opt/mandrel/lib/svm/clibraries/linux-amd64/libjvm.a\n"
"Other libraries: stdc++,pthread,dl,z,rt\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:689
#, fuzzy
msgid "Even more detail can be obtained by passing in `--verbose` as an additional native-image build argument.  This option can be very useful in detecting whether the options that you pass at a high level via Quarkus are being passed down to the native executable production, or whether some third party jar has some native-image configuration embedded in it that is reaching the native-image invocation:"
msgstr "Se pueden obtener aún más detalles pasando `--verbose` como un argumento adicional de construcción de la imagen nativa. Esta opción puede ser muy útil para detectar si las opciones que se pasan a un alto nivel a través de Quarkus se están pasando a la producción del ejecutable nativo, o si algún tarro de terceros tiene alguna configuración de imagen nativa incrustada que está llegando a la invocación de la imagen nativa:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:694
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative \\\n"
"    -Dquarkus.native.additional-build-args=--verbose\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:697
#, fuzzy
msgid "Running with `--verbose` demonstrates how the native-image building process is two sequential java processes:"
msgstr "La ejecución con `--verbose` demuestra cómo el proceso de construcción de imágenes nativas son dos procesos java secuenciales:"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:700
#, fuzzy
msgid "The first is a very short Java process that does some basic validation and builds the arguments for the second process (in a stock GraalVM distribution, this is executed as native code)."
msgstr "El primero es un proceso Java muy corto que hace alguna validación básica y construye los argumentos para el segundo proceso (en una distribución de GraalVM, esto se ejecuta como código nativo)."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:703
#, fuzzy
msgid "The second Java process is where the main part of the native executable production happens.  The `--verbose` option shows the actual Java process executed.  You could take the output and run it yourself."
msgstr "El segundo proceso Java es donde ocurre la parte principal de la producción del ejecutable nativo. La opción `--verbose` muestra el proceso Java real ejecutado. Puedes tomar la salida y ejecutarlo tú mismo."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:705
#, fuzzy
msgid "One may also combine multiple native build options by separating with a comma, e.g.:"
msgstr "También se pueden combinar varias opciones de construcción nativa separándolas con una coma, por ejemplo"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:710
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative \\\n"
"    -Dquarkus.native.additional-build-args=--native-image-info,--verbose\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:716
#, fuzzy
msgid "Remember that if an argument for `-Dquarkus.native.additional-build-args` includes the `,` symbol, it needs to be escaped to be processed correctly, e.g. `\\\\,`."
msgstr "Recuerde que si un argumento para `-Dquarkus.native.additional-build-args` incluye el símbolo `,`, es necesario escaparlo para que se procese correctamente, por ejemplo, `\\\\,`."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:718
#, fuzzy, no-wrap
msgid "Inspecting Native Executables"
msgstr "Inspección de ejecutables nativos"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:724
#, fuzzy
msgid "Given a native executable, various Linux tools can be used to inspect it.  To allow supporting a variety of environments, inspections will be done from within a Linux container.  Let's create a Linux container image with all the tools required for this guide:"
msgstr "Dado un ejecutable nativo, se pueden utilizar varias herramientas de Linux para inspeccionarlo. Para permitir el soporte de una variedad de entornos, las inspecciones se harán desde un contenedor Linux. Vamos a crear una imagen de contenedor Linux con todas las herramientas necesarias para esta guía:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:728
#, no-wrap
msgid "FROM fedora:35\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:735
#, no-wrap
msgid ""
"RUN dnf install -y \\\n"
"binutils \\\n"
"gdb \\\n"
"git \\\n"
"perf \\\n"
"perl-open\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:737
#, no-wrap
msgid "ENV FG_HOME /opt/FlameGraph\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:739
#, no-wrap
msgid "RUN git clone https://github.com/brendangregg/FlameGraph $FG_HOME\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:741
#, no-wrap
msgid "WORKDIR /data\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:743
#, no-wrap
msgid "ENTRYPOINT /bin/bash\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:746
#, fuzzy
msgid "Using docker in the non-Linux environment, you can create an image using this Dockerfile via:"
msgstr "Utilizando Docker en el entorno no Linux, puede crear una imagen utilizando este Dockerfile a través de:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:750
#, no-wrap
msgid "docker build -t fedora-tools:v1 .\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:753
#, fuzzy
msgid "Then, go to the root of the project and run the Docker container we have just created as:"
msgstr "A continuación, vaya a la raíz del proyecto y ejecute el contenedor Docker que acabamos de crear como"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:757
#, no-wrap
msgid "docker run -t -i --rm -v ${PWD}:/data -p 8080:8080 fedora-tools:v1\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:760
#, fuzzy
msgid "`ldd` shows the shared library dependencies of an executable:"
msgstr "`ldd` muestra las dependencias de la biblioteca compartida de un ejecutable:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:764
#, no-wrap
msgid "ldd ./target/debugging-native-1.0.0-SNAPSHOT-runner\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:767
#, fuzzy
msgid "`strings` can be used to look for text messages inside the binary:"
msgstr "`strings` puede utilizarse para buscar mensajes de texto dentro del binario:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:771
#, no-wrap
msgid "strings ./target/debugging-native-1.0.0-SNAPSHOT-runner | grep Hello\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:774
#, fuzzy
msgid "Using `strings` you can also get Mandrel information given the binary:"
msgstr "Utilizando `strings` también se puede obtener la información del mandril dado el binario:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:778
#, no-wrap
msgid "strings ./target/debugging-native-1.0.0-SNAPSHOT-runner | grep core.VM\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:782
#, fuzzy
msgid "Finally, using `readelf` we can inspect different sections of the binary.  For example, we can see how the heap and text sections take most of the binary:"
msgstr "Por último, utilizando `readelf` podemos inspeccionar diferentes secciones del binario. Por ejemplo, podemos ver cómo las secciones de montón y texto ocupan la mayor parte del binario:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:786
#, no-wrap
msgid "readelf -SW ./target/debugging-native-1.0.0-SNAPSHOT-runner\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:793
#, fuzzy
msgid "Runtime containers produced by Quarkus to run native executables will not include the tools mentioned above.  To explore a native executable within a runtime container, it's best to run the container itself and then `docker cp` the executable locally, e.g.:"
msgstr "Los contenedores de tiempo de ejecución producidos por Quarkus para ejecutar ejecutables nativos no incluirán las herramientas mencionadas anteriormente. Para explorar un ejecutable nativo dentro de un contenedor de ejecución, lo mejor es ejecutar el propio contenedor y luego `docker cp` el ejecutable localmente, por ejemplo:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:798
#, no-wrap
msgid ""
"docker run -i --rm --name=mytest -p 8080:8080 test/debugging-native:1.0.0-SNAPSHOT\n"
"docker cp mytest:/work/application path/on/host/\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:801
#, fuzzy
msgid "From there, you can either inspect the executable directly or use a tools container like above."
msgstr "A partir de ahí, puedes inspeccionar el ejecutable directamente o utilizar un contenedor de herramientas como el anterior."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:804
#, fuzzy, no-wrap
msgid "Native Reports"
msgstr "Informes nativos"

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:807
#, fuzzy
msgid "Optionally, the native build process can generate reports that show what goes into the binary:"
msgstr "Opcionalmente, el proceso de construcción nativo puede generar informes que muestren lo que entra en el binario:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:812
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative \\\n"
"    -Dquarkus.native.enable-reports\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:816
#, fuzzy
msgid "The reports will be created under `target/debugging-native-1.0.0-SNAPSHOT-native-image-source-jar/reports/`.  These reports are some of the most useful resources when encountering issues with missing methods/classes, or encountering forbidden methods by Mandrel."
msgstr "Los informes se crearán en `target/debugging-native-1.0.0-SNAPSHOT-native-image-source-jar/reports/`. Estos informes son algunos de los recursos más útiles cuando se encuentran problemas con métodos/clases que faltan, o se encuentran con métodos prohibidos por Mandrel."

#. type: Title ====
#: upstream/_guides/native-reference.adoc:817
#, fuzzy, no-wrap
msgid "Call Tree Reports"
msgstr "Informes del árbol de llamadas"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:823
#, fuzzy
msgid "`call_tree` csv file reports are some of the default reports generated when the `-Dquarkus.native.enable-reports` option is passed in.  These csv files can be imported into a graph database, such as Neo4j, to inspect them more easily and run queries against the call tree.  This is useful for getting an approximation on why a method/class is included in the binary."
msgstr "`call_tree` El informe del archivo de texto es uno de los informes generados por defecto cuando se pasa la opción `-Dquarkus.native.enable-reports`. Es útil para obtener una aproximación de por qué un método/clase está incluido en el binario. Sin embargo, el formato de texto hace que sea muy difícil de leer y puede ocupar mucho espacio."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:825
#, fuzzy
msgid "Let’s see this in action."
msgstr "Veamos esto en acción."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:827
#, fuzzy
msgid "First, start a Neo4j instance:"
msgstr "En primer lugar, inicia una instancia de Neo4j:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:838
#, no-wrap
msgid ""
"export NEO_PASS=...\n"
"docker run \\\n"
"    --detach \\\n"
"    --rm \\\n"
"    --name testneo4j \\\n"
"    -p7474:7474 -p7687:7687 \\\n"
"    --env NEO4J_AUTH=neo4j/${NEO_PASS} \\\n"
"    neo4j:latest\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:843
#, fuzzy
msgid "Once the container is running, you can access the link:http://localhost:7474[Neo4j browser].  Use `neo4j` as the username and the value of `NEO_PASS` as the password to log in."
msgstr "Una vez que el contenedor está en funcionamiento, puedes acceder al  link:http://localhost:7474[navegador Neo4j]. Utiliza `neo4j` como nombre de usuario y el valor de `NEO_PASS` como contraseña para acceder."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:846
#, fuzzy
msgid "To import the CSV files, we need the following cypher script which will import the data within the CSV files and create graph database nodes and edges:"
msgstr "Para importar los archivos CSV, necesitamos el siguiente script cypher que importará los datos dentro de los archivos CSV y creará los nodos y aristas de la base de datos gráfica:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:851
#, no-wrap
msgid ""
"CREATE CONSTRAINT unique_vm_id ON (v:VM) ASSERT v.vmId IS UNIQUE;\n"
"CREATE CONSTRAINT unique_method_id ON (m:Method) ASSERT m.methodId IS UNIQUE;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:855
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/call_tree_vm.csv' AS row\n"
"MERGE (v:VM {vmId: row.Id, name: row.Name})\n"
"RETURN count(v);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:859
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/call_tree_methods.csv' AS row\n"
"MERGE (m:Method {methodId: row.Id, name: row.Name, type: row.Type, parameters: row.Parameters, return: row.Return, display: row.Display})\n"
"RETURN count(m);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:863
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/call_tree_virtual_methods.csv' AS row\n"
"MERGE (m:Method {methodId: row.Id, name: row.Name, type: row.Type, parameters: row.Parameters, return: row.Return, display: row.Display})\n"
"RETURN count(m);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:869
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/call_tree_entry_points.csv' AS row\n"
"MATCH (m:Method {methodId: row.Id})\n"
"MATCH (v:VM {vmId: '0'})\n"
"MERGE (v)-[:ENTRY]->(m)\n"
"RETURN count(*);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:875
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/call_tree_direct_edges.csv' AS row\n"
"MATCH (m1:Method {methodId: row.StartId})\n"
"MATCH (m2:Method {methodId: row.EndId})\n"
"MERGE (m1)-[:DIRECT {bci: row.BytecodeIndexes}]->(m2)\n"
"RETURN count(*);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:881
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/call_tree_override_by_edges.csv' AS row\n"
"MATCH (m1:Method {methodId: row.StartId})\n"
"MATCH (m2:Method {methodId: row.EndId})\n"
"MERGE (m1)-[:OVERRIDEN_BY]->(m2)\n"
"RETURN count(*);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:887
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/call_tree_virtual_edges.csv' AS row\n"
"MATCH (m1:Method {methodId: row.StartId})\n"
"MATCH (m2:Method {methodId: row.EndId})\n"
"MERGE (m1)-[:VIRTUAL {bci: row.BytecodeIndexes}]->(m2)\n"
"RETURN count(*);\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:890
#, fuzzy
msgid "Copy and paste the contents of the script into a file called `import.cypher`."
msgstr "Copie y pegue el contenido del script en un archivo llamado `import.cypher`."

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:896
#, fuzzy
msgid "Mandrel 22.0.0 contains a bug where the symbolic links used by the import cypher file are not correctly set when generating reports within a container (for more details see link:https://github.com/oracle/graal/issues/4355[here]).  This can be worked around by copying the following script into a file and executing it:"
msgstr "Mandrel 22.0.0 contiene un error en el que los enlaces simbólicos utilizados por el archivo cypher de importación no se establecen correctamente cuando se generan informes dentro de un contenedor (para más detalles ver  link:https://github.com/oracle/graal/issues/4355[aquí]). Esto se puede solucionar copiando el siguiente script en un archivo y ejecutándolo:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:900
#, no-wrap
msgid "set -e\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:902
#, no-wrap
msgid "project=\"debugging-native\"\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:904
#, no-wrap
msgid "pushd target/*-native-image-source-jar/reports\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:907
#, no-wrap
msgid ""
"rm -f call_tree_vm.csv\n"
"ln -s call_tree_vm_${project}-* call_tree_vm.csv\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:910
#, no-wrap
msgid ""
"rm -f call_tree_direct_edges.csv\n"
"ln -s call_tree_direct_edges_${project}-* call_tree_direct_edges.csv\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:913
#, no-wrap
msgid ""
"rm -f call_tree_entry_points.csv\n"
"ln -s call_tree_entry_points_${project}-* call_tree_entry_points.csv\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:916
#, no-wrap
msgid ""
"rm -f call_tree_methods.csv\n"
"ln -s call_tree_methods_${project}-* call_tree_methods.csv\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:919
#, no-wrap
msgid ""
"rm -f call_tree_virtual_edges.csv\n"
"ln -s call_tree_virtual_edges_${project}-* call_tree_virtual_edges.csv\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:922
#, no-wrap
msgid ""
"rm -f call_tree_virtual_methods.csv\n"
"ln -s call_tree_virtual_methods_${project}-* call_tree_virtual_methods.csv\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:925
#, no-wrap
msgid ""
"rm -f call_tree_override_by_edges.csv\n"
"ln -s call_tree_override_by_edges_${project}-* call_tree_override_by_edges.csv\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:927
#, no-wrap
msgid "popd\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:931
#, fuzzy
msgid "Next, copy the import cypher script and CSV files into Neo4j's import folder:"
msgstr "A continuación, copia el script de importación y los archivos CSV en la carpeta de importación de Neo4j:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:937
#, no-wrap
msgid ""
"docker cp \\\n"
"    target/*-native-image-source-jar/reports \\\n"
"    testneo4j:/var/lib/neo4j/import\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:939
#, no-wrap
msgid "docker cp import.cypher testneo4j:/var/lib/neo4j\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:942
#, fuzzy
msgid "After copying all the files, invoke the import script:"
msgstr "Después de copiar todos los archivos, invoque el script de importación:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:946
#, no-wrap
msgid "docker exec testneo4j bin/cypher-shell -u neo4j -p ${NEO_PASS} -f import.cypher\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:950
#, fuzzy
msgid "Once the import completes (shouldn't take more than a couple of minutes), go to the link:http://localhost:7474[Neo4j browser], and you'll be able to observe a small summary of the data in the graph:"
msgstr "Una vez completada la importación (no debería tardar más de un par de minutos), ve al  link:http://localhost:7474[navegador Neo4j], y podrás observar un pequeño resumen de los datos en el gráfico:"

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_guides/native-reference.adoc:951
#, fuzzy, no-wrap
msgid "Neo4j database information after import"
msgstr "Información de la base de datos Neo4j después de la importación"

#. type: Target for macro image
#: upstream/_guides/native-reference.adoc:951
#, no-wrap
msgid "native-reference-neo4j-db-info.png"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:956
#, fuzzy
msgid "The data above shows that there are ~60000 methods, and just over ~200000 edges between them.  The Quarkus application demonstrated here is very basic, so there’s not a lot we can explore, but here are some example queries you can run to explore the graph in more detail.  Typically, you’d start by looking for a given method:"
msgstr "Los datos anteriores muestran que hay ~60000 métodos, y algo más de ~200000 aristas entre ellos. La aplicación Quarkus demostrada aquí es muy básica, así que no hay mucho que podamos explorar, pero aquí hay algunas consultas de ejemplo que puedes ejecutar para explorar el gráfico con más detalle. Típicamente, empezarías buscando un método determinado:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:960
#, no-wrap
msgid "match (m:Method) where m.name = \"hello\" return *\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:963
#, fuzzy
msgid "From there, you can narrow down to a given method on a specific type:"
msgstr "A partir de ahí, puedes limitarte a un método determinado en un tipo específico:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:967
#, no-wrap
msgid "match (m:Method) where m.name = \"hello\" and m.type =~ \".*GreetingResource\" return *\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:974
#, fuzzy
msgid "Once you’ve located the node for the specific method you’re after, a typical question you’d want to get an answer for is: why does this method get included in the call tree? To do that, start from the method and look for incoming connections at a given depth, starting from the end method.  For example, methods that directly call a method can be located via:"
msgstr "Una vez que hayas localizado el nodo del método específico que buscas, una pregunta típica para la que querrías obtener una respuesta es: ¿por qué se incluye este método en el árbol de llamadas? Para ello, empieza por el método y busca las conexiones entrantes a una profundidad determinada, empezando por el método final. Por ejemplo, los métodos que llaman directamente a un método pueden ser localizados a través de:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:978
#, no-wrap
msgid "match (m:Method) <- [*1..1] - (o) where m.name = \"hello\" and m.type =~ \".*GreetingResource\" return *\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:982
#, fuzzy
msgid "Then you can look for direct calls at depth of 2, so you’d search for methods that call methods that call into the target method:"
msgstr "Entonces puedes buscar llamadas directas a profundidad de 2, así que buscarías métodos que llamen a métodos que llamen al método objetivo:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:986
#, no-wrap
msgid "match (m:Method) <- [*1..2] - (o) where m.name = \"hello\" and m.type =~ \".*GreetingResource\" return *\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:992
#, fuzzy
msgid "You can continue going up layers, but unfortunately if you reach a depth with too many nodes, the Neo4j browser will be unable to visualize them all.  When that happens, you can alternatively run the queries directly against the cypher shell:"
msgstr "Puedes seguir subiendo capas, pero lamentablemente si llegas a una profundidad con demasiados nodos, el navegador Neo4j no podrá visualizarlos todos. Cuando esto ocurra, puedes ejecutar las consultas directamente contra el shell de cypher:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:997
#, no-wrap
msgid ""
"docker exec testneo4j bin/cypher-shell -u neo4j -p ${NEO_PASS} \\\n"
"  \"match (m:Method) <- [*1..10] - (o) where m.name = 'hello' and m.type =~ '.*GreetingResource' return *\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1002
#, fuzzy
msgid "For further information, check out this link:https://quarkus.io/blog/quarkus-native-neo4j-call-tree[blog post] that explores the Quarkus Hibernate ORM quickstart using the techniques explained above."
msgstr "Para obtener más información, consulte esta  link:https://quarkus.io/blog/quarkus-native-neo4j-call-tree[entrada del blog] que explora el inicio rápido de Quarkus Hibernate ORM utilizando las técnicas explicadas anteriormente."

#. type: Title ====
#: upstream/_guides/native-reference.adoc:1003
#, fuzzy, no-wrap
msgid "Used Packages/Classes/Methods Reports"
msgstr "Informes de paquetes/clases/métodos utilizados"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1007
#, fuzzy
msgid "`used_packages`, `used_classes` and `used_methods` text file reports come in handy when comparing different versions of the application, e.g. why does the image take longer to build? Or why is the image bigger now?"
msgstr "`used_packages`Los informes de los archivos de texto `used_classes` y `used_methods` resultan muy útiles cuando se comparan diferentes versiones de la aplicación, por ejemplo, ¿por qué la imagen tarda más en construirse? ¿O por qué la imagen es más grande ahora?"

#. type: Title ====
#: upstream/_guides/native-reference.adoc:1008
#, fuzzy, no-wrap
msgid "Further Reports"
msgstr "Otros informes"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1012
#, fuzzy
msgid "Mandrel can produce further reports beyond the ones that are enabled with the `-Dquarkus.native.enable-reports` option.  These are called expert options and you can learn more about them by running:"
msgstr "Mandrel puede producir otros informes además de los que se activan con la opción `-Dquarkus.native.enable-reports`. Estas se llaman opciones expertas y puede aprender más sobre ellas ejecutando:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1016
#, no-wrap
msgid "docker run quay.io/quarkus/ubi-quarkus-mandrel-builder-image:{mandrel-flavor} --expert-options-all\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:1022
#, fuzzy
msgid "These expert options are not considered part of the GraalVM native image API, so they might change anytime."
msgstr "Estas opciones expertas no se consideran parte de la API de imagen nativa de GraalVM, por lo que podrían cambiar en cualquier momento."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1025
#, fuzzy
msgid "To use these expert options, add them comma separated to the `-Dquarkus.native.additional-build-args` parameter."
msgstr "Para utilizar estas opciones de experto, añádelas separadas por comas al parámetro `-Dquarkus.native.additional-build-args`."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:1026
#, fuzzy, no-wrap
msgid "Build-time vs Run-time Initialization"
msgstr "Inicialización en tiempo de compilación y en tiempo de ejecución"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1033
#, fuzzy
msgid "Quarkus instructs Mandrel to initialize as much as possible at build time, so that runtime startup can be as fast as possible.  This is important in containerized environments where the startup speed has a big impact on how quickly an application is ready to do work.  Build time initialization also minimizes the risk of runtime failures due to unsupported features becoming reachable through runtime initialization, thus making Quarkus more reliable."
msgstr "Quarkus instruye a Mandrel para que inicialice todo lo posible en el momento de la construcción, para que el arranque en tiempo de ejecución sea lo más rápido posible. Esto es importante en entornos de contenedores donde la velocidad de arranque tiene un gran impacto en la rapidez con la que una aplicación está lista para trabajar. La inicialización en tiempo de construcción también minimiza el riesgo de fallos en tiempo de ejecución debido a que las características no soportadas son accesibles a través de la inicialización en tiempo de ejecución, haciendo así a Quarkus más fiable."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1037
#, fuzzy
msgid "The most common examples of build-time initialized code are static variables and blocks.  Although Mandrel executes those at run-time by default, Quarkus instructs Mandrel to run them at build-time for the reasons given."
msgstr "Los ejemplos más comunes de código inicializado en tiempo de compilación son las variables estáticas y los bloques. Aunque Mandrel los ejecuta en tiempo de ejecución por defecto, Quarkus le indica a Mandrel que los ejecute en tiempo de compilación por las razones expuestas."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1041
#, fuzzy
msgid "This means that any static variables initialized inline, or initialized in a static block, will keep the same value even if the application is restarted.  This is a different behaviour compared to what would happen if executed as Java."
msgstr "Esto significa que cualquier variable estática inicializada en línea, o inicializada en un bloque estático, mantendrá el mismo valor incluso si la aplicación se reinicia. Este es un comportamiento diferente en comparación con lo que ocurriría si se ejecutara como Java."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1044
#, fuzzy
msgid "To see this in action with a very basic example, add a new `TimestampResource` to the application that looks like this:"
msgstr "Para ver esto en acción con un ejemplo muy básico, añada un nuevo `TimestampResource` a la aplicación con el siguiente aspecto:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1048
#: upstream/_guides/native-reference.adoc:1100
#: upstream/_guides/native-reference.adoc:1246
#: upstream/_guides/native-reference.adoc:1438
#: upstream/_guides/native-reference.adoc:1575
#, no-wrap
msgid "package org.acme;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1053
#: upstream/_guides/native-reference.adoc:1251
#, no-wrap
msgid ""
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.Produces;\n"
"import jakarta.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1056
#, no-wrap
msgid ""
"@Path(\"/timestamp\")\n"
"public class TimestampResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1058
#, no-wrap
msgid "    static long firstAccess = System.currentTimeMillis();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1065
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String timestamp() {\n"
"        return \"First access \" + firstAccess;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1068
#, fuzzy
msgid "Rebuild the binary using:"
msgstr "Reconstruye el binario usando:"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1076
#, fuzzy
msgid "Run the application in one terminal (make sure you stop any other native executable container runs before executing this):"
msgstr "Ejecute la aplicación en un terminal (asegúrese de detener cualquier otra ejecución nativa del contenedor antes de ejecutar esto):"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1083
#, fuzzy
msgid "Send a `GET` request multiple times from another terminal:"
msgstr "Enviar una solicitud de `GET` varias veces desde otro terminal:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1087
#, no-wrap
msgid "curl -w '\\n' http://localhost:8080/timestamp # run this multiple times\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1092
#, fuzzy
msgid "to see how the current time has been baked into the binary.  This time was calculated when the binary was being built, hence application restarts have no effect."
msgstr "para ver cómo se ha incorporado la hora actual al binario. Esta hora se calculó cuando se estaba construyendo el binario, por lo que los reinicios de la aplicación no tienen ningún efecto."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1096
#, fuzzy
msgid "In some situations, built time initializations can lead to errors when building native executables.  One example is when a value gets computed at build time which is forbidden to reside in the heap of the JVM that gets baked into the binary.  To see this in action, add this REST resource:"
msgstr "En algunas situaciones, las inicializaciones en tiempo de compilación pueden conducir a errores al construir ejecutables nativos. Un ejemplo es cuando se calcula un valor en tiempo de compilación que está prohibido que resida en el montón de la JVM que se incorpora al binario. Para ver esto en acción, añada este recurso REST:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1109
#, no-wrap
msgid ""
"import javax.crypto.Cipher;\n"
"import javax.crypto.NoSuchPaddingException;\n"
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
"import java.nio.charset.StandardCharsets;\n"
"import java.security.KeyPair;\n"
"import java.security.KeyPairGenerator;\n"
"import java.security.NoSuchAlgorithmException;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1112
#, no-wrap
msgid ""
"@Path(\"/encrypt-decrypt\")\n"
"public class EncryptDecryptResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1115
#, no-wrap
msgid ""
"    static final KeyPairGenerator KEY_PAIR_GEN;\n"
"    static final Cipher CIPHER;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1120
#, no-wrap
msgid ""
"    static {\n"
"        try {\n"
"            KEY_PAIR_GEN = KeyPairGenerator.getInstance(\"RSA\");\n"
"            KEY_PAIR_GEN.initialize(1024);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1126
#, no-wrap
msgid ""
"            CIPHER = Cipher.getInstance(\"RSA\");\n"
"        } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {\n"
"            throw new RuntimeException(e);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1131
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/{message}\")\n"
"    public String encryptDecrypt(String message) throws Exception {\n"
"        KeyPair keyPair = KEY_PAIR_GEN.generateKeyPair();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1133
#, no-wrap
msgid "        byte[] text = message.getBytes(StandardCharsets.UTF_8);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1137
#, no-wrap
msgid ""
"        // Encrypt with private key\n"
"        CIPHER.init(Cipher.ENCRYPT_MODE, keyPair.getPrivate());\n"
"        byte[] encrypted = CIPHER.doFinal(text);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1141
#, no-wrap
msgid ""
"        // Decrypt with public key\n"
"        CIPHER.init(Cipher.DECRYPT_MODE, keyPair.getPublic());\n"
"        byte[] unencrypted = CIPHER.doFinal(encrypted);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1145
#, no-wrap
msgid ""
"        return new String(unencrypted, StandardCharsets.UTF_8);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1148
#, fuzzy
msgid "When trying to rebuild the application, you’ll encounter an error:"
msgstr "Al intentar reconstruir la aplicación, se encontrará con un error:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1167
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative\n"
"...\n"
"Error: Unsupported features in 2 methods\n"
"Detailed message:\n"
"Error: Detected an instance of Random/SplittableRandom class in the image heap. Instances created during image generation have cached seed values and don't behave as expected.  To see how this object got instantiated use --trace-object-instantiation=java.security.SecureRandom. The object was probably created by a class initializer and is reachable from a static field. You can request class initialization at image runtime by using the option --initialize-at-run-time=<class-name>. Or you can write your own initialization methods and call them explicitly from your main entry point.\n"
"Trace: Object was reached by\n"
"\treading field java.security.KeyPairGenerator$Delegate.initRandom of\n"
"\t\tconstant java.security.KeyPairGenerator$Delegate@58b0fe1b reached by\n"
"\treading field org.acme.EncryptDecryptResource.KEY_PAIR_GEN\n"
"Error: Detected an instance of Random/SplittableRandom class in the image heap. Instances created during image generation have cached seed values and don't behave as expected.  To see how this object got instantiated use --trace-object-instantiation=java.security.SecureRandom. The object was probably created by a class initializer and is reachable from a static field. You can request class initialization at image runtime by using the option --initialize-at-run-time=<class-name>. Or you can write your own initialization methods and call them explicitly from your main entry point.\n"
"Trace: Object was reached by\n"
"\treading field sun.security.rsa.RSAKeyPairGenerator.random of\n"
"\t\tconstant sun.security.rsa.RSAKeyPairGenerator$Legacy@3248a092 reached by\n"
"\treading field java.security.KeyPairGenerator$Delegate.spi of\n"
"\t\tconstant java.security.KeyPairGenerator$Delegate@58b0fe1b reached by\n"
"\treading field org.acme.EncryptDecryptResource.KEY_PAIR_GEN\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1175
#, fuzzy
msgid "So, what the message above is telling us is that our application caches a value that is supposed to be random as a constant.  This is not desirable because something that's supposed to be random is no longer so, because the seed is baked in the image.  The message above makes it quite clear what is causing this, but in other situations the cause might be more obfuscated.  As a next step, we'll add some extra flags to the native executable generation to get more information."
msgstr "Entonces, lo que el mensaje anterior nos está diciendo es que nuestra aplicación almacena en caché un valor que se supone que es aleatorio como una constante. Esto no es deseable, porque algo que se supone que es aleatorio ya no lo es, porque la semilla se ha incorporado a la imagen. El mensaje anterior deja bastante claro cuál es la causa de esto, pero en otras situaciones la causa podría estar más ofuscada. Como siguiente paso, añadiremos algunas banderas extra a la generación del ejecutable nativo para obtener más información."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1177
#, fuzzy
msgid "As suggested by the message, let's start by adding an option to track object instantiation:"
msgstr "Como se sugiere en el mensaje, empecemos por añadir una opción de seguimiento de la instanciación de objetos:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1207
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative \\\n"
"    -Dquarkus.native.additional-build-args=\"--trace-object-instantiation=java.security.SecureRandom\"\n"
"...\n"
"Error: Unsupported features in 2 methods\n"
"Detailed message:\n"
"Error: Detected an instance of Random/SplittableRandom class in the image heap. Instances created during image generation have cached seed values and don't behave as expected.  Object has been initialized by the com.sun.jndi.dns.DnsClient class initializer with a trace:\n"
" \tat java.security.SecureRandom.<init>(SecureRandom.java:218)\n"
"\tat sun.security.jca.JCAUtil$CachedSecureRandomHolder.<clinit>(JCAUtil.java:59)\n"
"\tat sun.security.jca.JCAUtil.getSecureRandom(JCAUtil.java:69)\n"
"\tat com.sun.jndi.dns.DnsClient.<clinit>(DnsClient.java:82)\n"
". Try avoiding to initialize the class that caused initialization of the object. The object was probably created by a class initializer and is reachable from a static field. You can request class initialization at image runtime by using the option --initialize-at-run-time=<class-name>. Or you can write your own initialization methods and call them explicitly from your main entry point.\n"
"Trace: Object was reached by\n"
"\treading field java.security.KeyPairGenerator$Delegate.initRandom of\n"
"\t\tconstant java.security.KeyPairGenerator$Delegate@4a5058f9 reached by\n"
"\treading field org.acme.EncryptDecryptResource.KEY_PAIR_GEN\n"
"Error: Detected an instance of Random/SplittableRandom class in the image heap. Instances created during image generation have cached seed values and don't behave as expected.  Object has been initialized by the com.sun.jndi.dns.DnsClient class initializer with a trace:\n"
" \tat java.security.SecureRandom.<init>(SecureRandom.java:218)\n"
"\tat sun.security.jca.JCAUtil$CachedSecureRandomHolder.<clinit>(JCAUtil.java:59)\n"
"\tat sun.security.jca.JCAUtil.getSecureRandom(JCAUtil.java:69)\n"
"\tat com.sun.jndi.dns.DnsClient.<clinit>(DnsClient.java:82)\n"
". Try avoiding to initialize the class that caused initialization of the object. The object was probably created by a class initializer and is reachable from a static field. You can request class initialization at image runtime by using the option --initialize-at-run-time=<class-name>. Or you can write your own initialization methods and call them explicitly from your main entry point.\n"
"Trace: Object was reached by\n"
"\treading field sun.security.rsa.RSAKeyPairGenerator.random of\n"
"\t\tconstant sun.security.rsa.RSAKeyPairGenerator$Legacy@71880cf1 reached by\n"
"\treading field java.security.KeyPairGenerator$Delegate.spi of\n"
"\t\tconstant java.security.KeyPairGenerator$Delegate@4a5058f9 reached by\n"
"\treading field org.acme.EncryptDecryptResource.KEY_PAIR_GEN\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1216
#, fuzzy
msgid "The error messages point to the code in the example, but it can be surprising that a reference to `DnsClient` appears.  Why is that? The key is in what happens inside `KeyPairGenerator.initialize()` method call.  It uses `JCAUtil.getSecureRandom()` which is why this is problematic, but sometimes the tracing options can show some stack traces that do not represent what happens in reality.  The best option is to dig through the source code and use tracing output for guidance but not as full truth."
msgstr "Los mensajes de error apuntan al código del ejemplo, pero puede sorprender que aparezca una referencia a `DnsClient`. ¿A qué se debe esto? La clave está en lo que ocurre dentro de la llamada al método `KeyPairGenerator.initialize()`. Se utiliza `JCAUtil.getSecureRandom()` y por eso es problemático, pero a veces las opciones de trazado pueden mostrar algunas trazas de pila que no representan lo que ocurre en la realidad. La mejor opción es escarbar en el código fuente y utilizar la salida del tracing como orientación, pero no como verdad completa."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1219
#, fuzzy
msgid "Moving the `KEY_PAIR_GEN.initialize(1024);` call to the run-time executed method `encryptDecrypt` is enough to solve this particular issue.  Rebuild the application and verify that encrypt/decrypt endpoint works as expected by sending any message and check if the reply is the same as the incoming message:"
msgstr "Trasladar la llamada a `KEY_PAIR_GEN.initialize(1024);` al método ejecutado en tiempo de ejecución `encryptDecrypt` es suficiente para resolver este problema concreto."

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1228
#, no-wrap
msgid ""
"$ ./mvnw package -DskipTests -Dnative\n"
"...\n"
"$ docker run -i --rm -p 8080:8080 test/debugging-native:1.0.0-SNAPSHOT\n"
"...\n"
"$ curl -w '\\n' http://localhost:8080/encrypt-decrypt/hellomandrel\n"
"hellomandrel\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1231
#, fuzzy
msgid "Additional information on which classes are initialized and why can be obtained by passing in the `-H:+PrintClassInitialization` flag via `-Dquarkus.native.additional-build-args`."
msgstr "Se puede obtener información adicional sobre qué clases se inicializan y por qué pasando la bandera `-H:+PrintClassInitialization` a través de `-Dquarkus.native.additional-build-args`."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:1233
#, fuzzy, no-wrap
msgid "Profile Runtime Behaviour"
msgstr "Perfil Comportamiento en tiempo de ejecución"

#. type: Title ====
#: upstream/_guides/native-reference.adoc:1235
#, fuzzy, no-wrap
msgid "Single Thread"
msgstr "Hilo único"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1239
#, fuzzy
msgid "In this exercise, we profile the runtime behaviour of some Quarkus application that was compiled to a native executable to determine where the bottleneck is.  Assume that you’re in a scenario where profiling the pure Java version is not possible, maybe because the issue only occurs with the native version of the application."
msgstr "En este ejercicio, perfilamos el comportamiento en tiempo de ejecución de alguna aplicación Quarkus que fue compilada a un ejecutable nativo para determinar dónde está el cuello de botella. Supongamos que nos encontramos en un escenario en el que no es posible perfilar la versión Java pura, tal vez porque el problema sólo se produce con la versión nativa de la aplicación."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1242
#, fuzzy
msgid "Add a REST resource with the following code (example courtesy of link:https://github.com/apangin/java-profiling-presentation/blob/master/src/demo1/StringBuilderTest.java[Andrei Pangin's Java Profiling presentation]):"
msgstr "Añade un recurso REST con el siguiente código (ejemplo cortesía de la  link:https://github.com/apangin/java-profiling-presentation/blob/master/src/demo1/StringBuilderTest.java[presentación de Andrei Pangin de Java Profiling]):"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1254
#, no-wrap
msgid ""
"@Path(\"/string-builder\")\n"
"public class StringBuilderResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1260
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String appendDelete() {\n"
"        StringBuilder sb = new StringBuilder();\n"
"        sb.append(new char[1_000_000]);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1266
#, no-wrap
msgid ""
"        do\n"
"        {\n"
"            sb.append(12345);\n"
"            sb.delete(0, 5);\n"
"        } while (Thread.currentThread().isAlive());\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1270
#, no-wrap
msgid ""
"        return \"Never happens\";\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1273
#, fuzzy
msgid "Recompile the application, rebuild the binary and run it. Attempting a simple curl will never complete, as expected:"
msgstr "Recompilar la aplicación, reconstruir el binario y ejecutarlo. El intento de un simple curl nunca se completará, como se esperaba:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1281
#, no-wrap
msgid ""
"$ ./mvnw package -DskipTests -Dnative\n"
"...\n"
"$ docker run -i --rm -p 8080:8080 test/debugging-native:1.0.0-SNAPSHOT\n"
"...\n"
"$ curl http://localhost:8080/string-builder # this will never complete\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1286
#, fuzzy
msgid "However, the question we’re trying to answer here is: what would be the bottleneck of such code? Is it appending the characters? Is it deleting it? Is it checking whether the thread is alive?"
msgstr "Sin embargo, la pregunta que intentamos responder aquí es: ¿cuál sería el cuello de botella de ese código? ¿Es añadir los caracteres? ¿se trata de borrarlos? ¿Se trata de comprobar si el hilo está vivo?"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1291
#, fuzzy
msgid "Since we're dealing with a linux native executable, we can use tools like `perf` directly.  To use `perf`, go to the root of the project and start the tools container created earlier as a privileged user:"
msgstr "Dado que estamos tratando con un ejecutable nativo de linux, podemos utilizar herramientas como `perf` directamente. Para usar `perf`, ve a la raíz del proyecto e inicia el contenedor de herramientas creado anteriormente como usuario privilegiado:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1295
#, no-wrap
msgid "docker run --privileged -t -i --rm -v ${PWD}:/data -p 8080:8080 fedora-tools:v1\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:1302
#, fuzzy
msgid "Note that in order to use `perf` to profile the native executables in the guide, the container needs to run as privileged, or with `--cap-add sys_admin`.  Please note that privileged containers are **NOT** recommended in production, so use this flag with caution!"
msgstr "Tenga en cuenta que para utilizar `perf` para perfilar los ejecutables nativos en la guía, el contenedor necesita ejecutarse como privilegiado, o con `--cap-add sys_admin`. Tenga en cuenta que los contenedores con privilegios *NO* se recomiendan en producción, así que utilice esta bandera con precaución."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1305
#, fuzzy
msgid "Once the container is running, you need to ensure that the kernel is ready for the profiling exercises:"
msgstr "Una vez que el contenedor está en marcha, hay que asegurarse de que el kernel está listo para los ejercicios de perfilado:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1310
#, no-wrap
msgid ""
"echo -1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n"
"echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:1317
#, fuzzy
msgid "The kernel modifications above also apply to Linux virtual machines.  If running on a bare metal Linux machine, tweaking only `perf_event_paranoid` is enough."
msgstr "Las modificaciones del kernel anteriores también se aplican a las máquinas virtuales Linux. Si se ejecuta en una máquina Linux de metal desnudo, es suficiente con ajustar sólo `perf_event_paranoid`."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1320
#, fuzzy
msgid "Then, from inside the tools container we execute:"
msgstr "Luego, desde el interior del contenedor de herramientas ejecutamos:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1324
#: upstream/_guides/native-reference.adoc:2083
#, no-wrap
msgid "perf record -F 1009 -g -a ./target/debugging-native-1.0.0-SNAPSHOT-runner\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:1335
#, fuzzy
msgid "The `perf record` command above takes `1009` samples per second.  Increasing this value means more samples are gathered, which can end up affecting the runtime performance.  This also increases the amount of data generated.  The more data generated, the longer it takes to process it, but the more precision you get on what the application is doing.  So, finding the right value is a balancing act."
msgstr "El comando `perf record` anterior toma `1009` muestras por segundo. Aumentar este valor significa que se recogen más muestras, lo que puede acabar afectando al rendimiento en tiempo de ejecución. Esto también aumenta la cantidad de datos generados. Cuantos más datos se generen, más tiempo se tarda en procesarlos, pero más precisión se obtiene sobre lo que está haciendo la aplicación. Por tanto, encontrar el valor adecuado es un acto de equilibrio."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1338
#, fuzzy
msgid "While `perf record` is running, open another window and access the endpoint:"
msgstr "Mientras se ejecuta `perf record`, abra otra ventana y acceda al punto final:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1342
#, no-wrap
msgid "curl http://localhost:8080/string-builder # this will never complete\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1351
#, fuzzy
msgid "After a few seconds, halt the `perf record` process.  This will generate a `perf.data` file.  We could use `perf report` to inspect the perf data, but you can often get a better picture showing that data as a flame graph.  To generate flame graphs, we will use https://github.com/brendangregg/FlameGraph[FlameGraph GitHub repository], which has already been installed inside the tools container."
msgstr "Después de unos segundos, detenga el proceso `perf record`. Esto generará un archivo `perf.data`. Podríamos utilizar `perf report` para inspeccionar los datos de perfeccionamiento, pero a menudo se puede obtener una mejor imagen mostrando esos datos como un gráfico de llama. Para generar gráficos de llama, utilizaremos el  link:https://github.com/brendangregg/FlameGraph[repositorio GitHub de FlameGraph], que ya ha sido instalado dentro del contenedor de herramientas."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1353
#, fuzzy
msgid "Next, generate a flame graph using the data captured via `perf record`:"
msgstr "A continuación, genere un gráfico de la llama utilizando los datos capturados a través de `perf record`:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1357
#: upstream/_guides/native-reference.adoc:1421
#: upstream/_guides/native-reference.adoc:1528
#, no-wrap
msgid "perf script -i perf.data | ${FG_HOME}/stackcollapse-perf.pl | ${FG_HOME}/flamegraph.pl > flamegraph.svg\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1361
#, fuzzy
msgid "The flame graph is a svg file that a web browser, such as Firefox, can easily display.  After the above two commands complete one can open `flamegraph.svg` in their browser:"
msgstr "El gráfico de la llama es un archivo svg que un navegador web, como Firefox, puede mostrar fácilmente. Una vez completados los dos comandos anteriores se puede abrir `flamegraph.svg` en su navegador:"

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_guides/native-reference.adoc:1362
#, fuzzy, no-wrap
msgid "Perf flamegraph without symbols"
msgstr "Perfeccionar el flamegráfico sin símbolos"

#. type: Target for macro image
#: upstream/_guides/native-reference.adoc:1362
#, no-wrap
msgid "native-reference-perf-flamegraph-no-symbols.svg"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1371
#, fuzzy
msgid "We see a big majority of time spent in what is supposed to be our main, but we see no trace of the `StringBuilderResource` class, nor the `StringBuilder` class we're calling.  We should look at the symbol table of the binary: can we find symbols for our class and `StringBuilder`? We need those in order to get meaningful data.  From within the tools container, query the symbol table:"
msgstr "Vemos una gran mayoría de tiempo en lo que se supone que es nuestro main, pero no vemos ningún rastro de la clase `StringBuilderResource`, ni de la clase `StringBuilder` a la que estamos llamando. Deberíamos mirar la tabla de símbolos del binario: ¿podemos encontrar símbolos para nuestra clase y `StringBuilder`? Los necesitamos para obtener datos significativos. Desde el contenedor de herramientas, consulta la tabla de símbolos:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1376
#, no-wrap
msgid ""
"objdump -t ./target/debugging-native-1.0.0-SNAPSHOT-runner | grep StringBuilder\n"
"[no output]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1382
#, fuzzy
msgid "No output appears when querying the symbol table.  This is why we don't see any call graphs in the flame graphs.  This is a deliberate decision that native-image makes.  By default, it removes symbols from the binary."
msgstr "No aparece ninguna salida al consultar la tabla de símbolos. Por eso no vemos ningún gráfico de llamadas en los gráficos de llamas. Esta es una decisión deliberada que toma native-image. Por defecto, elimina los símbolos del binario."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1386
#, fuzzy
msgid "To regain the symbols, we need to rebuild the binary instructing GraalVM not to delete the symbols.  On top of that, enable DWARF debug info so that the stack traces can be populated with that information.  From outside the tools container, execute:"
msgstr "Para recuperar los símbolos, necesitamos reconstruir el binario indicando a GraalVM que no borre los símbolos. Además, habilitar la información de depuración DWARF para que las trazas de pila puedan ser rellenadas con esa información. Desde fuera del contenedor de herramientas, ejecuta:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1392
#: upstream/_guides/native-reference.adoc:1507
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative \\\n"
"    -Dquarkus.native.debug.enabled \\\n"
"    -Dquarkus.native.additional-build-args=-H:-DeleteLocalSymbols\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1397
#, fuzzy
msgid "Next, re-enter the tools container if you exited, and inspect the native executable with `objdump`, and see how the symbols are now present:"
msgstr "A continuación, vuelva a entrar en el contenedor de herramientas si salió, e inspeccione el ejecutable nativo con `objdump`, y vea cómo los símbolos están ahora presentes:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1404
#, no-wrap
msgid ""
"$ objdump -t ./target/debugging-native-1.0.0-SNAPSHOT-runner | grep StringBuilder\n"
"000000000050a940 l     F .text\t0000000000000091              .hidden ReflectionAccessorHolder_StringBuilderResource_appendDelete_9e06d4817d0208a0cce97ebcc0952534cac45a19_e22addf7d3eaa3ad14013ce01941dc25beba7621\n"
"000000000050a9e0 l     F .text\t00000000000000bb              .hidden ReflectionAccessorHolder_StringBuilderResource_constructor_0f8140ea801718b80c05b979a515d8a67b8f3208_12baae06bcd6a1ef9432189004ae4e4e176dd5a4\n"
"...\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1407
#, fuzzy
msgid "You should see a long list of symbols that match that pattern."
msgstr "Debería ver una larga lista de símbolos que coinciden con ese patrón."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1410
#, fuzzy
msgid "Then, run the executable through perf, *indicating that the call graph is dwarf*:"
msgstr "A continuación, ejecute el ejecutable a través de perf, *indicando que el gráfico de llamadas es enano*:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1414
#: upstream/_guides/native-reference.adoc:1514
#, no-wrap
msgid "perf record -F 1009 --call-graph dwarf -a ./target/debugging-native-1.0.0-SNAPSHOT-runner\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1417
#, fuzzy
msgid "Run the curl command once again, stop the binary, generate the flamegraphs and open it:"
msgstr "Ejecute el comando curl una vez más, detenga el binario, genere el flamegraphs y ábralo:"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1426
#, fuzzy
msgid "The flamegraph now shows where the bottleneck is.  It's when `StringBuilder.delete()` is called which calls `System.arraycopy()`.  The issue is that 1 million characters need to be shifted in very small increments:"
msgstr "El flamegráfico muestra ahora dónde está el cuello de botella. Es cuando se llama a `StringBuilder.delete()` que llama a `System.arraycopy()`. El problema es que hay que desplazar 1 millón de caracteres en incrementos muy pequeños:"

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_guides/native-reference.adoc:1427
#, fuzzy, no-wrap
msgid "Perf flamegraph with symbols"
msgstr "Perfeccionar el flamegráfico con símbolos"

#. type: Target for macro image
#: upstream/_guides/native-reference.adoc:1427
#, no-wrap
msgid "native-reference-perf-flamegraph-symbols.svg"
msgstr ""

#. type: Title ====
#: upstream/_guides/native-reference.adoc:1429
#, fuzzy, no-wrap
msgid "Multi-Thread"
msgstr "Multihilo"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1434
#, fuzzy
msgid "Multithreaded programs might require special attention when trying to understand their runtime behaviour.  To demonstrate this, add this `MulticastResource` code to your project (example courtesy of link:https://github.com/apangin/java-profiling-presentation/blob/master/src/demo6/DatagramTest.java[Andrei Pangin's Java Profiling presentation]):"
msgstr "Los programas multihilo pueden requerir una atención especial a la hora de entender su comportamiento en tiempo de ejecución. Para demostrarlo, añada este código `MulticastResource` a su proyecto (ejemplo cortesía de la  link:https://github.com/apangin/java-profiling-presentation/blob/master/src/demo6/DatagramTest.java[presentación Java Profiling de Andrei Pangin]):"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1450
#, no-wrap
msgid ""
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.Produces;\n"
"import jakarta.ws.rs.core.MediaType;\n"
"import java.net.InetSocketAddress;\n"
"import java.nio.ByteBuffer;\n"
"import java.nio.channels.DatagramChannel;\n"
"import java.util.concurrent.ExecutorService;\n"
"import java.util.concurrent.Executors;\n"
"import java.util.concurrent.ThreadFactory;\n"
"import java.util.concurrent.atomic.AtomicInteger;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1460
#, no-wrap
msgid ""
"@Path(\"/multicast\")\n"
"public class MulticastResource\n"
"{\n"
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String send() throws Exception {\n"
"        sendMulticasts();\n"
"        return \"Multicast packets sent\";\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1465
#, no-wrap
msgid ""
"    static void sendMulticasts() throws Exception {\n"
"        DatagramChannel ch = DatagramChannel.open();\n"
"        ch.bind(new InetSocketAddress(5555));\n"
"        ch.configureBlocking(false);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1473
#, no-wrap
msgid ""
"        ExecutorService pool =\n"
"            Executors.newCachedThreadPool(new ShortNameThreadFactory());\n"
"        for (int i = 0; i < 10; i++) {\n"
"            pool.submit(() -> {\n"
"                final ByteBuffer buf = ByteBuffer.allocateDirect(1000);\n"
"                final InetSocketAddress remoteAddr =\n"
"                    new InetSocketAddress(\"127.0.0.1\", 5556);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1480
#, no-wrap
msgid ""
"                while (true) {\n"
"                    buf.clear();\n"
"                    ch.send(buf, remoteAddr);\n"
"                }\n"
"            });\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1483
#, no-wrap
msgid ""
"        System.out.println(\"Warming up...\");\n"
"        Thread.sleep(3000);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1487
#, no-wrap
msgid ""
"        System.out.println(\"Benchmarking...\");\n"
"        Thread.sleep(5000);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1489
#, no-wrap
msgid "    private static final class ShortNameThreadFactory implements ThreadFactory {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1492
#, no-wrap
msgid ""
"        private final AtomicInteger threadNumber = new AtomicInteger(1);\n"
"        private final String namePrefix = \"thread-\";\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1498
#, no-wrap
msgid ""
"        public Thread newThread(Runnable r) {\n"
"            return new Thread(r, namePrefix + threadNumber.getAndIncrement());\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1501
#, fuzzy
msgid "Build the native executable with debug info:"
msgstr "Construye el ejecutable nativo con información de depuración:"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1510
#, fuzzy
msgid "From inside the tools container (as privileged user) run the native executable through `perf`:"
msgstr "Desde el interior del contenedor de herramientas (como usuario privilegiado) ejecutar el ejecutable nativo a través de `perf`:"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1517
#, fuzzy
msgid "Invoke the endpoint to send the multicast packets:"
msgstr "Invoca el punto final para enviar los paquetes de multidifusión:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1521
#, no-wrap
msgid "curl -w '\\n' http://localhost:8080/multicast\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1524
#, fuzzy
msgid "Make and open a flamegraph:"
msgstr "Hacer y abrir un flamograma:"

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_guides/native-reference.adoc:1530
#, fuzzy, no-wrap
msgid "Muti-thread perf flamegraph with separate threads"
msgstr "Flamegraph mutihilo con hilos separados"

#. type: Target for macro image
#: upstream/_guides/native-reference.adoc:1530
#, no-wrap
msgid "native-reference-multi-flamegraph-separate-threads.svg"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1534
#, fuzzy
msgid "The flamegraph produced looks odd. Each thread is treated independently even though they all do the same work.  This makes it difficult to have a clear picture of the bottlenecks in the program."
msgstr "El flamegráfico producido tiene un aspecto extraño. Cada hilo se trata de forma independiente aunque todos hagan el mismo trabajo. Esto hace difícil tener una imagen clara de los cuellos de botella en el programa."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1537
#, fuzzy
msgid "This is happening because from a `perf` perspective, each thread is a different command.  We can see that if we inspect `perf report`:"
msgstr "Esto sucede porque desde la perspectiva de `perf`, cada hilo es un comando diferente. Podemos ver que si inspeccionamos `perf report`:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1548
#, no-wrap
msgid ""
"perf report --stdio\n"
"# Children      Self  Command          Shared Object       Symbol\n"
"# ........  ........  ...............  ......................................  ......................................................................................\n"
"...\n"
"     6.95%     0.03%  thread-2         debugging-native-1.0.0-SNAPSHOT-runner  [.] MulticastResource_lambda$sendMulticasts$0_cb1f7b5dcaed7dd4e3f90d18bad517d67eae4d88\n"
"...\n"
"     4.60%     0.02%  thread-10        debugging-native-1.0.0-SNAPSHOT-runner  [.] MulticastResource_lambda$sendMulticasts$0_cb1f7b5dcaed7dd4e3f90d18bad517d67eae4d88\n"
"...\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1552
#, fuzzy
msgid "This can be worked around by applying some modifications to the perf output, in order to make all threads have the same name. E.g."
msgstr "Esto se puede solucionar aplicando algunas modificaciones a la salida de perf, para que todos los hilos tengan el mismo nombre. Por ejemplo"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1556
#, no-wrap
msgid "perf script | sed -E \"s/thread-[0-9]*/thread/\" | ${FG_HOME}/stackcollapse-perf.pl | ${FG_HOME}/flamegraph.pl > flamegraph.svg\n"
msgstr ""

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_guides/native-reference.adoc:1558
#, fuzzy, no-wrap
msgid "Muti-thread perf flamegraph with joined threads"
msgstr "Flamegrafía de múltiples hilos con hilos unidos"

#. type: Target for macro image
#: upstream/_guides/native-reference.adoc:1558
#, no-wrap
msgid "native-reference-multi-flamegraph-joined-threads.svg"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1562
#, fuzzy
msgid "When you open the flamegraph, you will see all threads' work collapsed into a single area.  Then, you can clearly see that there's some locking that could affect performance."
msgstr "Cuando abra el flamegraph, verá el trabajo de todos los hilos colapsado en una sola área. Entonces, puedes ver claramente que hay algún bloqueo que podría afectar al rendimiento."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:1564
#, fuzzy, no-wrap
msgid "Debugging Native Crashes"
msgstr "Depuración de fallos nativos"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1571
#, fuzzy
msgid "One of the drawbacks of using native executables is that they cannot be debugged using the standard Java debuggers, instead we need to debug them using `gdb`, the GNU Project debugger.  To demonstrate how to do this, we are going to generate a native Quarkus application that crashes due to a Segmentation Fault when accessing http://localhost:8080/crash.  To achieve this, add the following REST resource to the project:"
msgstr "Uno de los inconvenientes de usar ejecutables nativos es que no pueden ser depurados usando los depuradores estándar de Java, en su lugar necesitamos depurarlos usando `gdb`, el depurador del Proyecto GNU. Para demostrar cómo hacerlo, vamos a generar una aplicación nativa de Quarkus que se bloquea debido a un fallo de segmentación al acceder a  http://localhost:8080/crash  Para conseguirlo, añade el siguiente recurso REST al proyecto:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1577
#, no-wrap
msgid "import sun.misc.Unsafe;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1583
#, no-wrap
msgid ""
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.Produces;\n"
"import jakarta.ws.rs.core.MediaType;\n"
"import java.lang.reflect.Field;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1586
#, no-wrap
msgid ""
"@Path(\"/crash\")\n"
"public class CrashResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1602
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        Field theUnsafe = null;\n"
"        try {\n"
"            theUnsafe = Unsafe.class.getDeclaredField(\"theUnsafe\");\n"
"            theUnsafe.setAccessible(true);\n"
"            Unsafe unsafe = (Unsafe) theUnsafe.get(null);\n"
"            unsafe.copyMemory(0, 128, 256);\n"
"        } catch (NoSuchFieldException | IllegalAccessException e) {\n"
"            e.printStackTrace();\n"
"        }\n"
"        return \"Never happens\";\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1606
#, fuzzy
msgid "This code will try to copy 256 bytes from address `0x0` to `0x80` resulting in a Segmentation Fault.  To verify this, compile and run the example application:"
msgstr "Este código intentará copiar 256 bytes de la dirección `0x0` a `0x80`, lo que provocará un fallo de segmentación. Para verificar esto compila y ejecuta la aplicación de ejemplo:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1614
#, no-wrap
msgid ""
"$ ./mvnw package -DskipTests -Dnative\n"
"...\n"
"$ docker run -i --rm -p 8080:8080 test/debugging-native:1.0.0-SNAPSHOT\n"
"...\n"
"$ curl http://localhost:8080/crash\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1617
#, fuzzy
msgid "This will result in the following output:"
msgstr "Esto dará como resultado la siguiente salida:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1624
#, no-wrap
msgid ""
"$ docker run -i --rm -p 8080:8080 test/debugging-native:1.0.0-SNAPSHOT\n"
"...\n"
"Segfault detected, aborting process. Use runtime option -R:-InstallSegfaultHandler if you don't want to use SubstrateSegfaultHandler.\n"
"...\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1630
#, fuzzy
msgid "The omitted output above contains clues to what caused the issue, but in this exercise we are going to assume that no information was provided.  Let’s try to debug the segmentation fault using `gdb`.  To do that, go to the root of the project and enter the tools container:"
msgstr "La salida omitida arriba contiene pistas sobre la causa del problema, pero en este ejercicio vamos a asumir que no se proporcionó ninguna información. Vamos a intentar depurar el fallo de segmentación utilizando `gdb`. Para ello, ve a la raíz del proyecto y entra en el contenedor de herramientas:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1634
#, no-wrap
msgid "docker run -t -i --rm -v ${PWD}:/data -p 8080:8080 fedora-tools:v1 /bin/bash\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1637
#, fuzzy
msgid "Then start the application in `gdb` and execute `run`."
msgstr "A continuación, inicie la aplicación en `gdb` y ejecute `run`."

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1646
#, no-wrap
msgid ""
"gdb ./target/debugging-native-1.0.0-SNAPSHOT-runner\n"
"...\n"
"Reading symbols from ./target/debugging-native-1.0.0-SNAPSHOT-runner...\n"
"(No debugging symbols found in ./target/debugging-ntaive-1.0.0-SNAPSHOT-runner)\n"
"(gdb) run\n"
"Starting program: /data/target/debugging-native-1.0.0-SNAPSHOT-runner\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1649
#, fuzzy
msgid "Next, try to access http://localhost:8080/crash:"
msgstr "A continuación, intente acceder a  http://localhost:8080/crash"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1652
#, no-wrap
msgid "curl http://localhost:8080/crash\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1655
#: upstream/_guides/native-reference.adoc:1699
#, fuzzy
msgid "This will result in the following message in `gdb`:"
msgstr "Esto dará como resultado el siguiente mensaje en `gdb`:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1661
#, no-wrap
msgid ""
"Thread 4 \"ecutor-thread-0\" received signal SIGSEGV, Segmentation fault.\n"
"[Switching to Thread 0x7fe103dff640 (LWP 190)]\n"
"0x0000000000461f6e in ?? ()\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1664
#, fuzzy
msgid "If we try to get more info about the backtrace that led to this crash we will see that there is not enough information available."
msgstr "Si intentamos obtener más información sobre el backtrace que ha llevado a esta caída veremos que no hay suficiente información disponible."

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1675
#, no-wrap
msgid ""
"(gdb) bt\n"
"#0  0x0000000000418b5e in ?? ()\n"
"#1  0x00007ffff6f2d328 in ?? ()\n"
"#2  0x0000000000418a04 in ?? ()\n"
"#3  0x00007ffff44062a0 in ?? ()\n"
"#4  0x00000000010c3dd3 in ?? ()\n"
"#5  0x0000000000000100 in ?? ()\n"
"#6  0x0000000000000000 in ?? ()\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1680
#, fuzzy
msgid "This is because we didn’t compile the Quarkus application with `-Dquarkus.native.debug.enabled`, so `gdb` cannot find debugging symbols for our native executable, as indicated by the \"_No debugging symbols found in ./target/debugging-native-1.0.0-SNAPSHOT-runner_\" message in the beginning of `gdb`."
msgstr "Esto se debe a que no hemos compilado la aplicación Quarkus con `-Dquarkus.native.debug.enabled`, por lo que `gdb` no puede encontrar símbolos de depuración para nuestro ejecutable nativo, como indica el mensaje _\"No debugging symbols found in ./target/debugging-native-1.0.0-SNAPSHOT-runner_\" al principio de `gdb`."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1683
#, fuzzy
msgid "Recompiling the Quarkus application with `-Dquarkus.native.debug.enabled` and rerunning it through `gdb` we are now able to get a backtrace making clear what caused the crash.  On top of that, add `-H:-OmitInlinedMethodDebugLineInfo` option to avoid inlined methods being omitted from the backtrace:"
msgstr "Recompilando la aplicación Quarkus con `-Dquarkus.native.debug.enabled` y volviéndola a ejecutar a través de `gdb` ahora podemos obtener un backtrace que aclare la causa del fallo. Además, añade la opción `-H:-OmitInlinedMethodDebugLineInfo` para evitar que los métodos inline sean omitidos del backtrace:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1696
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative \\\n"
"    -Dquarkus.native.debug.enabled \\\n"
"    -Dquarkus.native.additional-build-args=-H:-OmitInlinedMethodDebugLineInfo\n"
"...\n"
"$ gdb ./target/debugging-native-1.0.0-SNAPSHOT-runner\n"
"Reading symbols from ./target/debugging-native-1.0.0-SNAPSHOT-runner...\n"
"(gdb) run\n"
"Starting program: /data/target/debugging-native-1.0.0-SNAPSHOT-runner\n"
"...\n"
"$ curl http://localhost:8080/crash\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1707
#, no-wrap
msgid ""
"Thread 4 \"ecutor-thread-0\" received signal SIGSEGV, Segmentation fault.\n"
"[Switching to Thread 0x7fffeffff640 (LWP 362984)]\n"
"com.oracle.svm.core.UnmanagedMemoryUtil::copyLongsBackward(org.graalvm.word.Pointer *, org.graalvm.word.Pointer *, org.graalvm.word.UnsignedWord *) ()\n"
"\tat com/oracle/svm/core/UnmanagedMemoryUtil.java:169\n"
"169    com/oracle/svm/core/UnmanagedMemoryUtil.java: No such file or directory.\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1711
#, fuzzy
msgid "We already see that `gdb` is able to tell us which method caused the crash and where it’s located in the source code.  We can also get a backtrace of the call graph that led us to this state:"
msgstr "Ya vemos que `gdb` es capaz de decirnos qué método ha causado el fallo y en qué parte del código fuente se encuentra. También podemos obtener un backtrace del gráfico de llamadas que nos ha llevado a este estado:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1724
#, no-wrap
msgid ""
"(gdb) bt\n"
"#0  com.oracle.svm.core.UnmanagedMemoryUtil::copyLongsBackward(org.graalvm.word.Pointer *, org.graalvm.word.Pointer *, org.graalvm.word.UnsignedWord *) () at com/oracle/svm/core/UnmanagedMemoryUtil.java:169\n"
"#1  0x0000000000461e14 in com.oracle.svm.core.UnmanagedMemoryUtil::copyBackward(org.graalvm.word.Pointer *, org.graalvm.word.Pointer *, org.graalvm.word.UnsignedWord *) () at com/oracle/svm/core/UnmanagedMemoryUtil.java:110\n"
"#2  0x0000000000461dc8 in com.oracle.svm.core.UnmanagedMemoryUtil::copy(org.graalvm.word.Pointer *, org.graalvm.word.Pointer *, org.graalvm.word.UnsignedWord *) () at com/oracle/svm/core/UnmanagedMemoryUtil.java:67\n"
"#3  0x000000000045d3c0 in com.oracle.svm.core.JavaMemoryUtil::unsafeCopyMemory(java.lang.Object *, long, java.lang.Object *, long, long) () at com/oracle/svm/core/JavaMemoryUtil.java:276\n"
"#4  0x00000000013277de in jdk.internal.misc.Unsafe::copyMemory0 () at com/oracle/svm/core/jdk/SunMiscSubstitutions.java:125\n"
"#5  jdk.internal.misc.Unsafe::copyMemory(java.lang.Object *, long, java.lang.Object *, long, long) () at jdk/internal/misc/Unsafe.java:788\n"
"#6  0x00000000013b1a3f in jdk.internal.misc.Unsafe::copyMemory () at jdk/internal/misc/Unsafe.java:799\n"
"#7  sun.misc.Unsafe::copyMemory () at sun/misc/Unsafe.java:585\n"
"#8  org.acme.CrashResource::hello(void) () at org/acme/CrashResource.java:22\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1727
#, fuzzy
msgid "Similarly, we can get a backtrace of the call graph of other threads."
msgstr "Del mismo modo, podemos obtener un backtrace del gráfico de llamadas de otros hilos."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1729
#, fuzzy
msgid "First, we can list the available threads with:"
msgstr "En primer lugar, podemos enumerar los hilos disponibles con:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1740
#, no-wrap
msgid ""
"(gdb) info threads\n"
"  Id   Target Id                                             Frame\n"
"  1    Thread 0x7fcc62a07d00 (LWP 322) \"debugging-nativ\" 0x00007fcc62b8b77a in __futex_abstimed_wait_common () from /lib64/libc.so.6\n"
"  2    Thread 0x7fcc60eff640 (LWP 326) \"gnal Dispatcher\" 0x00007fcc62b8b77a in __futex_abstimed_wait_common () from /lib64/libc.so.6\n"
"* 4    Thread 0x7fcc5b7fe640 (LWP 328) \"ecutor-thread-0\" com.oracle.svm.core.UnmanagedMemoryUtil::copyLongsBackward(org.graalvm.word.Pointer *, org.graalvm.word.Pointer *, org.graalvm.word.UnsignedWord *) () at com/oracle/svm/core/UnmanagedMemoryUtil.java:169\n"
"  5    Thread 0x7fcc5abff640 (LWP 329) \"-thread-checker\" 0x00007fcc62b8b77a in __futex_abstimed_wait_common () from /lib64/libc.so.6\n"
"  6    Thread 0x7fcc59dff640 (LWP 330) \"ntloop-thread-0\" 0x00007fcc62c12c9e in epoll_wait () from /lib64/libc.so.6\n"
"...\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1743
#, fuzzy
msgid "select the thread we want to inspect, e.g. thread 1:"
msgstr "seleccionar el hilo que queremos inspeccionar, por ejemplo, el hilo 1:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1750
#, no-wrap
msgid ""
"(gdb) thread 1\n"
"[Switching to thread 1 (Thread 0x7ffff7a58d00 (LWP 1028851))]\n"
"#0  __futex_abstimed_wait_common64 (private=0, cancel=true, abstime=0x0, op=393, expected=0, futex_word=0x2cd7adc) at futex-internal.c:57\n"
"57\t    return INTERNAL_SYSCALL_CANCEL (futex_time64, futex_word, op, expected,\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1753
#, fuzzy
msgid "and, finally, print the stack trace:"
msgstr "y, por último, imprimir el seguimiento de la pila:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1781
#, no-wrap
msgid ""
"(gdb) bt\n"
"#0  __futex_abstimed_wait_common64 (private=0, cancel=true, abstime=0x0, op=393, expected=0, futex_word=0x2cd7adc) at futex-internal.c:57\n"
"#1  __futex_abstimed_wait_common (futex_word=futex_word@entry=0x2cd7adc, expected=expected@entry=0, clockid=clockid@entry=0, abstime=abstime@entry=0x0, private=private@entry=0,\n"
"    cancel=cancel@entry=true) at futex-internal.c:87\n"
"#2  0x00007ffff7bdd79f in __GI___futex_abstimed_wait_cancelable64 (futex_word=futex_word@entry=0x2cd7adc, expected=expected@entry=0, clockid=clockid@entry=0, abstime=abstime@entry=0x0,\n"
"    private=private@entry=0) at futex-internal.c:139\n"
"#3  0x00007ffff7bdfeb0 in __pthread_cond_wait_common (abstime=0x0, clockid=0, mutex=0x2ca07b0, cond=0x2cd7ab0) at pthread_cond_wait.c:504\n"
"#4  ___pthread_cond_wait (cond=0x2cd7ab0, mutex=0x2ca07b0) at pthread_cond_wait.c:619\n"
"#5  0x00000000004e2014 in com.oracle.svm.core.posix.headers.Pthread::pthread_cond_wait () at com/oracle/svm/core/posix/thread/PosixJavaThreads.java:252\n"
"#6  com.oracle.svm.core.posix.thread.PosixParkEvent::condWait(void) () at com/oracle/svm/core/posix/thread/PosixJavaThreads.java:252\n"
"#7  0x0000000000547070 in com.oracle.svm.core.thread.JavaThreads::park(void) () at com/oracle/svm/core/thread/JavaThreads.java:764\n"
"#8  0x0000000000fc5f44 in jdk.internal.misc.Unsafe::park(boolean, long) () at com/oracle/svm/core/thread/Target_jdk_internal_misc_Unsafe_JavaThreads.java:49\n"
"#9  0x0000000000eac1ad in java.util.concurrent.locks.LockSupport::park(java.lang.Object *) () at java/util/concurrent/locks/LockSupport.java:194\n"
"#10 0x0000000000ea5d68 in java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject::awaitUninterruptibly(void) ()\n"
"    at java/util/concurrent/locks/AbstractQueuedSynchronizer.java:2018\n"
"#11 0x00000000008b6b30 in io.quarkus.runtime.ApplicationLifecycleManager::run(io.quarkus.runtime.Application *, java.lang.Class *, java.util.function.BiConsumer *, java.lang.String[] *) ()\n"
"    at io/quarkus/runtime/ApplicationLifecycleManager.java:144\n"
"#12 0x00000000008bc055 in io.quarkus.runtime.Quarkus::run(java.lang.Class *, java.util.function.BiConsumer *, java.lang.String[] *) () at io/quarkus/runtime/Quarkus.java:67\n"
"#13 0x000000000045c88b in io.quarkus.runtime.Quarkus::run () at io/quarkus/runtime/Quarkus.java:41\n"
"#14 io.quarkus.runtime.Quarkus::run () at io/quarkus/runtime/Quarkus.java:120\n"
"#15 0x000000000045c88b in io.quarkus.runner.GeneratedMain::main ()\n"
"#16 com.oracle.svm.core.JavaMainWrapper::runCore () at com/oracle/svm/core/JavaMainWrapper.java:150\n"
"#17 com.oracle.svm.core.JavaMainWrapper::run(int, org.graalvm.nativeimage.c.type.CCharPointerPointer *) () at com/oracle/svm/core/JavaMainWrapper.java:186\n"
"#18 0x000000000048084d in com.oracle.svm.core.code.IsolateEnterStub::JavaMainWrapper_run_5087f5482cc9a6abc971913ece43acb471d2631b(int, org.graalvm.nativeimage.c.type.CCharPointerPointer *)\n"
"    () at com/oracle/svm/core/JavaMainWrapper.java:280\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1784
#, fuzzy
msgid "Alternatively, we can list the backtraces of all threads with a single command:"
msgstr "Alternativamente, podemos listar los backtraces de todos los hilos con un solo comando:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1788
#, no-wrap
msgid "(gdb) thread apply all backtrace\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1808
#, no-wrap
msgid ""
"Thread 22 (Thread 0x7fffc8dff640 (LWP 1028872) \"tloop-thread-15\"):\n"
"#0  0x00007ffff7c64c2e in epoll_wait (epfd=8, events=0x2ca3880, maxevents=1024, timeout=-1) at ../sysdeps/unix/sysv/linux/epoll_wait.c:30\n"
"#1  0x000000000166e01c in Java_sun_nio_ch_EPoll_wait ()\n"
"#2  0x00000000011bfece in sun.nio.ch.EPoll::wait(int, long, int, int) () at com/oracle/svm/core/stack/JavaFrameAnchors.java:42\n"
"#3  0x00000000011c08d2 in sun.nio.ch.EPollSelectorImpl::doSelect(java.util.function.Consumer *, long) () at sun/nio/ch/EPollSelectorImpl.java:120\n"
"#4  0x00000000011d8977 in sun.nio.ch.SelectorImpl::lockAndDoSelect(java.util.function.Consumer *, long) () at sun/nio/ch/SelectorImpl.java:124\n"
"#5  0x0000000000705720 in sun.nio.ch.SelectorImpl::select () at sun/nio/ch/SelectorImpl.java:141\n"
"#6  io.netty.channel.nio.SelectedSelectionKeySetSelector::select(void) () at io/netty/channel/nio/SelectedSelectionKeySetSelector.java:68\n"
"#7  0x0000000000703c2e in io.netty.channel.nio.NioEventLoop::select(long) () at io/netty/channel/nio/NioEventLoop.java:813\n"
"#8  0x0000000000701a5f in io.netty.channel.nio.NioEventLoop::run(void) () at io/netty/channel/nio/NioEventLoop.java:460\n"
"#9  0x00000000008496df in io.netty.util.concurrent.SingleThreadEventExecutor$4::run(void) () at io/netty/util/concurrent/SingleThreadEventExecutor.java:986\n"
"#10 0x0000000000860762 in io.netty.util.internal.ThreadExecutorMap$2::run(void) () at io/netty/util/internal/ThreadExecutorMap.java:74\n"
"#11 0x0000000000840da4 in io.netty.util.concurrent.FastThreadLocalRunnable::run(void) () at io/netty/util/concurrent/FastThreadLocalRunnable.java:30\n"
"#12 0x0000000000b7dd04 in java.lang.Thread::run(void) () at java/lang/Thread.java:829\n"
"#13 0x0000000000547dcc in com.oracle.svm.core.thread.JavaThreads::threadStartRoutine(org.graalvm.nativeimage.ObjectHandle *) () at com/oracle/svm/core/thread/JavaThreads.java:597\n"
"#14 0x00000000004e15b1 in com.oracle.svm.core.posix.thread.PosixJavaThreads::pthreadStartRoutine(com.oracle.svm.core.thread.JavaThreads$ThreadStartData *) () at com/oracle/svm/core/posix/thread/PosixJavaThreads.java:194\n"
"#15 0x0000000000480984 in com.oracle.svm.core.code.IsolateEnterStub::PosixJavaThreads_pthreadStartRoutine_e1f4a8c0039f8337338252cd8734f63a79b5e3df(com.oracle.svm.core.thread.JavaThreads$ThreadStartData *) () at com/oracle/svm/core/posix/thread/PosixJavaThreads.java:182\n"
"#16 0x00007ffff7be0b1a in start_thread (arg=<optimized out>) at pthread_create.c:443\n"
"#17 0x00007ffff7c65650 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1828
#, no-wrap
msgid ""
"Thread 21 (Thread 0x7fffc97fa640 (LWP 1028871) \"tloop-thread-14\"):\n"
"#0  0x00007ffff7c64c2e in epoll_wait (epfd=53, events=0x2cd0970, maxevents=1024, timeout=-1) at ../sysdeps/unix/sysv/linux/epoll_wait.c:30\n"
"#1  0x000000000166e01c in Java_sun_nio_ch_EPoll_wait ()\n"
"#2  0x00000000011bfece in sun.nio.ch.EPoll::wait(int, long, int, int) () at com/oracle/svm/core/stack/JavaFrameAnchors.java:42\n"
"#3  0x00000000011c08d2 in sun.nio.ch.EPollSelectorImpl::doSelect(java.util.function.Consumer *, long) () at sun/nio/ch/EPollSelectorImpl.java:120\n"
"#4  0x00000000011d8977 in sun.nio.ch.SelectorImpl::lockAndDoSelect(java.util.function.Consumer *, long) () at sun/nio/ch/SelectorImpl.java:124\n"
"#5  0x0000000000705720 in sun.nio.ch.SelectorImpl::select () at sun/nio/ch/SelectorImpl.java:141\n"
"#6  io.netty.channel.nio.SelectedSelectionKeySetSelector::select(void) () at io/netty/channel/nio/SelectedSelectionKeySetSelector.java:68\n"
"#7  0x0000000000703c2e in io.netty.channel.nio.NioEventLoop::select(long) () at io/netty/channel/nio/NioEventLoop.java:813\n"
"#8  0x0000000000701a5f in io.netty.channel.nio.NioEventLoop::run(void) () at io/netty/channel/nio/NioEventLoop.java:460\n"
"#9  0x00000000008496df in io.netty.util.concurrent.SingleThreadEventExecutor$4::run(void) () at io/netty/util/concurrent/SingleThreadEventExecutor.java:986\n"
"#10 0x0000000000860762 in io.netty.util.internal.ThreadExecutorMap$2::run(void) () at io/netty/util/internal/ThreadExecutorMap.java:74\n"
"#11 0x0000000000840da4 in io.netty.util.concurrent.FastThreadLocalRunnable::run(void) () at io/netty/util/concurrent/FastThreadLocalRunnable.java:30\n"
"#12 0x0000000000b7dd04 in java.lang.Thread::run(void) () at java/lang/Thread.java:829\n"
"#13 0x0000000000547dcc in com.oracle.svm.core.thread.JavaThreads::threadStartRoutine(org.graalvm.nativeimage.ObjectHandle *) () at com/oracle/svm/core/thread/JavaThreads.java:597\n"
"#14 0x00000000004e15b1 in com.oracle.svm.core.posix.thread.PosixJavaThreads::pthreadStartRoutine(com.oracle.svm.core.thread.JavaThreads$ThreadStartData *) () at com/oracle/svm/core/posix/thread/PosixJavaThreads.java:194\n"
"#15 0x0000000000480984 in com.oracle.svm.core.code.IsolateEnterStub::PosixJavaThreads_pthreadStartRoutine_e1f4a8c0039f8337338252cd8734f63a79b5e3df(com.oracle.svm.core.thread.JavaThreads$ThreadStartData *) () at com/oracle/svm/core/posix/thread/PosixJavaThreads.java:182\n"
"#16 0x00007ffff7be0b1a in start_thread (arg=<optimized out>) at pthread_create.c:443\n"
"#17 0x00007ffff7c65650 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1831
#, no-wrap
msgid ""
"Thread 20 (Thread 0x7fffc9ffb640 (LWP 1028870) \"tloop-thread-13\"):\n"
"...\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1834
#, fuzzy
msgid "Note, however, that despite being able to get a backtrace we can still not list the source code at point with the `list` command."
msgstr "Tenga en cuenta, sin embargo, que a pesar de ser capaz de obtener un backtrace todavía no podemos listar el código fuente en el punto con el comando `list`."

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1839
#, no-wrap
msgid ""
"(gdb) list\n"
"164    in com/oracle/svm/core/UnmanagedMemoryUtil.java\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1845
#, fuzzy
msgid "This is because `gdb` is not aware of the location of the source files.  We are running the executable outside the target directory.  To fix this we can either rerun `gdb` from the target directory or, run `directory target/debugging-native-1.0.0-SNAPSHOT-native-image-source-jar/sources` e.g.:"
msgstr "Esto se debe a que `gdb` no conoce la ubicación de los archivos fuente. Estamos ejecutando el ejecutable fuera del directorio de destino. Para solucionar esto podemos volver a ejecutar `gdb` desde el directorio de destino o, ejecutar `directory target/debugging-native-1.0.0-SNAPSHOT-native-image-source-jar/sources` por ejemplo:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1861
#, no-wrap
msgid ""
"(gdb) directory target/debugging-native-1.0.0-SNAPSHOT-native-image-source-jar/sources\n"
"Source directories searched: /data/target/debugging-native-1.0.0-SNAPSHOT-native-image-source-jar/sources:$cdir:$cwd\n"
"(gdb) list\n"
"164        \tUnsignedWord offset = size;\n"
"165        \twhile (offset.aboveOrEqual(32)) {\n"
"166            \toffset = offset.subtract(32);\n"
"167            \tPointer src = from.add(offset);\n"
"168            \tPointer dst = to.add(offset);\n"
"169            \tlong l24 = src.readLong(24);\n"
"170            \tlong l16 = src.readLong(16);\n"
"171            \tlong l8 = src.readLong(8);\n"
"172            \tlong l0 = src.readLong(0);\n"
"173            \tdst.writeLong(24, l24);\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1868
#, fuzzy
msgid "We can now examine line `169` and get a first hint of what might be wrong (in this case we see that it fails at the first read from src which contains the address `0x0000`), or walk up the stack using `gdb`’s `up` command to see what part of our code led to this situation.  For more information about using `gdb` to debug native executables, see the link:https://www.graalvm.org/{graalvm-docs-version}/reference-manual/native-image/debugging-and-diagnostics/DebugInfo/[GraalVM Debug Info Feature] guide."
msgstr "Ahora podemos examinar la línea `169` y obtener un primer indicio de lo que podría estar mal (en este caso vemos que falla en la primera lectura de src que contiene la dirección `0x0000`), o recorrer la pila usando el comando `gdb`'s `up` para ver qué parte de nuestro código condujo a esta situación. Para aprender más sobre el uso de gdb para depurar ejecutables nativos vea  link:https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/DebugInfo.md[aquí]."

#. type: Title ==
#: upstream/_guides/native-reference.adoc:1870
#, fuzzy, no-wrap
msgid "Frequently Asked Questions"
msgstr "Preguntas frecuentes"

#. type: Title ===
#: upstream/_guides/native-reference.adoc:1872
#, fuzzy, no-wrap
msgid "Why is the process of generating a native executable slow?"
msgstr "¿Por qué es lento el proceso de generación de un ejecutable nativo?"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1876
#, fuzzy
msgid "Native executable generation is a multi-step process.  The analysis and compile steps are the most expensive of all and hence the ones that dominate the time spent generating the native executable."
msgstr "La generación de un ejecutable nativo es un proceso de varios pasos. Los pasos de análisis y compilación son los más costosos de todos y, por tanto, los que dominan el tiempo de generación del ejecutable nativo."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1882
#, fuzzy
msgid "In the analysis phase, a static points-to analysis starts from the main method of the program to find out what is reachable.  As new classes are discovered, some of them will be initialized during this process depending on the configuration.  In the next step, the heap is snapshotted and checks are made to see which types need to be available at runtime.  The initialization and heap snapshotting can cause new types to be discovered, in which case the process is repeated.  The process stops when a fixed point is reached, that is when the reachable program grows no more."
msgstr "En la fase de análisis, un análisis estático de puntos comienza desde el método principal del programa para averiguar qué es alcanzable. A medida que se descubren nuevas clases, algunas de ellas se inicializarán durante este proceso dependiendo de la configuración. En el siguiente paso, se hace un snapshot del heap y se comprueba qué clases deben estar disponibles en tiempo de ejecución. La inicialización y el snapshotting del heap pueden hacer que se descubran nuevos tipos, en cuyo caso se repite el proceso. El proceso se detiene cuando se alcanza un punto fijo, es decir, cuando el programa alcanzable no crece más."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1884
#, fuzzy
msgid "The compilation step is pretty straightforward, it simply compiles all the reachable code."
msgstr "El paso de compilación es bastante sencillo, simplemente compila todo el código alcanzable."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1891
#, fuzzy
msgid "The time spent in analysis and compilation phases depends on how big the application is.  The bigger the application, the longer it takes to compile it.  However, there are certain features that can have an exponential effect.  For example, when registering types and methods for reflection access, the analysis can’t easily see what’s behind those types or methods, so it has to do more work to complete the analysis step."
msgstr "El tiempo empleado en las fases de análisis y compilación depende del tamaño de la aplicación. Cuanto más grande sea la aplicación, más tiempo se tarda en compilarla. Sin embargo, hay ciertas características que pueden tener un efecto exponencial. Por ejemplo, cuando se registran tipos y métodos para el acceso por reflexión, el análisis no puede ver fácilmente lo que hay detrás de esos tipos o métodos, por lo que tiene que hacer más trabajo para completar el paso de análisis."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:1893
#, no-wrap
msgid "I get a warning about using experimental options, what can I do?"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1896
msgid "Starting with Mandrel 23.1 and GraalVM for JDK 21, the native executable generation process will warn about the use of experimental options with a message like this:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1900
#, no-wrap
msgid "Warning: The option '-H:ReflectionConfigurationResources=META-INF/native-image/io.micrometer/micrometer-core/reflect-config.json' is experimental and must be enabled via '-H:+UnlockExperimentalVMOptions' in the future.\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1904
msgid "If the mentioned option is added by a third party library like in the example above, you should consider opening an issue in the library's repository to ask for the option to be removed.  If the option is added by your application, you should consider either removing it (if it's not necessary) or wrapping it between `-H:+UnlockExperimentalVMOptions` and `-H:-UnlockExperimentalVMOptions`."
msgstr ""

#. type: Title ===
#: upstream/_guides/native-reference.adoc:1905
#, fuzzy, no-wrap
msgid "I get a `AnalysisError\\$ParsingError` when building a native executable due to an `UnresolvedElementException`, what can I do?"
msgstr "Me sale un `OutOfMemoryError` (OOME) construyendo ejecutables nativos, ¿qué puedo hacer?"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1910
#, fuzzy
msgid "When building a native executable Quarkus requires all classes being referenced by the code, no matter if they are build-time or run-time initialized, to be present in the classpath.  This way it ensures that there will be no crashes at runtime due to potential `NoClassDefFoundError` exceptions.  To achieve this it makes use of GraalVM's `--link-at-build-time` parameter:"
msgstr "Cuando se construye un ejecutable nativo Quarkus requiere que todas las clases referenciadas por el código, sin importar si son inicializadas en tiempo de construcción o en tiempo de ejecución, estén presentes en el classpath. De esta manera se asegura de que no habrá fallos en tiempo de ejecución debido a posibles excepciones `NoClassDefFoundError`. Para lograr esto se hace uso del parámetro `--link-at-build-time` de GraalVM:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1916
#, no-wrap
msgid ""
"--link-at-build-time  require types to be fully defined at image build-time. If used\n"
"                      without args, all classes in scope of the option are required to\n"
"                      be fully defined.\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1920
#, fuzzy
msgid "This, however, may result in an `AnalysisError\\$ParsingError` due to an `UnresolvedElementException` at build time.  This is often caused because the application references a class from an https://maven.apache.org/guides/introduction/introduction-to-optional-and-excludes-dependencies.html#optional-dependencies[optional dependency]."
msgstr "Esto, sin embargo, puede resultar en un `AnalysisError\\$ParsingError` debido a un `UnresolvedElementException` en tiempo de compilación. Esto suele deberse a que la aplicación hace referencia a una clase de una  link:https://maven.apache.org/guides/introduction/introduction-to-optional-and-excludes-dependencies.html#optional-dependencies[dependencia opcional]."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1922
#, fuzzy
msgid "If you have access to the source code responsible for the reference to the missing dependency and can alter it, you should consider one of the following:"
msgstr "Si tiene acceso al código fuente responsable de la referencia a la dependencia que falta y puede modificarlo, debería considerar una de las siguientes opciones:"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1924
#, fuzzy
msgid "Remove the reference if it's not actually necessary."
msgstr "Elimine la referencia si no es realmente necesaria."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1925
#, fuzzy
msgid "Move the affected code in a sub-module and make the dependency non-optional (as is the best practice)."
msgstr "Mueva el código afectado en un submódulo y haga que la dependencia no sea opcional (como es la mejor práctica)."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1926
#, fuzzy
msgid "Make the dependency non-optional."
msgstr "Hacer que la dependencia no sea opcional."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1928
#, fuzzy
msgid "In the unfortunate case where the reference causing the issue is made by a 3rd party library, that you cannot modify, you should consider one of the following:"
msgstr "En el desafortunado caso de que la referencia que causa el problema esté hecha por una biblioteca de terceros, que usted no puede modificar, debería considerar una de las siguientes opciones:"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1930
#, fuzzy
msgid "Use a class/method substitution to remove the said reference."
msgstr "Utilice una sustitución de clase/método para eliminar dicha referencia."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1931
#, fuzzy
msgid "Add the optional dependency as a non-optional dependency of your project."
msgstr "Añada la dependencia opcional como dependencia no opcional de su proyecto."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1935
#, fuzzy
msgid "Note that although option (1) is the best choice performance wise, as it minimizes the applications footprint,it might not be trivial to implement.  To make matters worse, it's also not easy to maintain as it is tightly coupled to the 3rd party library implementation.  Option (2) is a straight forward alternative to work around the issue, but comes at the cost of including possibly never invoked code in the resulting native executable."
msgstr "Tenga en cuenta que aunque la opción (1) es la mejor opción en cuanto a rendimiento, ya que minimiza la huella de las aplicaciones, puede que no sea trivial de implementar. Para empeorar las cosas, tampoco es fácil de mantener, ya que está estrechamente vinculada a la implementación de la biblioteca de terceros. La opción (2) es una alternativa directa para solucionar el problema, pero tiene el coste de incluir código que posiblemente nunca se invoque en el ejecutable nativo resultante."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:1936
#, fuzzy, no-wrap
msgid "I get an `OutOfMemoryError` (OOME) building native executables, what can I do?"
msgstr "Me sale un `OutOfMemoryError` (OOME) construyendo ejecutables nativos, ¿qué puedo hacer?"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1948
#, fuzzy
msgid "Building native executables is not only time consuming, but it also takes a fair amount of memory.  For example, building a sample native Quarkus Jakarta Persistence application such as the Hibernate ORM quickstart, may use 6GB to 8GB resident set size in memory.  A big chunk of this memory is Java heap, but extra memory is required for other aspects of the JVM that runs the native building process.  It is still possible to build such applications in environments that have total memory close to the limits, but to do that it is necessary to shrink the maximum heap size of the GraalVM native image process.  To do that, set a maximum heap size using the `quarkus.native.native-image-xmx` property.  For example, we can instruct GraalVM to use 5GB of maximum heap size by passing in `-Dquarkus.native.native-image-xmx=5g` in the command line."
msgstr "La construcción de ejecutables nativos no sólo consume tiempo, sino que también requiere una buena cantidad de memoria. Por ejemplo, la construcción de un ejemplo de aplicación nativa JPA de Quarkus, como el inicio rápido de Hibernate, puede utilizar de 6GB a 8GB de tamaño de conjunto residente en memoria. Una gran parte de esta memoria es el heap de Java, pero se requiere memoria extra para otros aspectos de la JVM que ejecuta el proceso de construcción nativo. Todavía es posible construir este tipo de aplicaciones en entornos que tienen una memoria total cercana a los límites, pero para ello es necesario reducir el tamaño máximo del heap del proceso de imagen nativa de GraalVM. Para ello, hay que establecer un tamaño máximo de heap mediante la propiedad `quarkus.native.native-image-xmx`. Por ejemplo, podemos instruir a GraalVM para que utilice 5GB de tamaño máximo de heap pasando `-Dquarkus.native.native-image-xmx=5g` en la línea de comandos."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1951
#, fuzzy
msgid "Building native executables this way might have the side effect of requiring more time to complete.  This is due to garbage collection having to work harder for native image generation to have free space to do its job."
msgstr "Construir ejecutables nativos de esta manera puede tener el efecto secundario de requerir más tiempo para completarse. Esto se debe a que la recolección de basura tiene que trabajar más para que la generación de imágenes nativas tenga espacio libre para hacer su trabajo."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1954
#, fuzzy
msgid "Note that typical applications are likely bigger than quickstarts, so the memory requirements will also likely be higher."
msgstr "Tenga en cuenta que las aplicaciones típicas son probablemente más grandes que los quickstarts, por lo que los requisitos de memoria también serán probablemente mayores."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:1955
#, fuzzy, no-wrap
msgid "Why is runtime performance of a native executable inferior compared to JVM mode?"
msgstr "¿Por qué el rendimiento en tiempo de ejecución de un ejecutable nativo es inferior al del modo JVM?"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1960
#, fuzzy
msgid "As with most things in life there are some trade-offs involved when choosing native compilation over JVM mode.  So depending on the application the runtime performance of a native application might be slower compared to JVM mode, though that’s not always the case."
msgstr "Como con la mayoría de las cosas en la vida, hay algunas compensaciones cuando se elige la compilación nativa sobre el modo JVM. Así, dependiendo de la aplicación, el rendimiento en tiempo de ejecución de una aplicación nativa puede ser más lento en comparación con el modo JVM, aunque no siempre es así."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1966
#, fuzzy
msgid "JVM execution of an application includes runtime optimization of the code that profits from profile information built up during execution.  That includes the opportunities to inline a lot more of the code, locate hot code on direct paths (i.e. ensure better instruction cache locality)  and cut out a lot of the code on cold paths (on the JVM a lot of code does not get compiled until something tries to execute it -- it is replaced with a trap that causes deoptimization and recompilation).  Removal of cold paths provides many more optimization opportunities than are available for ahead of time compilation because it significantly reduces the branch complexity and combinatorial logic of the smaller amount of hot code that is compiled."
msgstr "La ejecución de una aplicación en la JVM incluye la optimización en tiempo de ejecución del código que se beneficia de la información del perfil acumulada durante la ejecución. Esto incluye las oportunidades de alinear mucho más código, localizar el código caliente en las rutas directas (es decir, garantizar una mejor localidad de la caché de instrucciones) y eliminar gran parte del código en las rutas frías (en la JVM, gran parte del código no se compila hasta que algo intenta ejecutarlo: se sustituye por una trampa que provoca la desoptimización y la recompilación). La eliminación de las rutas frías proporciona muchas más oportunidades de optimización que las disponibles para la compilación anticipada, ya que reduce significativamente la complejidad de las ramas y la lógica combinatoria de la menor cantidad de código caliente que se compila."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1969
#, fuzzy
msgid "By contrast, native executable compilation has to cater for all possible execution paths when it compiles code offline since it does not know which are the hot or cold paths and cannot use the trick of planting a trap and recompiling if it is hit. For the same reason it cannot load the dice to ensure that code cache conflicts are minimized by co-locating hot paths adjacent.  Native executable generation is able to remove some code because of the closed world hypothesis but that is often not enough to make up for all the benefits that profiling and runtime deopt & recompile provides to the JVM JIT compiler."
msgstr "Por el contrario, la compilación nativa de ejecutables tiene que atender a todas las posibles rutas de ejecución cuando compila el código fuera de línea, ya que no sabe cuáles son las rutas calientes o frías y no puede utilizar el truco de plantar una trampa y recompilar si es golpeada. Por la misma razón, no puede cargar los dados para garantizar que los conflictos de la caché de código se minimicen mediante la ubicación conjunta de las rutas calientes adyacentes. La generación de ejecutables nativos es capaz de eliminar algo de código debido a la hipótesis del mundo cerrado, pero eso no suele ser suficiente para compensar todos los beneficios que el perfilado y la desoperatividad y recompilación en tiempo de ejecución proporcionan al compilador JVM JIT."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1971
#, fuzzy
msgid "Note, however, that there is a price you pay for that potentially higher JVM speed, and that price is in increased resource usage (both CPU and memory) and startup time because:"
msgstr "Tenga en cuenta, sin embargo, que hay un precio que se paga por esa velocidad potencialmente más alta de la JVM, y ese precio es en el aumento del uso de recursos (tanto de la CPU como de la memoria) y el tiempo de inicio porque:"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1973
#, fuzzy
msgid "it takes some time before the JIT kicks in and fully optimizes the code."
msgstr "tarda algún tiempo antes de que el JIT entre en acción y optimice completamente el código."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1974
#, fuzzy
msgid "the JIT compiler consumes resources that could be utilized by the application."
msgstr "el compilador JIT consume recursos que podrían ser utilizados por la aplicación."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1975
#, fuzzy
msgid "the JVM has to retain a lot more metadata and compiler/profiler data to support the better optimizations that it can offer."
msgstr "la JVM tiene que retener muchos más metadatos y datos del compilador/perfilador para soportar las mejores optimizaciones que puede ofrecer."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1977
#, fuzzy
msgid "The reason for 1) is that code needs to be run interpreted for some time and, possibly, to be compiled several times before all potential optimizations are realized to ensure that:"
msgstr "La razón de 1) es que el código debe ejecutarse interpretado durante algún tiempo y, posiblemente, ser compilado varias veces antes de que se realicen todas las optimizaciones potenciales para garantizarlo:"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1979
#, fuzzy
msgid "it’s worth compiling that code path, i.e. it’s being executed enough times, and that"
msgstr "vale la pena compilar esa ruta de código, es decir, que se ejecuta suficientes veces, y que"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1980
#, fuzzy
msgid "we have enough profiling data to perform meaningful optimizations."
msgstr "tenemos suficientes datos de perfiles para realizar optimizaciones significativas."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1983
#, fuzzy
msgid "An implication of 1) is that for small, short-lived applications a native executable may well be a better bet.  Although the compiled code is not as well optimized it is available straight away."
msgstr "Una implicación de 1) es que para aplicaciones pequeñas y de corta duración un ejecutable nativo puede ser una mejor apuesta. Aunque el código compilado no está tan bien optimizado, está disponible de inmediato."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1986
#, fuzzy
msgid "The reason for 2) is that the JVM is essentially running the compiler at runtime in parallel with the application itself.  In the case of native executables the compiler is run ahead of time removing the need to run the compiler in parallel with the application."
msgstr "La razón de 2) es que la JVM ejecuta esencialmente el compilador en tiempo de ejecución en paralelo con la propia aplicación. En el caso de los ejecutables nativos, el compilador se ejecuta antes de tiempo, eliminando la necesidad de ejecutar el compilador en paralelo con la aplicación."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1995
#, fuzzy
msgid "There are several reasons for 3). The JVM does not have a closed world assumption.  So, it has to be able to recompile code if loading of new classes implies that it needs to revise optimistic assumptions made at compile time.  For example, if an interface has only one implementation it can make a call jump directly to that code.  However, in the case where a second implementation class is loaded the call site needs to be patched to test the type of the receiver instance and jump to the code that belongs to its class.  Supporting optimizations like this one requires keeping track of a lot more details of the class base than a native executable, including recording the full class and interface hierarchy, details of which methods override other methods, all method bytecode etc.  In a native executable most of the details of class structure and bytecode can be ignored at run time."
msgstr "Hay varias razones para 3). La JVM no tiene una suposición de mundo cerrado. Por lo tanto, tiene que ser capaz de recompilar el código si la carga de nuevas clases implica que necesita revisar las suposiciones optimistas hechas en tiempo de compilación. Por ejemplo, si una interfaz sólo tiene una implementación, puede hacer un salto de llamada directamente a ese código. Sin embargo, en el caso de que se cargue una segunda clase de implementación, el sitio de la llamada necesita ser parcheado para comprobar el tipo de la instancia receptora y saltar al código que pertenece a su clase. Soportar optimizaciones como ésta requiere mantener un registro de muchos más detalles de la clase base que un ejecutable nativo, incluyendo el registro de la clase completa y la jerarquía de la interfaz, los detalles de qué métodos sobrescriben a otros métodos, todo el código de bytes del método, etc. En un ejecutable nativo, la mayoría de los detalles de la estructura de la clase y el código de bytes pueden ignorarse en tiempo de ejecución."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2000
#, fuzzy
msgid "The JVM also has to cope with changes to the class base or execution profiles that result in a thread going down a previously cold path.  At that point the JVM has to jump out of the compiled code into the interpreter and recompile the code to cater for a new execution profile that includes the previously cold path.  That requires keeping runtime info that allow a compiled stack frame to be replaced with one or more interpreter frames.  It also requires runtime extensible profile counters to be allocated and updated to track what has or has not been executed."
msgstr "La JVM también tiene que hacer frente a los cambios en la base de clases o en los perfiles de ejecución que hacen que un hilo vaya por un camino previamente frío. En ese momento la JVM tiene que saltar del código compilado al intérprete y recompilar el código para atender a un nuevo perfil de ejecución que incluya la ruta previamente fría. Esto requiere mantener información en tiempo de ejecución que permita sustituir un marco de pila compilado por uno o más marcos de intérprete. También requiere que se asignen y actualicen contadores de perfil extensibles en tiempo de ejecución para hacer un seguimiento de lo que se ha ejecutado o no."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:2001
#, fuzzy, no-wrap
msgid "Why are native executables “big”?"
msgstr "¿Por qué los ejecutables nativos son \"grandes\"?"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2004
#, fuzzy
msgid "This can be attributed to a number of different reasons:"
msgstr "Esto puede atribuirse a diferentes razones:"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2010
#, fuzzy
msgid "Native executables include not only the application code but also, library code, and JDK code.  As a result a more fair comparison would be to compare the native executable’s size with the size of the application, plus the size of the libraries it uses, plus the size of the JDK.  Especially the JDK part is not negligible even in simple applications like HelloWorld.  To get a glance on what is being pulled in the image one can use `-H:+PrintUniverse` when building the native executable."
msgstr "Los ejecutables nativos no sólo incluyen el código de la aplicación, sino también el de las bibliotecas y el del JDK. Como resultado, una comparación más justa sería comparar el tamaño del ejecutable nativo con el tamaño de la aplicación, más el tamaño de las bibliotecas que utiliza, más el tamaño del JDK. Especialmente la parte del JDK no es despreciable ni siquiera en aplicaciones sencillas como HelloWorld. Para echar un vistazo a lo que se tira en la imagen se puede utilizar `-H:+PrintUniverse` cuando se construye el ejecutable nativo."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2016
#, fuzzy
msgid "Some features are always included in a native executable even though they might never be actually used at run time.  An example of such a feature is garbage collection.  At compile time we can’t be sure whether an application will need to run garbage collection at run time, so garbage collection is always included in native executables increasing their size even if not necessary.  Native executable generation relies on static code analysis to identify which code paths are reachable, and static code analysis can be imprecise leading to more code getting into the image than what’s actually needed."
msgstr "Algunas funciones se incluyen siempre en un ejecutable nativo aunque nunca se utilicen realmente en tiempo de ejecución. Un ejemplo de este tipo de características es la recolección de basura. En tiempo de compilación no podemos estar seguros de si una aplicación necesitará ejecutar la recolección de basura en tiempo de ejecución, por lo que la recolección de basura siempre se incluye en los ejecutables nativos aumentando su tamaño aunque no sea necesaria. La generación de ejecutables nativos se basa en el análisis de código estático para identificar qué rutas de código son accesibles, y el análisis de código estático puede ser impreciso, lo que hace que se introduzca en la imagen más código del que realmente se necesita."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2019
#, fuzzy
msgid "There is a https://github.com/oracle/graal/issues/287[GraalVM upstream issue] with some interesting discussions about that topic."
msgstr "Hay una  link:https://github.com/oracle/graal/issues/287[edición de GraalVM] con algunas discusiones interesantes sobre este tema."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:2020
#, fuzzy, no-wrap
msgid "What version of Mandrel was used to generate a binary?"
msgstr "¿Qué versión de Mandrel se ha utilizado para generar un binario?"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2023
#, fuzzy
msgid "One can see which Mandrel version was used to generate a binary by inspecting the binary as follows:"
msgstr "Se puede ver qué versión de Mandrel se utilizó para generar un binario inspeccionando el binario de la siguiente manera:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2028
#, no-wrap
msgid ""
"$ strings target/debugging-native-1.0.0-SNAPSHOT-runner | grep GraalVM\n"
"com.oracle.svm.core.VM=GraalVM 22.0.0.2-Final Java 11 Mandrel Distribution\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/native-reference.adoc:2030
#, fuzzy, no-wrap
msgid "How do I enable GC logging in native executables?"
msgstr "¿Cómo puedo activar el registro de la GC en los ejecutables nativos?"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2033
#, fuzzy
msgid "See xref:gc-logging[Native Memory Management GC Logging section] for details."
msgstr "Para más detalles, consulte  link:#gc-logging[la sección de registro GC de la gestión de la memoria nativa]."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:2035
#, fuzzy, no-wrap
msgid "Can I get a heap dump of a native executable? e.g. if it runs out of memory"
msgstr "¿Puedo obtener un volcado de heap de un ejecutable nativo? Por ejemplo, si se queda sin memoria"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2040
#, fuzzy
msgid "Starting with GraalVM 22.2.0 it is possible to create heap dumps upon request, e.g. `kill -SIGUSR1 <pid>`.  Support for dumping the heap dump upon an out of memory error will follow up."
msgstr "A partir de GraalVM 22.2.0 será posible realizar volcados de heap a petición, por ejemplo, `kill -SIGUSR1 &amp;lt;pid&amp;gt;`. El soporte para el volcado de la pila en caso de error de memoria será posterior."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:2041
#, fuzzy, no-wrap
msgid "Can I build and run this examples outside a container in Linux?"
msgstr "¿Puedo construir y ejecutar estos ejemplos fuera de un contenedor en Linux?"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2047
#, fuzzy
msgid "Yes you can.  In fact, debugging native executables on a Linux bare metal box offers the best possible experience.  In this kind of environments, root access is not needed except to install packages required to run some debug steps, or to enable `perf` to gather events at the kernel."
msgstr "Sí se puede. De hecho, la depuración de ejecutables nativos en una caja Linux bare metal ofrece la mejor experiencia posible. En este tipo de entornos, el acceso de root no es necesario, excepto para instalar los paquetes necesarios para ejecutar algunos pasos de depuración, o para habilitar `perf` para recoger eventos en el kernel."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2049
#, fuzzy
msgid "These are the packages you'll need on your Linux environment to run through the different debugging sections:"
msgstr "Estos son los paquetes que necesitarás en tu entorno Linux para ejecutar las diferentes secciones de depuración:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2056
#, no-wrap
msgid ""
"# dnf (rpm-based)\n"
"sudo dnf install binutils gdb perf perl-open\n"
"# Debian-based distributions:\n"
"sudo apt install binutils gdb perf\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/native-reference.adoc:2058
#, fuzzy, no-wrap
msgid "Generating flame graphs is slow, or produces errors, what can I do?"
msgstr "La generación de gráficos de llama es lenta o produce errores, ¿qué puedo hacer?"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2062
#, fuzzy
msgid "There are multiple ways in which a native executable produced by Mandrel can be profiled.  All the methods require you to pass in the `-H:-DeleteLocalSymbols` option."
msgstr "Existen múltiples formas de perfilar un ejecutable nativo producido por Mandrel. Todos los métodos requieren que se pase la opción `-H:-DeleteLocalSymbols`."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2066
#, fuzzy
msgid "The method shown in this reference guide generates a binary with DWARF debug information, runs it via `perf record` and then uses `perf script` and flame graph tooling to generate the flamegraphs.  However, the `perf script` post-processing step done on this binary can appear to be slow or can show some DWARF errors."
msgstr "El método que se muestra en esta guía de referencia genera un binario con información de depuración DWARF, lo ejecuta a través de `perf record` y, a continuación, utiliza `perf script` y la herramienta de gráficos de llama para generar los gráficos de llama. Sin embargo, el paso de post-procesamiento `perf script` realizado en este binario puede parecer lento o puede mostrar algunos errores DWARF."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2071
#, fuzzy
msgid "An alternative method to generate flame graphs is to pass in `-H:+PreserveFramePointer` when generating the native executable instead of generating the DWARF debug information.  It instructs the binary to use an extra register for the frame pointer.  This enables `perf` to do stack walking to profile the runtime behaviour.  To generate the native executable using these flags, do the following:"
msgstr "Un método alternativo para generar gráficos de llama es pasar en `-H:+PreserveFramePointer` cuando se genera el ejecutable nativo en lugar de generar la información de depuración DWARF. Esto instruye al binario para que utilice un registro extra para el puntero de la trama. Esto permite a `perf` hacer stack walking para perfilar el comportamiento en tiempo de ejecución. Para generar el ejecutable nativo utilizando estas banderas, haz lo siguiente:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2076
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative\n"
"    -Dquarkus.native.additional-build-args=-H:+PreserveFramePointer,-H:-DeleteLocalSymbols\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2079
#, fuzzy
msgid "To get runtime profiling information out of the native executable, simply do:"
msgstr "Para obtener información de perfiles en tiempo de ejecución del ejecutable nativo, simplemente haga"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2087
#, fuzzy
msgid "The recommended method for generating runtime profiling information is using the debug information rather than generating a binary that preserves the frame pointer.  This is because adding debug information to the native executable build process has no negative runtime performance whereas preserving the frame pointer does."
msgstr "El método recomendado para generar información de perfil en tiempo de ejecución es utilizar la información de depuración en lugar de generar un binario que conserve el puntero de cuadro. Esto se debe a que la adición de información de depuración al proceso de construcción del ejecutable nativo no tiene un rendimiento negativo en tiempo de ejecución, mientras que la preservación del puntero de marco sí lo tiene."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2093
#, fuzzy
msgid "DWARF debug info is generated in a separate file and can even be omitted in the default deployment and only be transferred and used on demand, for profiling or debugging purposes.  Furthermore, the presence of debug info enables `perf` to show us the relevant source code lines as well, hence it does not bloat the native executable itself.  To do that, simply call `perf report` with an extra parameter to show source code lines:"
msgstr "La información de depuración DWARF se genera en un archivo separado y puede incluso omitirse en el despliegue por defecto y sólo ser transferida y utilizada bajo demanda, con fines de perfilado o depuración. Además, la presencia de la información de depuración permite que `perf` nos muestre también las líneas de código fuente relevantes, por lo que no abulta el propio ejecutable nativo. Para ello, basta con llamar a `perf report` con un parámetro extra para mostrar las líneas de código fuente:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2103
#, no-wrap
msgid ""
"perf report --stdio -F+srcline\n"
"...\n"
"83.69%     0.00%  GreetingResource.java:20 ...\n"
"...\n"
"83.69%     0.00%  AbstractStringBuilder.java:1025 ...\n"
"...\n"
"83.69%     0.00%  ArraycopySnippets.java:95 ...\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2109
#, fuzzy
msgid "The performance penalty of preserving the frame pointer is due to using the extra register for stack walking, particularly in `x86_64` compared to `aarch64` where there are fewer registers available.  Using this extra register reduces the number of registers that are available for other work, which can lead to performance penalties."
msgstr "La penalización de rendimiento que supone conservar el puntero de trama se debe a que se utiliza el registro extra para recorrer la pila, especialmente en `x86_64` en comparación con `aarch64`, donde hay menos registros disponibles. El uso de este registro extra reduce el número de registros que están disponibles para otras tareas, lo que puede llevar a penalizaciones de rendimiento."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:2110
#, fuzzy, no-wrap
msgid "I think I’ve found a bug in native-image, how can I debug it with the IDE?"
msgstr "Creo que he encontrado un error en native-image, ¿cómo puedo depurarlo con el IDE?"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2114
#, fuzzy
msgid "Although it is possible to remote debug processes within containers, it might be easier to step-by-step debug native-image by installing Mandrel locally and adding it to the path of the shell process."
msgstr "Aunque es posible depurar remotamente los procesos dentro de los contenedores, podría ser más fácil depurar paso a paso la imagen nativa instalando Mandrel localmente y añadiéndolo a la ruta del proceso del shell."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2119
#, fuzzy
msgid "Native executable generation is the result of two Java processes that are executed sequentially.  The first process is very short and its main job is to set things up for the second process.  The second process is the one that takes care of most of the work.  The steps to debug one process or the other vary slightly."
msgstr "La generación de ejecutables nativos es el resultado de dos procesos Java que se ejecutan secuencialmente. El primer proceso es muy corto y su trabajo principal es preparar las cosas para el segundo proceso. El segundo proceso es el que se encarga de la mayor parte del trabajo. Los pasos para depurar un proceso u otro varían ligeramente."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2124
#, fuzzy
msgid "Let’s discuss first how to debug the second process, which is the one you most likely to want to debug.  The starting point for the second process is the `com.oracle.svm.hosted.NativeImageGeneratorRunner` class.  To debug this process, simply add `--debug-attach=*:8000` as an additional build time argument:"
msgstr "Vamos a discutir primero cómo depurar el segundo proceso, que es el que más probablemente querrá depurar. El punto de partida del segundo proceso es la clase `com.oracle.svm.hosted.NativeImageGeneratorRunner`. Para depurar este proceso, simplemente añada `--debug-attach=*:8000` como un argumento adicional en tiempo de compilación:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2129
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative \\\n"
"    -Dquarkus.native.additional-build-args=--debug-attach=*:8000\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2135
#, fuzzy
msgid "The starting point for the first process is the `com.oracle.svm.driver.NativeImages` class.  In GraalVM CE distributions, this first process is a binary, so debugging it in the traditional way with a Java IDE is not possible.  However, Mandrel distributions (or locally built GraalVM CE instances) keep this as a normal Java process, so you can remote debug this process by adding the `--vm.agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=*:8000` as an additional build argument, e.g."
msgstr "El punto de partida del primer proceso es la clase `com.oracle.svm.driver.NativeImages`. En las distribuciones de GraalVM CE, este primer proceso es un binario, por lo que depurarlo de la forma tradicional con un IDE de Java no es posible. Sin embargo, las distribuciones de Mandrel (o las instancias de GraalVM CE construidas localmente) mantienen esto como un proceso Java normal, por lo que puedes depurar remotamente este proceso añadiendo el `--vm.agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=*:8000` como un argumento de construcción adicional, por ejemplo"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2140
#, no-wrap
msgid ""
"$ ./mvnw package -DskipTests -Dnative \\\n"
"    -Dquarkus.native.additional-build-args=--vm.agentlib:jdwp=transport=dt_socket\\\\,server=y\\\\,suspend=y\\\\,address=*:8000\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/native-reference.adoc:2142
#, fuzzy, no-wrap
msgid "Can I use JFR/JMC to debug or profile native binaries?"
msgstr "¿Puedo utilizar JFR/JMC para depurar o perfilar binarios nativos?"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2151
#, fuzzy
msgid "https://docs.oracle.com/javacomponents/jmc-5-4/jfr-runtime-guide/about.htm#JFRUH170[Java Flight Recorder (JFR)] and https://www.oracle.com/java/technologies/jdk-mission-control.html[JDK Mission Control (JMC)] can be used to profile native binaries since GraalVM CE 21.2.0.  However, JFR in GraalVM is currently limited in capabilities compared to HotSpot.  The custom event API is fully supported, but some VM level features are unavailable.  More events and JFR features will continue to be added in later releases.  The following table outlines Native Image JFR support and limitations by version."
msgstr "link:https://docs.oracle.com/javacomponents/jmc-5-4/jfr-runtime-guide/about.htm#JFRUH170[Java Flight Recorder (JFR)] y  link:https://www.oracle.com/java/technologies/jdk-mission-control.html[JDK Mission Control (JMC)] pueden utilizarse para perfilar los binarios nativos desde GraalVM CE 21.2.0. Sin embargo, JFR en GraalVM está actualmente limitado significativamente en sus capacidades en comparación con HotSpot. La API de eventos personalizados es totalmente compatible, pero muchas características a nivel de VM no están disponibles. Se añadirán en futuras versiones. Las limitaciones actuales son:"

#. type: Table
#: upstream/_guides/native-reference.adoc:2154
#, fuzzy, no-wrap
msgid "GraalVM Version"
msgstr "Versión de GraalVM"

#. type: Table
#: upstream/_guides/native-reference.adoc:2154
#, fuzzy, no-wrap
msgid "Supports"
msgstr "Admite"

#. type: Table
#: upstream/_guides/native-reference.adoc:2156
#, fuzzy, no-wrap
msgid "Limitations"
msgstr "Limitaciones"

#. type: Table
#: upstream/_guides/native-reference.adoc:2157
#, fuzzy, no-wrap
msgid "GraalVM CE 21.3 and Mandrel 21.3"
msgstr "GraalVM CE 21.3 y Mandrel 21.3"

#. type: Bullet: '* '
#: upstream/_guides/native-reference.adoc:2160
#, fuzzy
msgid "Minimal VM Level events"
msgstr "Eventos mínimos a nivel de VM"

#. type: Bullet: '* '
#: upstream/_guides/native-reference.adoc:2160
#, fuzzy
msgid "Custom events API"
msgstr "API de eventos personalizados"

#. type: Table
#: upstream/_guides/native-reference.adoc:2160
#, fuzzy, no-wrap
msgid "* Start recordings upon executabe run or JFR Recording API"
msgstr "<li> <p>Iniciar grabaciones al ejecutar el programa o la API de grabación de JFR</p> </li>"

#. type: Bullet: '* '
#: upstream/_guides/native-reference.adoc:2165
#: upstream/_guides/native-reference.adoc:2172
#, fuzzy
msgid "No old object sampling"
msgstr "No hay muestreo de objetos antiguos"

#. type: Bullet: '* '
#: upstream/_guides/native-reference.adoc:2165
#: upstream/_guides/native-reference.adoc:2172
#, fuzzy
msgid "No stacktrace tracing"
msgstr "No hay rastreo de pila"

#. type: Table
#: upstream/_guides/native-reference.adoc:2165
#: upstream/_guides/native-reference.adoc:2172
#, fuzzy, no-wrap
msgid "* No event streaming"
msgstr "<li> <p>Sin retransmisión de eventos</p> </li>"

#. type: Table
#: upstream/_guides/native-reference.adoc:2166
#, fuzzy, no-wrap
msgid "GraalVM CE 22.3 and Mandrel 22.3"
msgstr "GraalVM CE 22.3 y Mandrel 22.3"

#. type: Bullet: '* '
#: upstream/_guides/native-reference.adoc:2168
#, fuzzy
msgid "Everything from GraalVM CE 21.3"
msgstr "Todo desde GraalVM CE 21.3"

#. type: Table
#: upstream/_guides/native-reference.adoc:2168
#, fuzzy, no-wrap
msgid "* Additional monitor and thread events"
msgstr "<li> <p>Eventos adicionales de monitores e hilos</p> </li>"

#. type: Table
#: upstream/_guides/native-reference.adoc:2173
#, fuzzy, no-wrap
msgid "GraalVM CE for JDK 17/20 and Mandrel 23.0"
msgstr "GraalVM CE para JDK 17/20 y Mandrel 23.0"

#. type: Bullet: '* '
#: upstream/_guides/native-reference.adoc:2178
#, fuzzy
msgid "Everything from GraalVM CE 22.3"
msgstr "Todo desde GraalVM CE 22.3"

#. type: Bullet: '* '
#: upstream/_guides/native-reference.adoc:2178
#, fuzzy
msgid "Additional monitor, thread, container, and allocation events"
msgstr "Eventos adicionales de monitor, hilo, contenedor y asignación"

#. type: Bullet: '* '
#: upstream/_guides/native-reference.adoc:2178
#, fuzzy
msgid "Stacktraces"
msgstr "Stacktraces"

#. type: Bullet: '* '
#: upstream/_guides/native-reference.adoc:2178
#, fuzzy
msgid "Sampling based method profiling"
msgstr "Perfiles de métodos basados en muestreos"

#. type: Table
#: upstream/_guides/native-reference.adoc:2178
#, fuzzy, no-wrap
msgid "* Event streaming"
msgstr "<li> <p>Transmisión de eventos</p> </li>"

#. type: Table
#: upstream/_guides/native-reference.adoc:2180
#, fuzzy, no-wrap
msgid "* No old object sampling"
msgstr "No hay muestreo de objetos antiguos"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2185
#, fuzzy
msgid "To add JFR support to your Quarkus executable, add the application property: `-Dquarkus.native.monitoring=jfr`.  E.g."
msgstr "Para utilizar JFR añada la propiedad de la aplicación: `-Dquarkus.native.enable-vm-inspection=true`. Por ejemplo"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2191
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative -Dquarkus.native.container-build=true \\\n"
"    -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel-builder-image:{mandrel-flavor} \\\n"
"    -Dquarkus.native.monitoring=jfr\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2194
#, fuzzy
msgid "Once the image is compiled, enable and start JFR via runtime flags: `-XX:+FlightRecorder` and `-XX:StartFlightRecording`. For example:"
msgstr "Una vez compilada la imagen, habilite e inicie JFR a través de las banderas de tiempo de ejecución: `-XX:+FlightRecorder` y `-XX:StartFlightRecording`. Por ejemplo:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2200
#, no-wrap
msgid ""
"./target/debugging-native-1.0.0-SNAPSHOT-runner \\\n"
"    -XX:+FlightRecorder \\\n"
"    -XX:StartFlightRecording=\"filename=recording.jfr\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2203
#, fuzzy
msgid "For more information about using JFR, see the link:https://www.graalvm.org/{graalvm-docs-version}/reference-manual/native-image/debugging-and-diagnostics/JFR/[GraalVM JDK Flight Recorder (JFR) with Native Image] guide."
msgstr "Para más detalles sobre el uso del JFR, consulte  link:https://www.graalvm.org/reference-manual/native-image/JFR[aquí]."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:2204
#, fuzzy, no-wrap
msgid "How can we troubleshoot performance problems only reproducible in production?"
msgstr "¿Cómo podemos solucionar los problemas de rendimiento que sólo son reproducibles en producción?"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2214
#, fuzzy
msgid "In this situation, switching to JVM mode would be the best thing to try first.  If the performance issues continue after switching to JVM mode, you can use more established and mature tooling to figure out the root cause.  If the performance issue is limited to native mode only, you might not be able to use `perf`, so JFR is the only way to gather any information in this situation.  As JFR support for native expands, the ability to detect root causes of performance issues directly in production will improve."
msgstr "En esta situación, cambiar al modo JVM sería lo mejor para probar primero. Si los problemas de rendimiento continúan después de cambiar al modo JVM, puedes utilizar herramientas más establecidas y maduras para averiguar la causa raíz. Si el problema de rendimiento se limita únicamente al modo nativo, es posible que no pueda utilizar `perf`, por lo que JFR es la única forma de obtener información en esta situación. A medida que se amplíe el soporte de JFR para el modo nativo, mejorará la capacidad de detectar las causas raíz de los problemas de rendimiento directamente en producción."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:2215
#, fuzzy, no-wrap
msgid "What information helps most debug issues that happen either at build-time or run-time?"
msgstr "¿Qué información ayuda más a depurar los problemas que se producen en tiempo de compilación o de ejecución?"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2219
#, fuzzy
msgid "To fix classpath, class initialization or forbidden API errors at build time it's best to use xref:native-reports[build time reports] to understand the closed world universe.  A complete picture of the universe, along with the relationships between the different classes and methods will help uncover and fix most of the issues."
msgstr "Para solucionar errores de classpath, inicialización de clases o APIs prohibidas en tiempo de compilación, lo mejor es utilizar  link:#native-reports[los informes de tiempo de compilación] para entender el universo del mundo cerrado. Una imagen completa del universo, junto con las relaciones entre las diferentes clases y métodos ayudará a descubrir y solucionar la mayoría de los problemas."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2225
#, fuzzy
msgid "To fix runtime native specific errors, it's best to have xref:debug-info[debug info builds] of the native executables around, so that `gdb` can be hooked up quickly to debug the issue.  If you also add local symbols to the debug info builds, you will obtain precise xref:profiling[profiling information] as well."
msgstr "Para solucionar errores específicos de los nativos en tiempo de ejecución, es mejor tener  link:#debug-info[compilaciones] de información de depuración de los ejecutables nativos, de modo que `gdb` pueda conectarse rápidamente para depurar el problema. Si además añades símbolos locales a las compilaciones de información de depuración, también obtendrás  link:#profiling[información] precisa de  link:#profiling[perfiles]."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:2226
#, fuzzy, no-wrap
msgid "Build stalled for minutes, barely using any CPU"
msgstr "La compilación se detuvo durante minutos, sin apenas usar CPU."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2229
#, fuzzy
msgid "It might so happen that the build gets stalled and even ends up with:"
msgstr "Puede ocurrir que la construcción se estanque e incluso acabe con:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2233
#, no-wrap
msgid "Image generator watchdog detected no activity.\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2236
#, fuzzy
msgid "One of the possible explanations could be a lack of entropy, e.g. on an entropy constrained VM, if such a source is needed as it is the case with Bouncycastle at build time."
msgstr "Una de las posibles explicaciones podría ser la falta de entropía, por ejemplo, en una máquina virtual con restricciones de entropía, si se necesita una fuente de este tipo, como es el caso de Bouncycastle en el momento de la compilación."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2238
#, fuzzy
msgid "One can check the available entropy on a Linux system with:"
msgstr "Se puede comprobar la entropía disponible en un sistema Linux con:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2242
#, no-wrap
msgid "$ cat /proc/sys/kernel/random/entropy_avail\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2244
#, fuzzy
msgid "If the amount is not in hundreds, it could be a problem. A possible workaround is to compromise, acceptable for testing, and set:"
msgstr "Si la cantidad no está en cientos, podría ser un problema. Una posible solución es comprometer, aceptable para la prueba, y establecer:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2247
#, no-wrap
msgid "export JAVA_OPTS=-Djava.security.egd=/dev/urandom\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2249
#, fuzzy
msgid "The proper solution is to increase the entropy available for the system. That is specific for each OS vendor and virtualization solution though."
msgstr "La solución adecuada es aumentar la entropía disponible para el sistema. Sin embargo, esto es específico para cada proveedor de SO y solución de virtualización."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:2250
#, fuzzy, no-wrap
msgid "Work around missing CPU features"
msgstr "Funciones de la CPU que faltan"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2253
#, fuzzy
msgid "When building on recent machines and running your native executable on older machines, you may see the following failure when starting the application:"
msgstr "Al compilar en máquinas recientes y ejecutar su ejecutable nativo en máquinas más antiguas, es posible que vea el siguiente fallo al iniciar la aplicación:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2258
#, no-wrap
msgid ""
"The current machine does not support all of the following CPU features that are required by the image: [CX8, CMOV, FXSR, MMX, SSE, SSE2, SSE3, SSSE3, SSE4_1, SSE4_2, POPCNT, LZCNT, AVX, AVX2, BMI1, BMI2, FMA].\n"
"Please rebuild the executable with an appropriate setting of the -march option.\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2262
#, fuzzy
msgid "This error message means that the native compilation used more advanced instruction sets, not supported by the CPU running the application.  To work around that issue, add the following line to the `application.properties`:"
msgstr "Este mensaje de error significa que la compilación nativa utilizó conjuntos de instrucciones más avanzados, no soportados por la CPU que ejecuta la aplicación. Para solucionar este problema, añada la siguiente línea a `application.properties`:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2266
#, no-wrap
msgid "quarkus.native.additional-build-args=-march=compatibility\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2270
#, fuzzy
msgid "Then, rebuild your native executable.  This setting forces the native compilation to use an older instruction set, increasing the chance of compatibility."
msgstr "A continuación, reconstruye tu ejecutable nativo. Esta configuración obliga a la compilación nativa a utilizar un conjunto de instrucciones más antiguo, lo que aumenta las posibilidades de compatibilidad."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2273
#, fuzzy
msgid "To explicitly define the target architecture run `native-image -march=list` to get the supported configurations and then set `-march` to one of them, e.g., `quarkus.native.additional-build-args=-march=x86-64-v4`.  If you are targeting an AMD64 host, `-march=x86-64-v2` would work in most cases."
msgstr "Para definir explícitamente la arquitectura de destino, ejecute `native-image -march=list` para obtener las configuraciones admitidas y, a continuación, establezca `-march` en una de ellas, por ejemplo, `quarkus.native.additional-build-args=-march=x86-64-v4`. Si su objetivo es un host AMD64, `-march=x86-64-v2` funcionará en la mayoría de los casos."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2274
#, fuzzy
msgid "The `march` parameter is only available on GraalVM 23+."
msgstr "El parámetro `march` sólo está disponible en GraalVM 23+."

#, fuzzy
#~ msgid "Memory management for Quarkus native executables is enabled by GraalVM’s SubstrateVM runtime system.  The memory management component in GraalVM is explained in detail link:https://www.graalvm.org/{graalvm-version}/reference-manual/native-image/optimizations-and-performance/MemoryManagement[here].  This guide complements the information available in the GraalVM website with further observations particularly relevant to Quarkus applications."
#~ msgstr "La gestión de la memoria para los ejecutables nativos de Quarkus está habilitada por el sistema de tiempo de ejecución SubstrateVM de GraalVM. El componente de gestión de la memoria en GraalVM se explica en detalle  link:https://www.graalvm.org/{graalvm-version}/reference-manual/native-image/optimizations-and-performance/MemoryManagement[aquí]. Esta guía complementa la información disponible en el sitio web de GraalVM con otras observaciones especialmente relevantes para las aplicaciones de Quarkus."

#, fuzzy
#~ msgid "No Streaming API for JDK 17"
#~ msgstr "No hay API de streaming para JDK 17"

#, fuzzy
#~ msgid "Executing the native executable with `-XX:PrintFlags=` prints a list of flags that can be passed to native executables.  For various levels of GC logging one may use:"
#~ msgstr "Al ejecutar el ejecutable nativo con `-XX:PrintFlags=` se imprime una lista de banderas que se pueden pasar a los ejecutables nativos. Para varios niveles de registro de GC se puede utilizar:"

#, fuzzy
#~ msgid "Since Mandrel 21.3.0.0, the call tree is also reported as a group of CSV files.  The CSV output can be enabled by adding `-H:PrintAnalysisCallTreeType=CSV` to the additional native arguments. E.g."
#~ msgstr "Desde Mandrel 21.3.0.0, el árbol de llamadas también se reporta como un grupo de archivos CSV. La salida CSV se puede habilitar añadiendo `-H:PrintAnalysisCallTreeType=CSV` a los argumentos nativos adicionales. Por ejemplo"

#, fuzzy
#~ msgid "These can in turn be imported into a graph database, such as Neo4j, to inspect them more easily and run queries against the call tree.  Let’s see this in action."
#~ msgstr "A su vez, estos pueden ser importados a una base de datos gráfica, como Neo4j, para inspeccionarlos más fácilmente y ejecutar consultas contra el árbol de llamadas. Veamos esto en acción."

#, fuzzy
#~ msgid "Unfortunately generating heap dumps in hprof format, which can be opened by tools such as VisualVM or Eclipse MAT, can only be achieved with https://www.graalvm.org/reference-manual/native-image/NativeImageHeapdump[GraalVM Enterprise Edition].  Mandrel, which is based on the GraalVM Community Edition, does not have this capability."
#~ msgstr "Desgraciadamente, la generación de volcados de heap en formato hprof, que pueden ser abiertos por herramientas como VisualVM o Eclipse MAT, sólo puede lograrse con  link:https://www.graalvm.org/reference-manual/native-image/NativeImageHeapdump[GraalVM Enterprise Edition]. Mandrel, que se basa en GraalVM Community Edition, no tiene esta capacidad."

#, fuzzy
#~ msgid "Although Mandrel can generate debug symbols and these contain a fair amount of information about object layouts, including what is a pointer field vs a primitive field, this information cannot be used as is to detect memory leaks or find dominator objects.  This is because it has no idea what constitutes a root pointer nor how to recursively trace pointers from those roots."
#~ msgstr "Aunque Mandrel puede generar símbolos de depuración y éstos contienen una buena cantidad de información sobre la disposición de los objetos, incluyendo lo que es un campo puntero frente a un campo primitivo, esta información no puede utilizarse tal cual para detectar fugas de memoria o encontrar objetos dominantes. Esto se debe a que no tiene idea de lo que constituye un puntero raíz ni de cómo rastrear recursivamente los punteros desde esas raíces."
