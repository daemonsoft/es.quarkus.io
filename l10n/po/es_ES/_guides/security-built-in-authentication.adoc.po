# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2022-12-06 18:09+0000\n"
"PO-Revision-Date: 2022-05-24 12:24+0200\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: es_ES\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.0.1\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/security-built-in-authentication.adoc:6
#, no-wrap
msgid "Built-In Authentication Support"
msgstr "Soporte de autenticación incorporado"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:11
#, fuzzy
msgid "The following section describes the Quarkus built-in authentication mechanisms for HTTP based FORM, BASIC, and Mutual TLS authentication. Proactive authentication is also described."
msgstr "Este documento describe los mecanismos de autenticación incorporados en Quarkus para la autenticación FORM basada en HTTP, BASIC y Mutual TLS, así como la autenticación proactiva."

#. type: Title ==
#: upstream/_guides/security-built-in-authentication.adoc:18
#, no-wrap
msgid "Form Based Authentication"
msgstr "Autenticación basada en formularios"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:24
#, fuzzy
msgid "Quarkus provides form based authentication that works in a similar manner to traditional Servlet form based auth. Unlike traditional form authentication, the authenticated user is not stored in an HTTP session, as Quarkus does not provide clustered HTTP session support. Instead, the authentication information is stored in an encrypted cookie, which can be read by all members of the cluster (provided they all share the same encryption key)."
msgstr "Quarkus proporciona una autenticación basada en formularios que funciona de manera similar a la autenticación tradicional basada en formularios Servlet. A diferencia de la autenticación tradicional de formularios, el usuario autenticado no se almacena en una sesión HTTP, ya que Quarkus no proporciona soporte para sesiones HTTP agrupadas. En su lugar, la información de autenticación se almacena en una cookie encriptada, que puede ser leída por todos los miembros del clúster (siempre que todos compartan la misma clave de encriptación)."

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:30
msgid "The encryption key can be set using the `quarkus.http.auth.session.encryption-key` property, and it must be at least 16 characters long. This key is hashed using SHA-256 and the resulting digest is used as a key for AES-256 encryption of the cookie value. This cookie contains an expiry time as part of the encrypted value, so all nodes in the cluster must have their clocks synchronized. At one minute intervals a new cookie will be generated with an updated expiry time if the session is in use."
msgstr "La clave de encriptación puede establecerse utilizando la propiedad `quarkus.http.auth.session.encryption-key`, y debe tener al menos 16 caracteres. Esta clave se convierte en hash utilizando SHA-256 y el resumen resultante se utiliza como clave para el cifrado AES-256 del valor de la cookie. Esta cookie contiene una hora de caducidad como parte del valor cifrado, por lo que todos los nodos del clúster deben tener sus relojes sincronizados. A intervalos de un minuto se generará una nueva cookie con una hora de caducidad actualizada si la sesión está en uso."

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:32
msgid "The following properties can be used to configure form based auth:"
msgstr "Las siguientes propiedades se pueden utilizar para configurar la autentificación basada en formularios:"

#. type: Title ==
#: upstream/_guides/security-built-in-authentication.adoc:36
#, no-wrap
msgid "Mutual TLS Authentication"
msgstr "Autenticación mutua TLS"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:39
msgid "Quarkus provides mTLS authentication so that you can authenticate users based on their X.509 certificates."
msgstr "Quarkus proporciona autenticación mTLS para que pueda autenticar a los usuarios basándose en sus certificados X.509."

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:41
msgid "To use this authentication method, you should first enable SSL for your application. For more details, check the xref:http-reference.adoc#ssl[Supporting secure connections with SSL] guide."
msgstr "Para utilizar este método de autenticación, primero debe habilitar SSL para su aplicación. Para más detalles, consulte la guía xref:http-reference.html#ssl[Soporte de conexiones seguras con SSL]."

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:45
msgid "Once your application is accepting secure connections, the next step is to configure a `quarkus.http.ssl.certificate.trust-store-file` holding all the certificates that your application should trust as well as how your application should ask for certificates when a client (e.g.: browser or another service) tries to access one of its protected resources."
msgstr "Una vez que su aplicación está aceptando conexiones seguras, el siguiente paso es configurar un `quarkus.http.ssl.certificate.trust-store-file` que contenga todos los certificados en los que su aplicación debe confiar, así como la forma en que su aplicación debe solicitar los certificados cuando un cliente (por ejemplo, un navegador u otro servicio) intente acceder a uno de sus recursos protegidos."

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:53
#, no-wrap
msgid ""
"quarkus.http.ssl.certificate.key-store-file=server-keystore.jks            <1>\n"
"quarkus.http.ssl.certificate.key-store-password=the_key_store_secret\n"
"quarkus.http.ssl.certificate.trust-store-file=server-truststore.jks        <2>\n"
"quarkus.http.ssl.certificate.trust-store-password=the_trust_store_secret\n"
"quarkus.http.ssl.client-auth=required                                      <3>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:56
#, no-wrap
msgid ""
"quarkus.http.auth.permission.default.paths=/*                              <4>\n"
"quarkus.http.auth.permission.default.policy=authenticated\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:58
msgid "Configures a key store where the server's private key is located."
msgstr "Configura un almacén de claves donde se encuentra la clave privada del servidor."

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:59
msgid "Configures a trust store from where the trusted certificates are going to be loaded from."
msgstr "Configura un almacén de confianza desde el que se van a cargar los certificados de confianza."

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:62
msgid "Defines that the server should *always* ask certificates from clients. You can relax this behavior by using `REQUEST` so that the server should still accept requests without a certificate. Useful when you are also supporting authentication methods other than mTLS."
msgstr "Define que el servidor debe pedir *siempre* certificados a los clientes. Puede relajar este comportamiento utilizando `REQUEST` para que el servidor siga aceptando peticiones sin certificado. Es útil cuando también se admiten métodos de autenticación distintos de mTLS."

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:63
msgid "Defines a policy where only authenticated users should have access to resources from your application."
msgstr "Define una política en la que sólo los usuarios autentificados deben tener acceso a los recursos de su aplicación."

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:66
msgid "Once the incoming request matches a valid certificate in the truststore, your application should be able to obtain the subject by just injecting a `SecurityIdentity` as follows:"
msgstr "Una vez que la solicitud entrante coincida con un certificado válido en el almacén de confianza, su aplicación debería ser capaz de obtener el asunto con sólo inyectar un `SecurityIdentity` como sigue:"

#. type: Block title
#: upstream/_guides/security-built-in-authentication.adoc:68
#, no-wrap
msgid "Obtaining the subject"
msgstr "Obtención del sujeto"

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:73
#, no-wrap
msgid ""
"@Inject\n"
"SecurityIdentity identity;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:79
#, no-wrap
msgid ""
"@GET\n"
"@Produces(MediaType.TEXT_PLAIN)\n"
"public String hello() {\n"
"    return String.format(\"Hello, %s\", identity.getPrincipal().getName());\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:82
msgid "You should also be able to get the certificate as follows:"
msgstr "También debería poder obtener el certificado de la siguiente manera:"

#. type: Block title
#: upstream/_guides/security-built-in-authentication.adoc:84
#, no-wrap
msgid "Obtaining the certificate"
msgstr "Obtención del certificado"

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:89
#, no-wrap
msgid ""
"import java.security.cert.X509Certificate;\n"
"import io.quarkus.security.credential.CertificateCredential;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:92
#, no-wrap
msgid ""
"CertificateCredential credential = identity.getCredential(CertificateCredential.class);\n"
"X509Certificate certificate = credential.getCertificate();\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/security-built-in-authentication.adoc:94
#, no-wrap
msgid "Authorization"
msgstr "Autorización"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:98
#, fuzzy
msgid "The information from the client certificate can be used to enhance Quarkus `SecurityIdentity`. For example, one can add new roles after checking a client certificate subject name, and so on.  Please see the xref:security-customization.adoc#security-identity-customization[SecurityIdentity Customization] section for more information about customizing Quarkus `SecurityIdentity`."
msgstr "La información del certificado del cliente puede utilizarse para mejorar Quarkus `SecurityIdentity`. Por ejemplo, se pueden añadir nuevos roles después de comprobar el nombre del sujeto del certificado del cliente, etc. Consulte la sección xref:security-customization.html#security-identity-customization[Personalización de SecurityIdentity] para obtener más información sobre la personalización de Quarkus `SecurityIdentity`."

#. type: Title ==
#: upstream/_guides/security-built-in-authentication.adoc:100
#, no-wrap
msgid "Proactive Authentication"
msgstr "Autenticación proactiva"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:104
#, fuzzy
msgid "By default, Quarkus does what we call proactive authentication. This means that if an incoming request has a credential then that request will always be authenticated (even if the target page does not require authentication)."
msgstr "Por defecto Quarkus hace lo que llamamos autenticación proactiva. Esto significa que si una solicitud entrante tiene una credencial entonces esa solicitud siempre será autenticada (incluso si la página de destino no requiere autenticación)."

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:107
msgid "This means that requests with an invalid credential will always be rejected, even for public pages. You can change this behavior and only authenticate when required by setting `quarkus.http.auth.proactive=false`."
msgstr "Esto significa que las solicitudes con una credencial no válida siempre serán rechazadas, incluso para las páginas públicas. Puedes cambiar este comportamiento y autenticar sólo cuando se requiera configurando `quarkus.http.auth.proactive=false`."

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:111
msgid "If you disable proactive authentication then the authentication process will only be run when an identity is requested, either because there are security rules that requires the user to be authenticated, or due to programmatic access to the current identity."
msgstr "Si desactiva la autenticación proactiva, el proceso de autenticación sólo se ejecutará cuando se solicite una identidad, ya sea porque hay reglas de seguridad que requieren que el usuario se autentique, o debido al acceso programático a la identidad actual."

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:119
#, fuzzy
msgid "Note that if proactive authentication is in use accessing the `SecurityIdentity` is a blocking operation. This is because authentication may not have happened yet, and accessing it may require calls to external systems such as databases that may block. For blocking applications this is no problem, however if you have disabled authentication in a reactive application this will fail (as you cannot do blocking operations on the IO thread). To work around this you need to `@Inject` an instance of `io.quarkus.security.identity.CurrentIdentityAssociation`, and call the `Uni<SecurityIdentity> getDeferredIdentity();` method. You can then subscribe to the resulting `Uni` and will be notified when authentication is complete and the identity is available."
msgstr "Tenga en cuenta que si se utiliza la autenticación proactiva, el acceso a `SecurityIdentity` es una operación de bloqueo. Esto se debe a que la autenticación puede no haber ocurrido todavía, y el acceso puede requerir llamadas a sistemas externos como bases de datos que pueden bloquearse. Para las aplicaciones de bloqueo esto no es un problema, sin embargo, si has desactivado la autenticación en una aplicación reactiva esto fallará (ya que no puedes hacer operaciones de bloqueo en el hilo IO). Para solucionar esto, es necesario `@Inject` una instancia de `io.quarkus.security.identity.CurrentIdentityAssociation`, y llamar al método `Uni<SecurityIdentity>`. Entonces puedes suscribirte al `Uni` resultante y serás notificado cuando la autenticación se complete y la identidad esté disponible."

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:124
#, fuzzy
msgid "It's still possible to access the `SecurityIdentity` synchronously with `public SecurityIdentity getIdentity()` in the xref:resteasy-reactive.adoc[RESTEasy Reactive] from endpoints annotated with `@RolesAllowed`, `@Authenticated`, or with respective configuration authorization checks as authentication has already happened. The same is also valid for the xref:reactive-routes.adoc[Reactive routes] if a route response is synchronous."
msgstr "Sigue siendo posible acceder a `SecurityIdentity` de forma sincrónica con `public SecurityIdentity getIdentity()` en el  link:resteasy-reactive.html[RESTEasy Reactive] desde puntos finales anotados con `@RolesAllowed`, `@Authenticated`, o con las respectivas comprobaciones de autorización de la configuración, ya que la autenticación ya se ha producido. Lo mismo es válido para las  link:reactive-routes.html[rutas] Reactive si una respuesta de ruta es sincrónica."

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:128
#, fuzzy
msgid "xref:security-authorization.adoc#standard-security-annotations[Standard security annotations] on CDI beans are not supported on IO thread if a non-void secured method returns a value synchronously and proactive authentication is disabled, as they need to access the `SecurityIdentity`.  In the example below, we have defined `HelloResource` and `HelloService`. It's easy to see that any GET request to `/hello` will run on IO thread and throw `BlockingOperationNotAllowedException` exception.  There is more than one way to fix the example:"
msgstr "Las  link:security-authorization.html#standard-security-annotations[anotaciones de seguridad estándar] en los beans CDI no son compatibles con el hilo IO si un método asegurado no vacío devuelve un valor de forma sincrónica y la autenticación proactiva está deshabilitada, ya que necesitan acceder a la `SecurityIdentity`. En el ejemplo siguiente, hemos definido `HelloResource` y `HelloService`. Es fácil ver que cualquier petición GET a `/hello` se ejecutará en el hilo IO y lanzará la excepción `BlockingOperationNotAllowedException`. Hay más de una forma de arreglar el ejemplo:"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:130
#, fuzzy
msgid "switch to a worker thread (annotate `hello` endpoint with `@Blocking`)"
msgstr "cambiar a un hilo de trabajo (anotar `hello` endpoint con `@Blocking`)"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:131
#, fuzzy
msgid "change `sayHello` method return type (use reactive or asynchronous data type)"
msgstr "cambiar el tipo de retorno del método `sayHello` (utilizar un tipo de datos reactivo o asíncrono)"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:132
#, fuzzy
msgid "arguably the safest way is to move `@RolesAllowed` annotation to the endpoint, as accessing `SecurityIdentity` from endpoint methods is never the blocking operation"
msgstr "Podría decirse que la forma más segura es mover la anotación `@RolesAllowed` al punto final, ya que el acceso a `SecurityIdentity` desde los métodos del punto final nunca es una operación de bloqueo"

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:139
#, no-wrap
msgid ""
"import javax.annotation.security.PermitAll;\n"
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:141
#, no-wrap
msgid "import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:145
#, no-wrap
msgid ""
"@Path(\"/hello\")\n"
"@PermitAll\n"
"public class HelloResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:148
#, no-wrap
msgid ""
"    @Inject\n"
"    HelloService helloService;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:153
#, no-wrap
msgid ""
"    @GET\n"
"    public Uni<String> hello() {\n"
"        return Uni.createFrom().item(helloService.sayHello());\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:155
#: upstream/_guides/security-built-in-authentication.adoc:171
#, no-wrap
msgid "}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:161
#, no-wrap
msgid ""
"import javax.annotation.security.RolesAllowed;\n"
"import javax.enterprise.context.ApplicationScoped;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:164
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class HelloService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:169
#, no-wrap
msgid ""
"    @RolesAllowed(\"admin\")\n"
"    public String sayHello() {\n"
"        return \"Hello\";\n"
"    }\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/security-built-in-authentication.adoc:174
#, no-wrap
msgid "How to customize authentication exception responses"
msgstr "Cómo personalizar las respuestas de excepción de autenticación"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:177
#, fuzzy
msgid "By default, the authentication security constraints are enforced before the JAX-RS chain starts and only way to handle Quarkus Security authentication exceptions is to provide a failure handler like this one:"
msgstr "Por defecto, las restricciones de seguridad de autenticación se aplican antes de que la cadena JAX-RS se inicie y la única manera de manejar las excepciones de autenticación de Quarkus Security es proporcionar un controlador de fallos como este:"

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:181
#: upstream/_guides/security-built-in-authentication.adoc:213
#, no-wrap
msgid "package io.quarkus.it.keycloak;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:184
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.enterprise.event.Observes;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:189
#, no-wrap
msgid ""
"import io.quarkus.security.AuthenticationFailedException;\n"
"import io.vertx.core.Handler;\n"
"import io.vertx.ext.web.Router;\n"
"import io.vertx.ext.web.RoutingContext;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:192
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class AuthenticationFailedExceptionHandler {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:206
#, no-wrap
msgid ""
"    public void init(@Observes Router router) {\n"
"        router.route().failureHandler(new Handler<RoutingContext>() {\n"
"            @Override\n"
"            public void handle(RoutingContext event) {\n"
"                if (event.failure() instanceof AuthenticationFailedException) {\n"
"                    event.response().setStatusCode(401).end(CUSTOMIZED_RESPONSE);\n"
"                } else {\n"
"                    event.next();\n"
"                }\n"
"            }\n"
"        });\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:209
#, fuzzy
msgid "Disabling the proactive authentication effectively shifts this process to the moment when the JAX-RS chain starts running thus making it possible to use JAX-RS `ExceptionMapper` to capture Quarkus Security authentication exceptions such as `io.quarkus.security.AuthenticationFailedException`, for example:"
msgstr "Por defecto, las restricciones de seguridad de la autenticación se aplican antes de que se inicie la cadena JAX-RS. Desactivar la autenticación proactiva desplaza efectivamente este proceso al momento en que la cadena JAX-RS comienza a ejecutarse haciendo así posible el uso de JAX-RS `ExceptionMapper` para capturar excepciones de autenticación de Quarkus Security como `io.quarkus.security.AuthenticationFailedException`, por ejemplo:"

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:219
#, no-wrap
msgid ""
"import javax.annotation.Priority;\n"
"import javax.ws.rs.Priorities;\n"
"import javax.ws.rs.core.Response;\n"
"import javax.ws.rs.ext.ExceptionMapper;\n"
"import javax.ws.rs.ext.Provider;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:221
#, no-wrap
msgid "import io.quarkus.security.AuthenticationFailedException;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:225
#, no-wrap
msgid ""
"@Provider\n"
"@Priority(Priorities.AUTHENTICATION)\n"
"public class AuthenticationFailedExceptionMapper implements ExceptionMapper<AuthenticationFailedException> {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:228
#, no-wrap
msgid ""
"    @Context\n"
"    UriInfo uriInfo;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:234
#, no-wrap
msgid ""
"    @Override\n"
"    public Response toResponse(AuthenticationFailedException exception) {\n"
"        return Response.status(401).header(\"WWW-Authenticate\", \"Basic realm=\\\"Quarkus\\\"\").build();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/security-built-in-authentication.adoc:236
#, no-wrap
msgid "References"
msgstr "Referencias"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:238
msgid "xref:security.adoc[Quarkus Security]"
msgstr "xref:security.html[Seguridad Quarkus]"

#~ msgid "Basic Authentication"
#~ msgstr "Autenticación básica"

#, fuzzy
#~ msgid "HTTP Basic Authentication uses fields in the HTTP header and is the easiest to set up. Also, it is one of the least resource-demanding techniques that enforce access controls to the Web resources without requiring HTTP cookies, session identifiers, or login pages."
#~ msgstr "La autenticación básica HTTP utiliza campos en la cabecera HTTP y es la más fácil de configurar. Además, es una de las técnicas menos exigentes en cuanto a recursos, que impone controles de acceso a los recursos web sin requerir cookies HTTP, identificadores de sesión o páginas de inicio de sesión."

#, fuzzy
#~ msgid "In the context of an HTTP request, Basic authentication is a method for an HTTP user agent, such as a web browser, to provide a user name and password when creating a request. In Basic HTTP Authentication, a request contains a header field in the form of `Authorization: Basic <credentials>`, where credentials are the Base64 encoding of a user ID and password joined by a colon as described in the following example."
#~ msgstr "En el contexto de una solicitud HTTP, la autenticación básica es un método para que un agente de usuario HTTP, como un navegador web, proporcione un nombre de usuario y una contraseña al crear una solicitud. En la autenticación básica HTTP, una solicitud contiene un campo de cabecera en forma de `Authorization: Basic &amp;lt;credentials&amp;gt;`, donde las credenciales son la codificación Base64 de un ID de usuario y una contraseña unidos por dos puntos, como se describe en el siguiente ejemplo."

#, fuzzy
#~ msgid "Example"
#~ msgstr "Ejemplo"

#, fuzzy
#~ msgid "If the user name is `Alice` and the password is `secret`, the HTTP authorization header looks authorization as `Authorization: Basic QWxjZTpzZWNyZXQ=`, where `QWxjZTpzZWNyZXQ=` is a Base64 encoded representation of the `Alice:secret` string."
#~ msgstr "Si el nombre de usuario es `Alice` y la contraseña es `secret`, la cabecera de autorización HTTP se ve como `Authorization: Basic QWxjZTpzZWNyZXQ=`, donde `QWxjZTpzZWNyZXQ=` es una representación codificada en Base64 de la cadena `Alice:secret`."

#, fuzzy
#~ msgid "The Basic Authentication mechanism does not provide confidentiality protection for the transmitted credentials. The credentials are merely encoded with Base64 when in transit and not encrypted or hashed in any way. Therefore, Basic Authentication is used with HTTPS to provide confidentiality."
#~ msgstr "El mecanismo de autenticación básica no proporciona protección de la confidencialidad de las credenciales transmitidas. Las credenciales simplemente se codifican con Base64 cuando están en tránsito y no se encriptan ni se hace hash de ninguna manera. Por lo tanto, la autenticación básica se utiliza con HTTPS para proporcionar confidencialidad."

#, fuzzy
#~ msgid "Basic Authentication is a well-specified, simple challenge and response scheme that all web browsers and most web servers understand. However, there are a few limitations associated with Basic Authentication, which include:"
#~ msgstr "La autenticación básica es un esquema de desafío y respuesta simple y bien especificado que todos los navegadores y la mayoría de los servidores web entienden. Sin embargo, hay algunas limitaciones asociadas a la autenticación básica, que incluyen:"

#, fuzzy
#~ msgid "Credentials are sent as plain text"
#~ msgstr "Las credenciales se envían como texto plano"

#, fuzzy
#~ msgid "It is required to use HTTPS with Basic Authentication to avoid exposing the credentials. However, if the load balancer terminates HTTPS, the risk of exposing credentials as plain text increases when a request is forwarded to Quarkus over HTTP."
#~ msgstr "Es necesario utilizar HTTPS con autenticación básica para evitar la exposición de las credenciales. Sin embargo, si el equilibrador de carga termina HTTPS, el riesgo de exponer las credenciales como texto plano aumenta cuando se reenvía una solicitud a Quarkus a través de HTTP."

#, fuzzy
#~ msgid "Also, in multi-hop deployments, the credentials can be exposed if HTTPS is used between the client and the first Quarkus endpoint only, and the credentials are propagated to the next Quarkus endpoint over HTTP."
#~ msgstr "Además, en los despliegues de varios saltos, las credenciales pueden estar expuestas si se utiliza HTTPS entre el cliente y el primer punto final de Quarkus solamente, y las credenciales se propagan al siguiente punto final de Quarkus a través de HTTP."

#, fuzzy
#~ msgid "Credentials are sent with each request"
#~ msgstr "Las credenciales se envían con cada solicitud"

#, fuzzy
#~ msgid "In Basic Authentication, a username and password need to be sent with each request, which increases the risk of credentials being exposed."
#~ msgstr "En la autenticación básica, es necesario enviar un nombre de usuario y una contraseña con cada solicitud, lo que aumenta el riesgo de que las credenciales queden expuestas."

#, fuzzy
#~ msgid "Application complexity increases"
#~ msgstr "La complejidad de la aplicación aumenta"

#, fuzzy
#~ msgid "The Quarkus application needs to ensure itself that usernames, passwords, and roles are managed securely, which increases the application complexity."
#~ msgstr "La aplicación Quarkus necesita asegurarse de que los nombres de usuario, las contraseñas y los roles se gestionan de forma segura, lo que aumenta la complejidad de la aplicación."

#, fuzzy
#~ msgid "Enabling Basic Authentication"
#~ msgstr "Autenticación básica"

#, fuzzy
#~ msgid "Prerequisites"
#~ msgstr "Requisitos previos"

#, fuzzy
#~ msgid "You have installed at least one extension that provides an `IdentityProvider` based on username and password, such as xref:security-jdbc.adoc[Elytron JDBC]."
#~ msgstr "Para habilitar la autenticación básica configure `quarkus.http.auth.basic=true`. También debe tener instalada al menos una extensión que proporcione un nombre de usuario/contraseña basado en `IdentityProvider`, como xref:security-jdbc.html[Elytron JDBC]."

#, fuzzy
#~ msgid "Procedure"
#~ msgstr "Procedimiento"

#, fuzzy
#~ msgid "Enable Basic Authentication by setting the value of `quarkus.http.auth.basic` property to `true`."
#~ msgstr "Habilite la autenticación básica estableciendo el valor de la propiedad `quarkus.http.auth.basic` en `true`."

#, fuzzy
#~ msgid "For a Basic Authentication configuration walk-through that uses `JPA`, see the xref:security-getting-started.adoc[Getting Started With Security] guide."
#~ msgstr "Para ver un ejemplo de configuración de la Autenticación Básica que utiliza `JPA`, consulte la guía de  link:security-getting-started.html[Introducción a la Seguridad]."

#, fuzzy
#~ msgid "Additional resources"
#~ msgstr "Recursos adicionales"

#, fuzzy
#~ msgid "xref:security.adoc#identity-providers[Security Identity Providers]"
#~ msgstr "Para más información, consulte xref:security.html#identity-providers[Proveedores de Identidad de Seguridad]."

#, fuzzy
#~ msgid "xref:security-testing.adoc#configuring-user-information[Configuring User Information in application.properties]"
#~ msgstr "Consulte también la sección xref:security-testing.html#configuring-user-information[Configuración de la información del usuario en application.properties]."
