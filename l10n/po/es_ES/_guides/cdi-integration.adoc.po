# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-10-29 08:10+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/cdi-integration.adoc:6
#, fuzzy, no-wrap
msgid "CDI Integration Guide"
msgstr "Guía de integración CDI"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:19
#, fuzzy
msgid "ArC, the CDI container in Quarkus, is bootstrapped at build time.  To integrate with the container, https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#spi_lite[CDI Build Compatible Extensions, window=\"_blank\"] can be used, as well as a Quarkus-specific extension API.  CDI Portable Extensions are not and cannot be supported.  This guide focuses on the Quarkus-specific extensions API."
msgstr "ArC, el contenedor CDI de Quarkus, se inicia en el momento de la compilación. Para integrarse con el contenedor, se pueden utilizar  link:https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#spi_lite[Extensiones Compatibles con la Compilación CDI, window=_blank], así como una API de extensión específica de Quarkus. Las Extensiones Portátiles CDI no son y no pueden ser soportadas. Esta guía se centra en la API de extensiones específica de Quarkus."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:22
#, fuzzy
msgid "The container is bootstrapped in multiple phases.  From a high level perspective these phases go as follows:"
msgstr "El contenedor se arranca en varias fases. Desde una perspectiva de alto nivel, estas fases son las siguientes:"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:24
#, fuzzy
msgid "Initialization"
msgstr "Inicialización"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:25
#, fuzzy
msgid "Bean discovery"
msgstr "Descubrimiento de las judías"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:26
#, fuzzy
msgid "Registration of synthetic components"
msgstr "Registro de componentes sintéticos"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:27
#, fuzzy
msgid "Validation"
msgstr "Validación"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:34
#, fuzzy
msgid "In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.  _Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.  Subsequently, the extensions can register _synthetic components_.  Attributes of these components are fully controlled by the extensions, i.e. are not derived from an existing class.  Finally, the _deployment is validated_.  For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers."
msgstr "En la fase de _inicialización_ se realiza el trabajo preparatorio y se registran los contextos personalizados. A continuación, el _descubrimiento de_ beans es el proceso en el que el contenedor analiza todas las clases de la aplicación, identifica los beans y los enlaza todos en función de los metadatos proporcionados. Posteriormente, las extensiones pueden registrar _componentes sintéticos_. Los atributos de estos componentes están totalmente controlados por las extensiones, es decir, no derivan de una clase existente. Por último, _se valida el despliegue_. Por ejemplo, el contenedor valida cada punto de inyección en la aplicación y falla la compilación si no hay ningún bean que satisfaga el tipo y los calificadores requeridos."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:36
#, fuzzy
msgid "You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X` or `--debug` and grep the lines that contain `io.quarkus.arc`. In the xref:cdi-reference.adoc#dev-mode[development mode], you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format."
msgstr "Puedes ver más información sobre el bootstrap habilitando el registro adicional. Simplemente ejecuta la compilación de Maven con `-X` o `--debug` y grep las líneas que contienen `io.quarkus.arc`. En el  link:cdi-reference.html#dev-mode[modo de desarrollo], puedes usar `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` y también se registran automáticamente dos endpoints especiales para proporcionar alguna información básica de depuración en el formato JSON."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:39
#, fuzzy
msgid "Quarkus build steps can produce and consume various build items and hook into each phase.  In the following sections we will describe all the relevant build items and common scenarios."
msgstr "Los pasos de construcción de Quarkus pueden producir y consumir varios elementos de construcción y engancharse a cada fase. En las siguientes secciones describiremos todos los elementos de compilación relevantes y los escenarios comunes."

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:40
#, fuzzy, no-wrap
msgid "Metadata Sources"
msgstr "Fuentes de metadatos"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:47
#, fuzzy
msgid "Classes and annotations are the primary source of bean-level metadata.  The initial metadata are read from the _bean archive index_, an immutable https://github.com/wildfly/jandex[Jandex index, window=\"_blank\"] which is built from various sources during xref:cdi-reference.adoc#bean_discovery[bean discovery].  However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.  Moreover, extensions can also register xref:synthetic_beans[synthetic components].  This is an important aspect to realize when integrating CDI components in Quarkus."
msgstr "Las clases y las anotaciones son la fuente principal de metadatos a nivel de frijol. Los metadatos iniciales se leen del _índice del archivo de beans_, un  link:https://github.com/wildfly/jandex[índice, window=_blank] inmutable  link:https://github.com/wildfly/jandex[de Jandex, window=_blank] que se construye a partir de varias fuentes durante el  link:cdi-reference.html#bean_discovery[descubrimiento de los beans]. Sin embargo, las extensiones pueden añadir, eliminar o transformar los metadatos en ciertas etapas del bootstrap. Además, las extensiones también pueden registrar  link:#synthetic_beans[componentes sintéticos]. Este es un aspecto importante a tener en cuenta cuando se integran componentes CDI en Quarkus."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:50
#, fuzzy
msgid "This way, extensions can turn classes, that would be otherwise ignored, into beans and vice versa.  For example, a class that declares a `@Scheduled` method is always registered as a bean even if it is not annotated with a bean defining annotation and would be normally ignored."
msgstr "De este modo, las extensiones pueden convertir clases, que de otro modo serían ignoradas, en beans y viceversa. Por ejemplo, una clase que declara un método `@Scheduled` siempre se registra como un frijol aunque no esté anotada con una anotación de definición de frijol y que normalmente se ignoraría."

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:54
#, fuzzy, no-wrap
msgid "Use Case - My Class Is Not Recognized as a Bean"
msgstr "Caso de uso - Mi clase no es reconocida como un frijol"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:60
#, fuzzy
msgid "An `UnsatisfiedResolutionException` indicates a problem during xref:cdi.adoc#typesafe_resolution[typesafe resolution].  Sometimes an injection point cannot be satisfied even if there is a class on the classpath that appears to be eligible for injection.  There are several reasons why a class is not recognized and also several ways to fix it.  In the first step we should identify the _reason_."
msgstr "Un `UnsatisfiedResolutionException` indica un problema durante la  link:cdi.html#typesafe_resolution[resolución de tipos]. A veces no se puede satisfacer un punto de inyección incluso si hay una clase en el classpath que parece ser elegible para la inyección. Hay varias razones por las que una clase no es reconocida y también varias formas de solucionarlo. En el primer paso debemos identificar la _razón_."

#. type: Title ===
#: upstream/_guides/cdi-integration.adoc:62
#, fuzzy, no-wrap
msgid "_Reason 1_: Class Is Not discovered"
msgstr "_Razón 1_: No se descubre la clase"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:67
#, fuzzy
msgid "Quarkus has a xref:cdi-reference.adoc#bean_discovery[simplified discovery].  It might happen that the class is not part of the application index.  For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically."
msgstr "Quarkus tiene un  link:cdi-reference.html#bean_discovery[descubrimiento simplificado]. Puede ocurrir que la clase no forme parte del índice de la aplicación. Por ejemplo, las clases del _módulo de tiempo de ejecución_ de una extensión de Quarkus no se indexan automáticamente."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:71
#, fuzzy
msgid "_Solution_: Use the `AdditionalBeanBuildItem`.  This build item can be used to specify one or more additional classes to be analyzed during the discovery.  Additional bean classes are transparently added to the application index processed by the container."
msgstr "_Solución_: Utilizar el elemento de construcción `AdditionalBeanBuildItem`. Este elemento de construcción se puede utilizar para especificar una o más clases adicionales que se analizarán durante el descubrimiento. Las clases de bean adicionales se añaden de forma transparente al índice de aplicación procesado por el contenedor."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:73
#, fuzzy
msgid "It is not possible to conditionally enable/disable additional beans via the `@IfBuildProfile`, `@UnlessBuildProfile`, `@IfBuildProperty` and `@UnlessBuildProperty` annotations as described in xref:cdi-reference.adoc#enable_build_profile[Enabling Beans for Quarkus Build Profile] and xref:cdi-reference.adoc#enable_build_properties[Enabling Beans for Quarkus Build Properties]. Extensions should inspect the configuration or the current profile and only produce an `AdditionalBeanBuildItem` if really needed."
msgstr "No es posible habilitar/deshabilitar condicionalmente beans adicionales a través de las anotaciones `@IfBuildProfile`, `@UnlessBuildProfile`, `@IfBuildProperty` y `@UnlessBuildProperty` como se describe en  link:cdi-reference.html#enable_build_profile[cdi-reference.html] y  link:cdi-reference.html#enable_build_properties[cdi-reference.html]. Las extensiones deben inspeccionar la configuración o el perfil actual y sólo producir un `AdditionalBeanBuildItem` si es realmente necesario."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:74
#, fuzzy, no-wrap
msgid "`AdditionalBeanBuildItem` Example"
msgstr "`AdditionalBeanBuildItem` Ejemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:81
#, no-wrap
msgid ""
"@BuildStep\n"
"AdditionalBeanBuildItem additionalBeans() {\n"
"     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:83
#, fuzzy
msgid "`AdditionalBeanBuildItem.Builder` can be used for more complex use cases."
msgstr "`AdditionalBeanBuildItem.Builder` puede utilizarse para casos de uso más complejos."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:88
#, fuzzy
msgid "Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.  If the container considers them xref:cdi-reference.adoc#remove_unused_beans[unused], they are just ignored.  However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.  See also xref:cdi-reference.adoc#remove_unused_beans[Removing Unused Beans] and xref:unremovable_builditem[_Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed] for more details."
msgstr "Las clases de frijoles añadidas a través de `AdditionalBeanBuildItem` son _extraíbles_ por defecto. Si el contenedor las considera  link:cdi-reference.html#remove_unused_beans[no utilizadas], simplemente se ignoran. Sin embargo, puedes utilizar el método `AdditionalBeanBuildItem.Builder.setUnremovable()` para indicar al contenedor que nunca elimine las clases bean registradas a través de este elemento de compilación. Para más detalles, véase también  link:cdi-reference.html#remove_unused_beans[Eliminación de beans no] utilizados y  link:#unremovable_builditem[[unremovable_builditem]]."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:91
#, fuzzy
msgid "It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.  The default scope is only used if there is no scope declared on the bean class."
msgstr "También es posible establecer el ámbito por defecto a través de `AdditionalBeanBuildItem.Builder#setDefaultScope()`. El ámbito por defecto sólo se utiliza si no hay ningún ámbito declarado en la clase bean."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:93
#: upstream/_guides/cdi-integration.adoc:135
#, fuzzy
msgid "If no default scope is specified the `@Dependent` pseudo-scope is used."
msgstr "Si no se especifica ningún ámbito por defecto, se utiliza el pseudoámbito `@Dependent`."

#. type: Title ===
#: upstream/_guides/cdi-integration.adoc:94
#, fuzzy, no-wrap
msgid "_Reason 2_: Class Is Discovered but Has No Bean Defining Annotation"
msgstr "_Razón 2_: Se descubre la clase pero no tiene una anotación que defina el frijol"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:99
#, fuzzy
msgid "In Quarkus, the application is represented by a single bean archive with the https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].  Therefore, bean classes that don't have a https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.  Bean defining annotations are declared on the class-level and include scopes, stereotypes and `@Interceptor`."
msgstr "En Quarkus, la aplicación está representada por un único archivo de frijoles con el  link:https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#default_bean_discovery[modo de descubrimiento de frijoles `annotated`., window=_blank] Por lo tanto, las clases de frijoles que no tienen una anotación de definición de  link:https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#bean_defining_annotations[frijoles, window=_blank] son ignoradas. Las anotaciones que definen los beans se declaran a nivel de clase e incluyen ámbitos, estereotipos y `@Interceptor`."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:101
#, fuzzy
msgid "_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions."
msgstr "_Solución 1_: Utilizar el elemento de construcción `AutoAddScopeBuildItem`. Este elemento de construcción se puede utilizar para añadir un ámbito a una clase que cumpla ciertas condiciones."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:102
#, fuzzy, no-wrap
msgid "`AutoAddScopeBuildItem` Example"
msgstr "`AutoAddScopeBuildItem` Ejemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:111
#, no-wrap
msgid ""
"@BuildStep\n"
"AutoAddScopeBuildItem autoAddScope() {\n"
"   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n"
"      .defaultScope(BuiltinScope.SINGLETON) <2>\n"
"      .build();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:113
#, fuzzy
msgid "Find all classes annotated with `@Scheduled`."
msgstr "Encuentre todas las clases anotadas con `@Scheduled`."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:114
#, fuzzy
msgid "Add `@Singleton` as default scope. Classes already annotated with a scope are skipped automatically."
msgstr "Añadir `@Singleton` como ámbito por defecto. Las clases ya anotadas con un ámbito se omiten automáticamente."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:116
#, fuzzy
msgid "_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`."
msgstr "_Solución 2_: Si necesita procesar clases anotadas con una anotación específica, es posible ampliar el conjunto de anotaciones que definen los frijoles a través de `BeanDefiningAnnotationBuildItem`."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:117
#, fuzzy, no-wrap
msgid "`BeanDefiningAnnotationBuildItem` Example"
msgstr "`BeanDefiningAnnotationBuildItem` Ejemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:124
#, no-wrap
msgid ""
"@BuildStep\n"
"BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n"
"   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:126
#, fuzzy
msgid "Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations."
msgstr "Añade `org.eclipse.microprofile.graphql.GraphQLApi` al conjunto de anotaciones que definen los frijoles."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:130
#, fuzzy
msgid "Bean classes added via `BeanDefiningAnnotationBuildItem` are _not removable_ by default, i.e. the resulting beans must not be removed even if they are considered unused.  However, you can change the default behavior.  See also xref:cdi-reference.adoc#remove_unused_beans[Removing Unused Beans] and xref:unremovable_builditem[_Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed] for more details."
msgstr "Las clases de beans añadidas a través de `BeanDefiningAnnotationBuildItem` _no se pueden eliminar_ por defecto, es decir, los beans resultantes no deben ser eliminados aunque se consideren no utilizados. Sin embargo, puedes cambiar el comportamiento por defecto. Véase también  link:cdi-reference.html#remove_unused_beans[Eliminar] beans no utilizados y  link:#unremovable_builditem[[unremovable_builditem]] para más detalles."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:133
#, fuzzy
msgid "It is also possible to specify the default scope.  The default scope is only used if there is no scope declared on the bean class."
msgstr "También es posible especificar el ámbito por defecto. El ámbito por defecto sólo se utiliza si no hay ningún ámbito declarado en la clase bean."

#. type: Title ===
#: upstream/_guides/cdi-integration.adoc:137
#, fuzzy, no-wrap
msgid "_Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed"
msgstr "_Razón 3_: La clase fue descubierta y tiene una anotación de definición de frijoles pero fue eliminada"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:144
#, fuzzy
msgid "The container attempts to xref:cdi-reference.adoc#remove_unused_beans[remove all unused beans] during the build by default.  This optimization allows for _framework-level dead code elimination_.  In few special cases, it's not possible to correctly identify an unused bean.  In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.  Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`."
msgstr "El contenedor intenta  link:cdi-reference.html#remove_unused_beans[eliminar todos los beans no utilizados] durante la construcción por defecto. Esta optimización permite la _eliminación de código muerto a nivel de marco_. En algunos casos especiales, no es posible identificar correctamente un frijol no utilizado. En particular, Quarkus aún no es capaz de detectar el uso del método estático `CDI.current()`. Las extensiones pueden eliminar posibles falsos positivos produciendo un `UnremovableBeanBuildItem`."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:145
#, fuzzy, no-wrap
msgid "`UnremovableBeanBuildItem` Example"
msgstr "`UnremovableBeanBuildItem` Ejemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:152
#, no-wrap
msgid ""
"@BuildStep\n"
"UnremovableBeanBuildItem unremovableBeans() {\n"
"   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:154
#, fuzzy
msgid "Make all classes annotated with `@Startup` unremovable."
msgstr "Hacer que todas las clases anotadas con `@Startup` sean inamovibles."

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:155
#, fuzzy, no-wrap
msgid "Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding"
msgstr "Caso de uso - Mi anotación no es reconocida como un calificador o un enlace interceptor"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:159
#, fuzzy
msgid "It is likely that the annotation class is not part of the application index.  For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically."
msgstr "Es probable que la clase de anotación no forme parte del índice de la aplicación. Por ejemplo, las clases del _módulo de tiempo de ejecución_ de una extensión de Quarkus no se indexan automáticamente."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:161
#, fuzzy
msgid "_Solution_: Use the `AdditionalBeanBuildItem` as described in xref:additional_bean_build_item[_Reason 1_: Class Is Not discovered]."
msgstr "_Solución_: Utilizar el `AdditionalBeanBuildItem` como se describe en  link:#additional_bean_build_item[[additional_bean_build_item]]."

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:163
#, fuzzy, no-wrap
msgid "Use Case - I Need To Transform Annotation Metadata"
msgstr "Caso práctico - Necesito transformar los metadatos"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:168
#, fuzzy
msgid "In some cases, it's useful to be able to modify the annotation metadata.  Quarkus provides a powerful alternative to https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#process_annotated_type[`jakarta.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"] and https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#bce_enhancement[`jakarta.enterprise.inject.build.compatible.spi.Enhancement`, window=\"_blank\"].  With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes."
msgstr "En algunos casos, es útil poder modificar los metadatos. Quarkus ofrece una potente alternativa a  link:https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=_blank]. Con un `AnnotationsTransformerBuildItem` es posible anular las anotaciones que existen en las clases de frijoles."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:170
#, fuzzy
msgid "Keep in mind that annotation transformers must be produced _before_ the bean discovery starts."
msgstr "Tenga en cuenta que los transformadores de anotación deben producirse _antes de_ que se inicie el descubrimiento de frijoles."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:173
#, fuzzy
msgid "For example, you might want to add an interceptor binding to a specific bean class.  You can use a convenient builder-like API to create a transformer instance:"
msgstr "Por ejemplo, es posible que quieras añadir un interceptor vinculado a una clase bean específica. A continuación se explica cómo hacerlo:"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:175
#, fuzzy
msgid "Builder Example"
msgstr "`CustomScopeBuildItem` Ejemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:183
#, no-wrap
msgid ""
"@BuildStep\n"
"AnnotationsTransformerBuildItem transform() {\n"
"   return new AnnotationsTransformerBuildItem(AnnotationsTransformer.appliedToClass() <1>\n"
"        .whenClass(c -> c.name().toString().equals(\"org.acme.Bar\")) <2>\n"
"        .thenTransform(t -> t.add(MyInterceptorBinding.class))); <3>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:185
#: upstream/_guides/cdi-integration.adoc:210
#, fuzzy
msgid "The transformer is only applied to classes."
msgstr "El transformador sólo se aplica a las clases."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:186
#, fuzzy
msgid "Only apply the transformation if the class name equals to `org.acme.Bar`."
msgstr "Aplique la transformación sólo si el nombre de la clase es igual a `org.acme.Bar`."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:187
#, fuzzy
msgid "Add the `@MyInterceptorBinding` annotation."
msgstr "Añada la anotación `@MyInterceptorBinding`."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:189
#, fuzzy
msgid "The example above can be rewritten with an anonymous class:"
msgstr "El ejemplo anterior puede reescribirse con una clase anónima:"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:190
#, fuzzy, no-wrap
msgid "`AnnotationsTransformerBuildItem` Example"
msgstr "`AnnotationsTransformerBuildItem` Ejemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:196
#, no-wrap
msgid ""
"@BuildStep\n"
"AnnotationsTransformerBuildItem transform() {\n"
"   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:200
#, no-wrap
msgid ""
"      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n"
"         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n"
"      }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:208
#, no-wrap
msgid ""
"      public void transform(TransformationContext context) {\n"
"         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n"
"            context.transform().add(MyInterceptorBinding.class).done(); <2>\n"
"         }\n"
"      }\n"
"    });\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:211
#, fuzzy
msgid "If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`."
msgstr "Si el nombre de la clase es igual a `org.acme.Bar` entonces agregue `@MyInterceptorBinding`. No olvide invocar `Transformation#done()`."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:213
#, fuzzy
msgid "Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`."
msgstr "Los pasos de construcción pueden consultar las anotaciones transformadas para un objetivo de anotación determinado a través de `TransformedAnnotationsBuildItem`."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:214
#, fuzzy, no-wrap
msgid "`TransformedAnnotationsBuildItem` Example"
msgstr "`TransformedAnnotationsBuildItem` Ejemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:224
#, no-wrap
msgid ""
"@BuildStep\n"
"void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n"
"   ClassInfo myClazz = ...;\n"
"   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n"
"     myBuildItem.produce(new MyBuildItem());\n"
"   }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:226
#, fuzzy
msgid "`TransformedAnnotationsBuildItem.getAnnotations()` will return a possibly transformed set of annotations."
msgstr "`TransformedAnnotationsBuildItem.getAnnotations()` devolverá un conjunto de anotaciones posiblemente transformado."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:228
#, fuzzy
msgid "There are other build items specialized in transformation: xref:additional_interceptor_bindings[Use Case - Additional Interceptor Bindings] and xref:injection_point_transformation[Use Case - Injection Point Transformation]."
msgstr "Hay otros elementos de construcción especializados en la transformación:  link:#additional_interceptor_bindings[[additional_interceptor_bindings]] y  link:#injection_point_transformation[[injection_point_transformation]]."

#. type: Title ===
#: upstream/_guides/cdi-integration.adoc:229
#, fuzzy, no-wrap
msgid "How to Enable Trace Logging for Annotation Transformers"
msgstr "Cómo activar el registro de trazas para los transformadores de anotación"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:232
#, fuzzy
msgid "You can set the `TRACE` level for the category `io.quarkus.arc.processor` and try to analyze the log output afterwards."
msgstr "Puede establecer el nivel `TRACE` para la categoría `io.quarkus.arc.processor` e intentar analizar la salida del registro después."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:233
#, fuzzy, no-wrap
msgid "`application.properties` Example"
msgstr "`application.properties` Ejemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:238
#, no-wrap
msgid ""
"quarkus.log.category.\"io.quarkus.arc.processor\".min-level=TRACE <1>\n"
"quarkus.log.category.\"io.quarkus.arc.processor\".level=TRACE\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:240
#, fuzzy
msgid "You also need to adjust the minimum log level for the relevant category."
msgstr "También debe ajustar el nivel mínimo de registro para la categoría correspondiente."

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:242
#, fuzzy, no-wrap
msgid "Use Case - Inspect Beans, Observers and Injection Points"
msgstr "Caso de uso - Inspeccionar frijoles, observadores y puntos de inyección"

#. type: Title ===
#: upstream/_guides/cdi-integration.adoc:244
#, fuzzy, no-wrap
msgid "_Solution 1_: `BeanDiscoveryFinishedBuildItem`"
msgstr "_Solución 1_: `BeanDiscoveryFinishedBuildItem`"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:248
#, fuzzy
msgid "Consumers of `BeanDiscoveryFinishedBuildItem` can easily inspect all class-based beans, observers and injection points registered in the application.  However, synthetic beans and observers are _not included_ because this build item is produced _before_ the synthetic components are registered."
msgstr "Los consumidores de `BeanDiscoveryFinishedBuildItem` pueden inspeccionar fácilmente todos los beans basados en clases, observadores y puntos de inyección registrados en la aplicación. Sin embargo, los beans y observadores sintéticos _no se incluyen_ porque este elemento de compilación se produce _antes de_ que se registren los componentes sintéticos."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:250
#, fuzzy
msgid "Additionally, the bean resolver returned from `BeanDiscoveryFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out whether there is a bean that would satisfy certain combination of required type and qualifiers."
msgstr "Además, el bean resolver devuelto desde `BeanDiscoveryFinishedBuildItem#getBeanResolver()` puede utilizarse para aplicar las reglas de resolución de tipo seguro, por ejemplo, para averiguar si hay un bean que satisfaga cierta combinación de tipo y calificadores requeridos."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:251
#, fuzzy, no-wrap
msgid "`BeanDiscoveryFinishedBuildItem` Example"
msgstr "`BeanDiscoveryFinishedBuildItem` Ejemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:259
#, no-wrap
msgid ""
"@BuildStep\n"
"void doSomethingWithNamedBeans(BeanDiscoveryFinishedBuildItem beanDiscovery, BuildProducer<NamedBeansBuildItem> namedBeans) {\n"
"   List<BeanInfo> namedBeans = beanDiscovery.beanStream().withName().collect(toList())); <1>\n"
"   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:261
#, fuzzy
msgid "The resulting list will not contain `@Named` synthetic beans."
msgstr "La lista resultante no contendrá `@Named` frijoles sintéticos."

#. type: Title ===
#: upstream/_guides/cdi-integration.adoc:262
#, fuzzy, no-wrap
msgid "_Solution 2_: `SynthesisFinishedBuildItem`"
msgstr "_Solución 2_: `SynthesisFinishedBuildItem`"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:265
#, fuzzy
msgid "Consumers of `SynthesisFinishedBuildItem` can easily inspect all beans, observers and injection points registered in the application. Synthetic beans and observers are included because this build item is produced _after_ the synthetic components are registered."
msgstr "Los consumidores de `SynthesisFinishedBuildItem` pueden inspeccionar fácilmente todos los beans, observadores y puntos de inyección registrados en la aplicación. Los beans y observadores sintéticos se incluyen porque este elemento de compilación se produce _después de_ registrar los componentes sintéticos."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:267
#, fuzzy
msgid "Additionally, the bean resolver returned from `SynthesisFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out whether there is a bean that would satisfy certain combination of required type and qualifiers."
msgstr "Además, el bean resolver devuelto desde `SynthesisFinishedBuildItem#getBeanResolver()` puede utilizarse para aplicar las reglas de resolución de tipo seguro, por ejemplo, para averiguar si hay un bean que satisfaga cierta combinación de tipo y calificadores requeridos."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:268
#, fuzzy, no-wrap
msgid "`SynthesisFinishedBuildItem` Example"
msgstr "`SynthesisFinishedBuildItem` Ejemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:276
#, no-wrap
msgid ""
"@BuildStep\n"
"void doSomethingWithNamedBeans(SynthesisFinishedBuildItem synthesisFinished, BuildProducer<NamedBeansBuildItem> namedBeans) {\n"
"   List<BeanInfo> namedBeans = synthesisFinished.beanStream().withName().collect(toList())); <1>\n"
"   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:278
#, fuzzy
msgid "The resulting list will contain `@Named` synthetic beans."
msgstr "La lista resultante contendrá `@Named` frijoles sintéticos."

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:280
#, fuzzy, no-wrap
msgid "Use Case - The Need for Synthetic Beans"
msgstr "Caso práctico - La necesidad de judías sintéticas"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:286
#, fuzzy
msgid "Sometimes it is practical to be able to register a _synthetic bean_.  Bean attributes of a synthetic bean are not derived from a Java class, method or field.  Instead, all the attributes are defined by an extension.  In regular CDI, this could be achieved using the https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#after_bean_discovery[`AfterBeanDiscovery.addBean()`, window=\"_blank\"] and https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#bce_synthesis[`SyntheticComponents.addBean()`] methods."
msgstr "A veces es práctico poder registrar un bean _sintético_. Los atributos de un bean sintético no derivan de una clase, método o campo de Java. En su lugar, todos los atributos son definidos por una extensión. En el CDI normal, esto podría lograrse utilizando los  link:https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#after_bean_discovery[`AfterBeanDiscovery.addBean()`, window=_blank] métodos."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:288
#, fuzzy
msgid "_Solution_: If you need to register a synthetic bean then use the `SyntheticBeanBuildItem`."
msgstr "_Solución_: Si necesita registrar un frijol sintético, utilice el sitio web `SyntheticBeanBuildItem`."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:289
#, fuzzy, no-wrap
msgid "`SyntheticBeanBuildItem` Example 1"
msgstr "`SyntheticBeanBuildItem` Ejemplo 1"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:299
#, no-wrap
msgid ""
"@BuildStep\n"
"SyntheticBeanBuildItem syntheticBean() {\n"
"   return SyntheticBeanBuildItem.configure(String.class)\n"
"             .qualifiers(AnnotationInstance.builder(MyQualifier.class).build())\n"
"             .creator(mc -> mc.returnValue(mc.load(\"foo\"))) <1>\n"
"             .done();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:301
#, fuzzy
msgid "Generate the bytecode of the `jakarta.enterprise.context.spi.Contextual#create(CreationalContext<T>)` implementation."
msgstr "Generar el bytecode de la implementación de `javax.enterprise.context.spi.Contextual#create(CreationalContext&amp;lt;T&amp;gt;)`."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:305
#, fuzzy
msgid "The output of a bean configurator is recorded as bytecode.  Therefore, there are some limitations in how a synthetic bean instance is created at runtime.  You can:"
msgstr "La salida de un configurador de beans se registra como bytecode. Por lo tanto, hay algunas limitaciones en cómo se crea una instancia de bean sintético en tiempo de ejecución. Se puede:"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:307
#, fuzzy
msgid "Generate the bytecode of the `Contextual#create(CreationalContext<T>)` method directly via `ExtendedBeanConfigurator.creator(Consumer<MethodCreator>)`."
msgstr "Generar el bytecode del método `Contextual#create(CreationalContext&amp;lt;T&amp;gt;)` directamente a través de `ExtendedBeanConfigurator.creator(Consumer&amp;lt;MethodCreator&amp;gt;)`."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:308
#, fuzzy
msgid "Pass a subclass of `io.quarkus.arc.BeanCreator` via `ExtendedBeanConfigurator#creator(Class<? extends BeanCreator<U>>)`, and possibly specify some build-time parameters via `ExtendedBeanConfigurator#param()` and synthetic injection points via `ExtendedBeanConfigurator#addInjectionPoint()`."
msgstr "Pase una clase de implementación de `io.quarkus.arc.BeanCreator` a través de `ExtendedBeanConfigurator#creator(Class&amp;lt;? extends BeanCreator&amp;lt;U&amp;gt;&amp;gt;)`, y posiblemente especifique algunos parámetros a través de `ExtendedBeanConfigurator#param()`."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:309
#, fuzzy
msgid "Produce the runtime instance through a proxy returned from a xref:writing-extensions.adoc#bytecode-recording[`@Recorder` method] and set it via `ExtendedBeanConfigurator#runtimeValue(RuntimeValue<?>)`, `ExtendedBeanConfigurator#runtimeProxy(Object)`, `ExtendedBeanConfigurator#supplier(Supplier<?>)` or `ExtendedBeanConfigurator#createWith(Function<SyntheticCreationalContext<?>, <?>)`."
msgstr "Producir la instancia de tiempo de ejecución a través de un proxy devuelto desde un  link:writing-extensions.html#bytecode-recording[método `@Recorder`] y establecerlo a través de `ExtendedBeanConfigurator#runtimeValue(RuntimeValue&amp;lt;?&amp;gt;)` o `ExtendedBeanConfigurator#supplier(Supplier&amp;lt;?&amp;gt;)`."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:310
#, fuzzy, no-wrap
msgid "`SyntheticBeanBuildItem` Example 2"
msgstr "`SyntheticBeanBuildItem` Ejemplo 2"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:320
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(STATIC_INIT) <1>\n"
"SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n"
"   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n"
"                .runtimeValue(recorder.createFoo()) <2>\n"
"                .done();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:322
#, fuzzy
msgid "By default, a synthetic bean is initialized during `STATIC_INIT`."
msgstr "Por defecto, un frijol sintético se inicializa durante `STATIC_INIT`."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:323
#, fuzzy
msgid "The bean instance is supplied by a value returned from a recorder method."
msgstr "La instancia del frijol es suministrada por un valor devuelto por un método del registrador."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:326
#, fuzzy
msgid "It is possible to mark a synthetic bean to be initialized during `RUNTIME_INIT`.  See the xref:writing-extensions.adoc#bootstrap-three-phases[Three Phases of Bootstrap and Quarkus Philosophy] for more information about the difference between `STATIC_INIT` and `RUNTIME_INIT`."
msgstr "Es posible marcar un bean sintético para que sea inicializado durante `RUNTIME_INIT`. Véase la  link:writing-extensions.html#bootstrap-three-phases[Filosofía de las Tres Fases de Bootstrap y Quarkus] para más información sobre la diferencia entre `STATIC_INIT` y `RUNTIME_INIT`."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:327
#, fuzzy, no-wrap
msgid "`RUNTIME_INIT` `SyntheticBeanBuildItem` Example"
msgstr "`RUNTIME_INIT` `SyntheticBeanBuildItem` Ejemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:338
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(RUNTIME_INIT) <1>\n"
"SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n"
"   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n"
"                .setRuntimeInit() <2>\n"
"                .runtimeValue(recorder.createFoo())\n"
"                .done();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:340
#, fuzzy
msgid "The recorder must be executed in the `ExecutionTime.RUNTIME_INIT` phase."
msgstr "La grabadora debe ejecutarse en la fase `ExecutionTime.RUNTIME_INIT`."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:341
#: upstream/_guides/cdi-integration.adoc:384
#, fuzzy
msgid "The bean instance is initialized during `RUNTIME_INIT`."
msgstr "La instancia del bean se inicializa durante `RUNTIME_INIT`."

#. type: delimited block =
#: upstream/_guides/cdi-integration.adoc:345
#, fuzzy
msgid "Synthetic beans initialized during `RUNTIME_INIT` must not be accessed during `STATIC_INIT`. `RUNTIME_INIT` build steps that access a runtime-init synthetic bean should consume the `SyntheticBeansRuntimeInitBuildItem`:"
msgstr "Los beans sintéticos inicializados durante `RUNTIME_INIT` no deben ser accedidos durante `STATIC_INIT`. Los pasos de construcción de `RUNTIME_INIT` que accedan a un bean sintético iniciado en tiempo de ejecución deben consumir el `SyntheticBeansRuntimeInitBuildItem`:"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:354
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(RUNTIME_INIT)\n"
"@Consume(SyntheticBeansRuntimeInitBuildItem.class) <1>\n"
"void accessFoo(TestRecorder recorder) {\n"
"   recorder.foo(); <2>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:356
#, fuzzy
msgid "This build step must be executed after `syntheticBean()` completes."
msgstr "Este paso de construcción debe ejecutarse después de que se complete `syntheticBean()`."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:357
#, fuzzy
msgid "This recorder method results in an invocation upon the `Foo` bean instance and thus we need to make sure that the build step is executed after all synthetic beans are initialized."
msgstr "Este método de grabación resulta en una invocación sobre la instancia del bean `Foo` y por lo tanto necesitamos asegurarnos de que el paso de construcción se ejecute después de que todos los beans sintéticos sean inicializados."

#. type: delimited block =
#: upstream/_guides/cdi-integration.adoc:360
#, fuzzy
msgid "It is also possible to use the `BeanRegistrationPhaseBuildItem` to register a synthetic bean. However, we recommend extension authors to stick with `SyntheticBeanBuildItem` which is more idiomatic for Quarkus."
msgstr "También es posible utilizar el `BeanRegistrationPhaseBuildItem` para registrar un frijol sintético. Sin embargo, recomendamos a los autores de extensiones que se atengan a `SyntheticBeanBuildItem`, que es más idiomático para Quarkus."

#. type: Title ===
#: upstream/_guides/cdi-integration.adoc:361
#, fuzzy, no-wrap
msgid "Synthetic Injection Points"
msgstr "Puntos de inyección sintéticos"

#. type: delimited block =
#: upstream/_guides/cdi-integration.adoc:366
#, fuzzy
msgid "A synthetic bean may register a synthetic injection point via the `ExtendedBeanConfigurator#addInjectionPoint()` method.  This injection point is validated at build time and considered when xref:cdi-reference.adoc#remove_unused_beans[detecting unused beans].  The injected reference is accessible through the `SyntheticCreationalContext#getInjectedReference()` methods at runtime."
msgstr "Un frijol sintético puede registrar un punto de inyección sintético a través del método `ExtendedBeanConfigurator#addInjectionPoint()`. Este punto de inyección se valida en tiempo de compilación y se tiene en cuenta al  link:cdi-reference.html#remove_unused_beans[detectar beans no utilizados]. La referencia inyectada es accesible a través de los métodos `SyntheticCreationalContext#getInjectedReference()` en tiempo de ejecución."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:367
#, fuzzy, no-wrap
msgid "Synthetic Injection Point - Build Step Example"
msgstr "`SyntheticBeanBuildItem` Ejemplo 1"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:372
#, no-wrap
msgid ""
"import org.jboss.jandex.ClassType;\n"
"import org.jboss.jandex.DotName;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:382
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(RUNTIME_INIT) <1>\n"
"SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n"
"   return SyntheticBeanBuildItem.configure(Foo.class)\n"
"                .scope(Singleton.class)\n"
"                .addInjectionPoint(ClassType.create(DotName.createSimple(Bar.class))) <2>\n"
"                .createWith(recorder.createFoo()) <3>\n"
"                .done();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:385
#, fuzzy
msgid "A synthetic injection point with required type `Bar` was added; this is an equivalent of `@Inject Bar`."
msgstr "Se ha añadido un punto de inyección sintético con el tipo requerido `Bar`; es un equivalente de `@Inject Bar`."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:386
#, fuzzy
msgid "The bean instance is created with a function returned from a recorder method."
msgstr "La instancia del frijol es suministrada por un valor devuelto por un método del registrador."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:387
#, fuzzy, no-wrap
msgid "Synthetic Injection Point - Recorder Example"
msgstr "Punto de inyección sintética - Ejemplo de registrador"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:392
#, no-wrap
msgid ""
"@Recorder\n"
"public class TestRecorder {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:399
#, no-wrap
msgid ""
"   public Function<SyntheticCreationalContext<Foo>, Foo> createFoo() {\n"
"     return (context) -> {\n"
"        return new Foo(context.getInjectedReference(Bar.class)); <1>\n"
"     };\n"
"   }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:401
#, fuzzy
msgid "Pass a contextual reference of `Bar` to the constructor of `Foo`."
msgstr "Pasa una referencia contextual de `Bar` al constructor de `Foo`."

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:403
#, fuzzy, no-wrap
msgid "Use Case - Synthetic Observers"
msgstr "Caso práctico - Observadores sintéticos"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:406
#, fuzzy
msgid "Similar to xref:synthetic_beans[synthetic beans], the attributes of a synthetic observer method are not derived from a Java method. Instead, all the attributes are defined by an extension."
msgstr "Al igual que  link:#synthetic_beans[los beans sintéticos], los atributos de un método de observador sintético no se derivan de un método Java. En su lugar, todos los atributos son definidos por una extensión."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:408
#, fuzzy
msgid "_Solution_: If you need to register a synthetic observer, use the `ObserverRegistrationPhaseBuildItem`."
msgstr "_Solución_: Si necesita registrar un observador sintético, utilice la página web `ObserverRegistrationPhaseBuildItem`."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:410
#, fuzzy
msgid "A build step that consumes the `ObserverRegistrationPhaseBuildItem` should always produce an `ObserverConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase)."
msgstr "Un paso de compilación que consuma el `ObserverRegistrationPhaseBuildItem` debería producir siempre un `ObserverConfiguratorBuildItem` o al menos inyectar un `BuildProducer` para este elemento de compilación, de lo contrario podría ser ignorado o procesado en el momento equivocado (por ejemplo, después de la fase correcta de arranque del CDI)."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:411
#, fuzzy, no-wrap
msgid "`ObserverRegistrationPhaseBuildItem` Example"
msgstr "`ObserverRegistrationPhaseBuildItem` Ejemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:427
#, no-wrap
msgid ""
"@BuildStep\n"
"void syntheticObserver(ObserverRegistrationPhaseBuildItem observerRegistrationPhase,\n"
"            BuildProducer<MyBuildItem> myBuildItem,\n"
"            BuildProducer<ObserverConfiguratorBuildItem> observerConfigurationRegistry) {\n"
"   observerConfigurationRegistry.produce(new ObserverConfiguratorBuildItem(observerRegistrationPhase.getContext()\n"
"       .configure()\n"
"       .beanClass(DotName.createSimple(MyBuildStep.class.getName()))\n"
"       .observedType(String.class)\n"
"       .notify(mc -> {\n"
"           // do some gizmo bytecode generation...\n"
"       })));\n"
"   myBuildItem.produce(new MyBuildItem());\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:432
#, fuzzy
msgid "The output of a `ObserverConfigurator` is recorded as bytecode.  Therefore, there are some limitations in how a synthetic observer is invoked at runtime.  Currently, you must generate the bytecode of the method body directly."
msgstr "La salida de un `ObserverConfigurator` se registra como bytecode. Por lo tanto, existen algunas limitaciones en la forma de invocar un observador sintético en tiempo de ejecución. Actualmente, debe generar el bytecode del cuerpo del método directamente."

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:434
#, fuzzy, no-wrap
msgid "Use Case - I Have a Generated Bean Class"
msgstr "Caso de uso - Tengo una clase de frijol generada"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:438
#, fuzzy
msgid "No problem.  You can generate the bytecode of a bean class manually and then all you need to do is to produce a `GeneratedBeanBuildItem` instead of `GeneratedClassBuildItem`."
msgstr "No hay problema. Puedes generar el bytecode de una clase bean de forma manual y entonces todo lo que tienes que hacer es producir un `GeneratedBeanBuildItem` en lugar de `GeneratedClassBuildItem`."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:439
#, fuzzy, no-wrap
msgid "`GeneratedBeanBuildItem` Example"
msgstr "`GeneratedBeanBuildItem` Ejemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:451
#, no-wrap
msgid ""
"@BuildStep\n"
"void generatedBean(BuildProducer<GeneratedBeanBuildItem> generatedBeans) {\n"
"    ClassOutput beansClassOutput = new GeneratedBeanGizmoAdaptor(generatedBeans); <1>\n"
"    ClassCreator beanClassCreator = ClassCreator.builder().classOutput(beansClassOutput)\n"
"                .className(\"org.acme.MyBean\")\n"
"                .build();\n"
"    beanClassCreator.addAnnotation(Singleton.class);\n"
"    beanClassCreator.close(); <2>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:453
#, fuzzy
msgid "`io.quarkus.arc.deployment.GeneratedBeanGizmoAdaptor` makes it easy to produce ``GeneratedBeanBuildItem``s from Gizmo constructs."
msgstr "`io.quarkus.arc.deployment.GeneratedBeanGizmoAdaptor` facilita la producción de `GeneratedBeanBuildItem`s a partir de construcciones Gizmo."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:454
#, fuzzy
msgid "The resulting bean class is something like `public class @Singleton MyBean { }`."
msgstr "La clase de frijol resultante es algo así como `public class @Singleton MyBean { }`."

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:455
#, fuzzy, no-wrap
msgid "Use Case - I Need to Validate the Deployment"
msgstr "Caso práctico - Necesito validar la implantación"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:458
#, fuzzy
msgid "Sometimes extensions need to inspect the beans, observers and injection points, then perform additional validations and fail the build if something is wrong."
msgstr "A veces las extensiones necesitan inspeccionar los beans, observadores y puntos de inyección, y luego realizar validaciones adicionales y fallar la compilación si algo está mal."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:460
#, fuzzy
msgid "_Solution_: If an extension needs to validate the deployment it should use the `ValidationPhaseBuildItem`."
msgstr "_Solución_: Si una extensión necesita validar el despliegue debe utilizar la página web `ValidationPhaseBuildItem`."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:462
#, fuzzy
msgid "A build step that consumes the `ValidationPhaseBuildItem` should always produce a `ValidationErrorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase)."
msgstr "Un paso de compilación que consuma el `ValidationPhaseBuildItem` debería producir siempre un `ValidationErrorBuildItem` o al menos inyectar un `BuildProducer` para este elemento de compilación, de lo contrario podría ser ignorado o procesado en el momento equivocado (por ejemplo, después de la fase correcta de arranque del CDI)."

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:474
#, no-wrap
msgid ""
"@BuildStep\n"
"void validate(ValidationPhaseBuildItem validationPhase,\n"
"            BuildProducer<MyBuildItem> myBuildItem,\n"
"            BuildProducer<ValidationErrorBuildItem> errors) {\n"
"   if (someCondition) {\n"
"     errors.produce(new ValidationErrorBuildItem(new IllegalStateException()));\n"
"     myBuildItem.produce(new MyBuildItem());\n"
"   }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:477
#, fuzzy
msgid "You can easily filter all registered beans via the convenient `BeanStream` returned from the `ValidationPhaseBuildItem.getContext().beans()` method."
msgstr "Puede filtrar fácilmente todos los granos registrados a través de la práctica `BeanStream` devuelta por el método `ValidationPhaseBuildItem.getContext().beans()`."

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:479
#, fuzzy, no-wrap
msgid "Use Case - Register a Custom CDI Context"
msgstr "Caso de uso - Registrar un contexto CDI personalizado"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:482
#, fuzzy
msgid "Sometimes extensions need to extend the set of built-in CDI contexts."
msgstr "A veces las extensiones necesitan ampliar el conjunto de contextos CDI incorporados."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:484
#, fuzzy
msgid "_Solution_: If you need to register a custom context, use the `ContextRegistrationPhaseBuildItem`."
msgstr "_Solución_: Si necesita registrar un contexto personalizado, utilice la página web `ContextRegistrationPhaseBuildItem`."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:486
#, fuzzy
msgid "A build step that consumes the `ContextRegistrationPhaseBuildItem` should always produce a `ContextConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase)."
msgstr "Un paso de compilación que consuma el `ContextRegistrationPhaseBuildItem` debería producir siempre un `ContextConfiguratorBuildItem` o al menos inyectar un `BuildProducer` para este elemento de compilación, de lo contrario podría ser ignorado o procesado en el momento equivocado (por ejemplo, después de la fase correcta de arranque del CDI)."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:488
#, fuzzy
msgid "`ContextRegistrationPhaseBuildItem` Example"
msgstr "`ContextRegistrationPhaseBuildItem` Ejemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:494
#, no-wrap
msgid ""
"@BuildStep\n"
"ContextConfiguratorBuildItem registerContext(ContextRegistrationPhaseBuildItem phase) {\n"
"      return new ContextConfiguratorBuildItem(phase.getContext().configure(TransactionScoped.class).normal().contextClass(TransactionContext.class));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:497
#, fuzzy
msgid "Additionally, each extension that registers a custom CDI context via `ContextRegistrationPhaseBuildItem` should also produce the `CustomScopeBuildItem` in order to contribute the custom scope annotation name to the set of bean defining annotations."
msgstr "Además, cada extensión que registre un contexto CDI personalizado a través de `ContextRegistrationPhaseBuildItem` también debe producir el `CustomScopeBuildItem` para contribuir con el nombre de la anotación del ámbito personalizado al conjunto de anotaciones que definen los frijoles."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:499
#, fuzzy
msgid "`CustomScopeBuildItem` Example"
msgstr "`CustomScopeBuildItem` Ejemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:505
#, no-wrap
msgid ""
"@BuildStep\n"
"CustomScopeBuildItem customScope() {\n"
"   return new CustomScopeBuildItem(DotName.createSimple(TransactionScoped.class.getName()));\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/cdi-integration.adoc:507
#, fuzzy, no-wrap
msgid "What if I Need to Know All the Scopes Used in the Application?"
msgstr "¿Y si necesito conocer todos los ámbitos utilizados en la aplicación?"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:510
#, fuzzy
msgid "_Solution_: You can inject the `CustomScopeAnnotationsBuildItem` in a build step and use the convenient methods such as `CustomScopeAnnotationsBuildItem.isScopeDeclaredOn()`."
msgstr "_Solución_: Puede inyectar el `CustomScopeAnnotationsBuildItem` en un paso de construcción y utilizar los métodos convenientes como `CustomScopeAnnotationsBuildItem.isScopeDeclaredOn()`."

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:512
#, fuzzy, no-wrap
msgid "Use Case - Additional Interceptor Bindings"
msgstr "Caso de uso - Enlaces de intercepción adicionales"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:517
#, fuzzy
msgid "In rare cases it might be handy to programmatically register an existing annotation that is not annotated with `@jakarta.interceptor.InterceptorBinding` as an interceptor binding.  This is similar to what CDI achieves through `BeforeBeanDiscovery#addInterceptorBinding()`.  We are going to use `InterceptorBindingRegistrarBuildItem` to get it done."
msgstr "En raras ocasiones puede ser útil registrar mediante programación una anotación existente que no esté anotada con `@javax.interceptor.InterceptorBinding` como enlace interceptor. Esto es similar a lo que consigue CDI a través de `BeforeBeanDiscovery#addInterceptorBinding()`. Vamos a utilizar `InterceptorBindingRegistrarBuildItem` para conseguirlo."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:518
#, fuzzy, no-wrap
msgid "`InterceptorBindingRegistrarBuildItem` Example"
msgstr "`InterceptorBindingRegistrarBuildItem` Ejemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:530
#, no-wrap
msgid ""
"@BuildStep\n"
"InterceptorBindingRegistrarBuildItem addInterceptorBindings() {\n"
"    return new InterceptorBindingRegistrarBuildItem(new InterceptorBindingRegistrar() {\n"
"        @Override\n"
"        public List<InterceptorBinding> getAdditionalBindings() {\n"
"            return List.of(InterceptorBinding.of(NotAnInterceptorBinding.class));\n"
"        }\n"
"    });\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:532
#, fuzzy, no-wrap
msgid "Use Case - Additional Qualifiers"
msgstr "Caso práctico - Calificadores adicionales"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:537
#, fuzzy
msgid "Sometimes it might be useful to register an existing annotation that is not annotated with `@jakarta.inject.Qualifier` as a CDI qualifier.  This is similar to what CDI achieves through `BeforeBeanDiscovery#addQualifier()`.  We are going to use `QualifierRegistrarBuildItem` to get it done."
msgstr "A veces puede ser útil registrar una anotación existente que no está anotada con `@javax.inject.Qualifier` como un calificador CDI. Esto es similar a lo que el CDI consigue a través de `BeforeBeanDiscovery#addQualifier()`. Vamos a utilizar `QualifierRegistrarBuildItem` para conseguirlo."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:538
#, fuzzy, no-wrap
msgid "`QualifierRegistrarBuildItem` Example"
msgstr "`QualifierRegistrarBuildItem` Ejemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:551
#, no-wrap
msgid ""
"@BuildStep\n"
"QualifierRegistrarBuildItem addQualifiers() {\n"
"    return new QualifierRegistrarBuildItem(new QualifierRegistrar() {\n"
"        @Override\n"
"        public Map<DotName, Set<String>> getAdditionalQualifiers() {\n"
"            return Collections.singletonMap(DotName.createSimple(NotAQualifier.class.getName()),\n"
"                                        Collections.emptySet());\n"
"        }\n"
"    });\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:553
#, fuzzy, no-wrap
msgid "Use Case - Additional Stereotypes"
msgstr "Caso práctico - Calificadores adicionales"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:558
#, fuzzy
msgid "It is sometimes useful to register an existing annotation that is not annotated with `@jakarta.enterprise.inject.Stereotype` as a CDI stereotype.  This is similar to what CDI achieves through `BeforeBeanDiscovery#addStereotype()`.  We are going to use `StereotypeRegistrarBuildItem` to get it done."
msgstr "A veces puede ser útil registrar una anotación existente que no está anotada con `@javax.inject.Qualifier` como un calificador CDI. Esto es similar a lo que el CDI consigue a través de `BeforeBeanDiscovery#addQualifier()`. Vamos a utilizar `QualifierRegistrarBuildItem` para conseguirlo."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:559
#, fuzzy, no-wrap
msgid "`StereotypeRegistrarBuildItem` Example"
msgstr "`QualifierRegistrarBuildItem` Ejemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:571
#, no-wrap
msgid ""
"@BuildStep\n"
"StereotypeRegistrarBuildItem addStereotypes() {\n"
"    return new StereotypeRegistrarBuildItem(new StereotypeRegistrar() {\n"
"        @Override\n"
"        public Set<DotName> getAdditionalStereotypes() {\n"
"            return Collections.singleton(DotName.createSimple(NotAStereotype.class.getName()));\n"
"        }\n"
"    });\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:574
#, fuzzy
msgid "If the newly registered stereotype annotation doesn't have the appropriate meta-annotations, such as scope or interceptor bindings, use an xref:annotations_transformer_build_item[annotation transformation] to add them."
msgstr "Si la anotación de estereotipo recién registrada no tiene las meta-anotaciones apropiadas, como los enlaces de alcance o interceptor, utilice una  link:#annotations_transformer_build_item[transformación de anotación] para añadirlas."

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:576
#, fuzzy, no-wrap
msgid "Use Case - Injection Point Transformation"
msgstr "Caso práctico - Transformación del punto de inyección"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:581
#, fuzzy
msgid "Every now and then it is handy to be able to change the qualifiers of an injection point programmatically.  You can do just that with `InjectionPointTransformerBuildItem`.  The following sample shows how to apply transformation to injection points with type `Foo` that contain qualifier `MyQualifier`:"
msgstr "De vez en cuando es útil poder cambiar los calificadores de un punto de inyección mediante programación. Eso es lo que se puede hacer con `InjectionPointTransformerBuildItem`. El siguiente ejemplo muestra cómo aplicar la transformación a los puntos de inyección de tipo `Foo` que contienen el calificador `MyQualifier`:"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:582
#, fuzzy, no-wrap
msgid "`InjectionPointTransformerBuildItem` Example"
msgstr "`InjectionPointTransformerBuildItem` Ejemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:588
#, no-wrap
msgid ""
"@BuildStep\n"
"InjectionPointTransformerBuildItem transformer() {\n"
"    return new InjectionPointTransformerBuildItem(new InjectionPointsTransformer() {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:592
#, no-wrap
msgid ""
"        public boolean appliesTo(Type requiredType) {\n"
"            return requiredType.name().equals(DotName.createSimple(Foo.class.getName()));\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:604
#, no-wrap
msgid ""
"        public void transform(TransformationContext context) {\n"
"            if (context.getQualifiers().stream()\n"
"                    .anyMatch(a -> a.name().equals(DotName.createSimple(MyQualifier.class.getName())))) {\n"
"                context.transform()\n"
"                        .removeAll()\n"
"                        .add(DotName.createSimple(MyOtherQualifier.class.getName()))\n"
"                        .done();\n"
"            }\n"
"        }\n"
"    });\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:607
#, fuzzy
msgid "In theory, you can use xref:annotations_transformer_build_item[an `AnnotationsTransformer`] to achieve the same goal. However, there are few differences that make `InjectionPointsTransformer` more suitable for this particular task: (1) annotation transformers are applied to all classes during bean discovery, whereas `InjectionPointsTransformer` is only applied to discovered injection points after bean discovery; (2) with `InjectionPointsTransformer` you don't need to handle various types of injection points (field, parameters of initializer methods, etc.)."
msgstr "En teoría, se puede utilizar  link:#annotations_transformer_build_item[un `AnnotationsTransformer`] para lograr el mismo objetivo. Sin embargo, hay algunas diferencias que hacen que `InjectionPointsTransformer` sea más adecuado para esta tarea en particular: (1) los transformadores de anotación se aplican a todas las clases durante el descubrimiento de los beans, mientras que `InjectionPointsTransformer` sólo se aplica a los puntos de inyección descubiertos después del descubrimiento de los beans; (2) con `InjectionPointsTransformer` no es necesario manejar varios tipos de puntos de inyección (campo, parámetros de métodos inicializadores, etc.)."

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:608
#, fuzzy, no-wrap
msgid "Use Case - Resource Annotations and Injection"
msgstr "Caso práctico - Anotaciones de recursos e inyección"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:612
#, fuzzy
msgid "The `ResourceAnnotationBuildItem` can be used to specify resource annotations that make it possible to resolve non-CDI injection points, such as Jakarta EE resources.  An integrator must also provide a corresponding `io.quarkus.arc.ResourceReferenceProvider` service provider implementation."
msgstr "El `ResourceAnnotationBuildItem` puede ser utilizado para especificar anotaciones de recursos que hacen posible resolver puntos de inyección no-CDI, como los recursos de Jakarta EE. Un integrador también debe proporcionar la correspondiente implementación del proveedor de servicios `io.quarkus.arc.ResourceReferenceProvider`."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:613
#, fuzzy, no-wrap
msgid "`ResourceAnnotationBuildItem` Example"
msgstr "`ResourceAnnotationBuildItem` Ejemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:622
#, no-wrap
msgid ""
"@BuildStep\n"
"void setupResourceInjection(BuildProducer<ResourceAnnotationBuildItem> resourceAnnotations, BuildProducer<GeneratedResourceBuildItem> resources) {\n"
"    resources.produce(new GeneratedResourceBuildItem(\"META-INF/services/io.quarkus.arc.ResourceReferenceProvider\",\n"
"        MyResourceReferenceProvider.class.getName().getBytes()));\n"
"    resourceAnnotations.produce(new ResourceAnnotationBuildItem(DotName.createSimple(MyAnnotation.class.getName())));\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:625
#, fuzzy, no-wrap
msgid "Available Build Time Metadata"
msgstr "Metadatos de tiempo de construcción disponibles"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:629
#, fuzzy
msgid "Any of the above extensions that operates with `BuildExtension.BuildContext` can leverage certain build time metadata that are generated during build.  The built-in keys located in `io.quarkus.arc.processor.BuildExtension.Key` are:"
msgstr "Cualquiera de las extensiones anteriores que opera con `BuildExtension.BuildContext` puede aprovechar ciertos metadatos de tiempo de compilación que se generan durante la misma. Las claves incorporadas ubicadas en `io.quarkus.arc.processor.BuildExtension.Key` son:"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:630
#, fuzzy, no-wrap
msgid "ANNOTATION_STORE"
msgstr "ALMACÉN_DE_ANOTACIONES"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:631
#, fuzzy
msgid "Contains an `AnnotationStore` that keeps information about all `AnnotationTarget` annotations after application of annotation transformers"
msgstr "Contiene un `AnnotationStore` que mantiene la información sobre todas las anotaciones de `AnnotationTarget` tras la aplicación de los transformadores de anotaciones"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:631
#, fuzzy, no-wrap
msgid "INJECTION_POINTS"
msgstr "PUNTOS_DE_INYECCIÓN"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:632
#, fuzzy
msgid "`Collection<InjectionPointInfo>` containing all injection points"
msgstr "`Collection&amp;lt;InjectionPointInfo&amp;gt;` que contiene todos los puntos de inyección"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:632
#, fuzzy, no-wrap
msgid "BEANS"
msgstr "FRIJOLES"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:633
#, fuzzy
msgid "`Collection<BeanInfo>` containing all beans"
msgstr "`Collection&amp;lt;BeanInfo&amp;gt;` que contiene todas las judías"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:633
#, fuzzy, no-wrap
msgid "REMOVED_BEANS"
msgstr "FRIJOLES_REMOVIDOS"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:634
#, fuzzy
msgid "`Collection<BeanInfo>` containing all the removed beans; see xref:cdi-reference.adoc#remove_unused_beans[Removing unused beans] for more information"
msgstr "`Collection&amp;lt;BeanInfo&amp;gt;` que contiene todos los granos eliminados; para más información, consulte  link:cdi-reference.html#remove_unused_beans[Eliminar los granos no utilizados]"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:634
#, fuzzy, no-wrap
msgid "OBSERVERS"
msgstr "OBSERVADORES"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:635
#, fuzzy
msgid "`Collection<ObserverInfo>` containing all observers"
msgstr "`Collection&amp;lt;ObserverInfo&amp;gt;` que contiene todos los observadores"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:635
#, fuzzy, no-wrap
msgid "SCOPES"
msgstr "SCOPES"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:636
#, fuzzy
msgid "`Collection<ScopeInfo>` containing all scopes, including custom ones"
msgstr "`Collection&amp;lt;ScopeInfo&amp;gt;` que contiene todos los ámbitos, incluidos los personalizados"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:636
#, fuzzy, no-wrap
msgid "QUALIFIERS"
msgstr "CALIFICADORES"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:637
#, fuzzy
msgid "`Map<DotName, ClassInfo>` containing all qualifiers"
msgstr "`Map&amp;lt;DotName, ClassInfo&amp;gt;` que contiene todos los calificativos"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:637
#, fuzzy, no-wrap
msgid "INTERCEPTOR_BINDINGS"
msgstr "INTERCEPTOR_BINDINGS"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:638
#, fuzzy
msgid "`Map<DotName, ClassInfo>` containing all interceptor bindings"
msgstr "`Map&amp;lt;DotName, ClassInfo&amp;gt;` que contiene todos los enlaces del interceptor"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:638
#, fuzzy, no-wrap
msgid "STEREOTYPES"
msgstr "ESTEREOTIPOS"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:639
#, fuzzy
msgid "`Map<DotName, StereotypeInfo>` containing all stereotypes"
msgstr "`Map&amp;lt;DotName, StereotypeInfo&amp;gt;` que contiene todos los estereotipos"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:644
#, fuzzy
msgid "To get hold of these, simply query the extension context object for given key.  Note that these metadata are made available as build proceeds which means that extensions can only leverage metadata that were built before the extensions are invoked.  If your extension attempts to retrieve metadata that wasn't yet produced, `null` will be returned.  Here is a summary of which extensions can access which metadata:"
msgstr "Para obtenerlos, basta con consultar el objeto de contexto de la extensión para una clave determinada. Tenga en cuenta que estos metadatos están disponibles a medida que se produce la construcción, lo que significa que las extensiones sólo pueden aprovechar los metadatos que se construyeron antes de que las extensiones sean invocadas. Si su extensión intenta recuperar metadatos que aún no se han producido, se devolverá `null`. A continuación se muestra un resumen de qué extensiones pueden acceder a qué metadatos:"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:645
#, fuzzy, no-wrap
msgid "AnnotationsTransformer"
msgstr "AnotacionesTransformador"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:646
#, fuzzy
msgid "Shouldn't rely on any metadata as it could be used at any time in any phase of the bootstrap"
msgstr "No debería depender de ningún metadato, ya que podría utilizarse en cualquier momento en cualquier fase del arranque"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:646
#, fuzzy, no-wrap
msgid "ContextRegistrar"
msgstr "ContextRegistrar"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:647
#: upstream/_guides/cdi-integration.adoc:648
#: upstream/_guides/cdi-integration.adoc:649
#, fuzzy
msgid "Has access to `ANNOTATION_STORE`, `QUALIFIERS`, `INTERCEPTOR_BINDINGS`, `STEREOTYPES`"
msgstr "Tiene acceso a `ANNOTATION_STORE`, `QUALIFIERS`, `INTERCEPTOR_BINDINGS`, `STEREOTYPES`"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:647
#, fuzzy, no-wrap
msgid "InjectionPointsTransformer"
msgstr "InjectionPointsTransformer"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:648
#, fuzzy, no-wrap
msgid "ObserverTransformer"
msgstr "ObservadorTransformador"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:649
#, fuzzy, no-wrap
msgid "BeanRegistrar"
msgstr "BeanRegistrar"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:650
#, fuzzy
msgid "Has access to `ANNOTATION_STORE`, `QUALIFIERS`, `INTERCEPTOR_BINDINGS`, `STEREOTYPES`, `BEANS` (class-based beans only), `OBSERVERS` (class-based observers only), `INJECTION_POINTS`"
msgstr "Tiene acceso a `ANNOTATION_STORE`, `QUALIFIERS`, `INTERCEPTOR_BINDINGS`, `STEREOTYPES`, `BEANS` (sólo beans basados en clases), `OBSERVERS` (sólo observadores basados en clases), `INJECTION_POINTS`"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:650
#, fuzzy, no-wrap
msgid "ObserverRegistrar"
msgstr "ObservadorRegistrador"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:651
#, fuzzy
msgid "Has access to `ANNOTATION_STORE`, `QUALIFIERS`, `INTERCEPTOR_BINDINGS`, `STEREOTYPES`, `BEANS`, `OBSERVERS` (class-based observers only), `INJECTION_POINTS`"
msgstr "Tiene acceso a `ANNOTATION_STORE`, `QUALIFIERS`, `INTERCEPTOR_BINDINGS`, `STEREOTYPES`, `BEANS`, `OBSERVERS` (sólo observadores de clase), `INJECTION_POINTS`"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:651
#, fuzzy, no-wrap
msgid "BeanDeploymentValidator"
msgstr "BeanDeploymentValidator"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:651
#, fuzzy
msgid "Has access to all build metadata"
msgstr "Tiene acceso a todos los metadatos de construcción"

#, fuzzy
#~ msgid "ArC, the CDI container, is bootstrapped at build time.  The downside of this approach is that CDI Portable Extensions cannot be supported.  Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API."
#~ msgstr "ArC, el contenedor CDI, se arranca en tiempo de construcción. La desventaja de este enfoque es que las extensiones portátiles CDI no pueden ser soportadas. Sin embargo, la funcionalidad puede lograrse utilizando la API de extensiones específica de Quarkus."
