# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-10-29 08:10+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/kafka.adoc:6
#, fuzzy, no-wrap
msgid "Apache Kafka Reference Guide"
msgstr "Guía de referencia de Apache Kafka"

#. type: Plain text
#: upstream/_guides/kafka.adoc:17
#, fuzzy
msgid "This reference guide demonstrates how your Quarkus application can utilize SmallRye Reactive Messaging to interact with Apache Kafka."
msgstr "Esta guía de referencia demuestra cómo su aplicación Quarkus puede utilizar SmallRye Reactive Messaging para interactuar con Apache Kafka."

#. type: Title ==
#: upstream/_guides/kafka.adoc:18
#, fuzzy, no-wrap
msgid "Introduction"
msgstr "Introducción"

#. type: Plain text
#: upstream/_guides/kafka.adoc:23
#, fuzzy
msgid "https://kafka.apache.org[Apache Kafka] is a popular open-source distributed event streaming platform.  It is used commonly for high-performance data pipelines, streaming analytics, data integration, and mission-critical applications.  Similar to a message queue, or an enterprise messaging platform, it lets you:"
msgstr "link:https://kafka.apache.org[Apache Kafka] es una popular plataforma de streaming de eventos distribuidos de código abierto. Se utiliza comúnmente para pipelines de datos de alto rendimiento, análisis de streaming, integración de datos y aplicaciones de misión crítica. Es similar a una cola de mensajes, o a una plataforma de mensajería empresarial, y le permite:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:25
#, fuzzy, no-wrap
msgid "*publish* (write) and *subscribe* to (read) streams of events, called _records_.\n"
msgstr "*publican* (escriben) y *se suscriben* (leen) a flujos de eventos, llamados _registros_."

#. type: Plain text
#: upstream/_guides/kafka.adoc:26
#, fuzzy, no-wrap
msgid "*store* streams of records durably and reliably inside _topics_.\n"
msgstr "*almacenar* flujos de registros de forma duradera y fiable dentro de _los temas_."

#. type: Plain text
#: upstream/_guides/kafka.adoc:27
#, fuzzy, no-wrap
msgid "*process* streams of records as they occur or retrospectively.\n"
msgstr "*procesar* flujos de registros a medida que se producen o de forma retrospectiva."

#. type: Plain text
#: upstream/_guides/kafka.adoc:29
#, fuzzy
msgid "And all this functionality is provided in a distributed, highly scalable, elastic, fault-tolerant, and secure manner."
msgstr "Y toda esta funcionalidad se proporciona de forma distribuida, altamente escalable, elástica, tolerante a fallos y segura."

#. type: Title ==
#: upstream/_guides/kafka.adoc:30
#, fuzzy, no-wrap
msgid "Quarkus Extension for Apache Kafka"
msgstr "Extensión de Quarkus para Apache Kafka"

#. type: Plain text
#: upstream/_guides/kafka.adoc:34
#, fuzzy
msgid "Quarkus provides support for Apache Kafka through https://smallrye.io/smallrye-reactive-messaging/[SmallRye Reactive Messaging] framework.  Based on Eclipse MicroProfile Reactive Messaging specification 2.0, it proposes a flexible programming model bridging CDI and event-driven."
msgstr "Quarkus proporciona soporte para Apache Kafka a través del marco de trabajo  link:https://smallrye.io/smallrye-reactive-messaging/[SmallRye Reactive Mess] aging. Basado en la especificación 2.0 de Eclipse MicroProfile Reactive Messaging, propone un modelo de programación flexible que tiende un puente entre la CDI y la gestión de eventos."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:39
#, fuzzy
msgid "This guide provides an in-depth look on Apache Kafka and SmallRye Reactive Messaging framework.  For a quick start take a look at xref:kafka-reactive-getting-started.adoc[Getting Started to SmallRye Reactive Messaging with Apache Kafka]."
msgstr "Esta guía proporciona una mirada en profundidad sobre Apache Kafka y el marco de mensajería reactiva SmallRye. Para un comienzo rápido, eche un vistazo a  link:kafka-reactive-getting-started.html[Getting Started to SmallRye Reactive Messaging with Apache Kafka]."

#. type: Plain text
#: upstream/_guides/kafka.adoc:42
#, fuzzy
msgid "You can add the `smallrye-reactive-messaging-kafka` extensions to your project by running the following command in your project base directory:"
msgstr "Puede añadir las extensiones de `smallrye-reactive-messaging-kafka` a su proyecto ejecutando el siguiente comando en el directorio base de su proyecto:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:47
#, fuzzy
msgid "This will add the following to your build file:"
msgstr "Esto añadirá lo siguiente a su archivo de construcción:"

#. type: Block title
#: upstream/_guides/kafka.adoc:49 upstream/_guides/kafka.adoc:1719
#: upstream/_guides/kafka.adoc:1968 upstream/_guides/kafka.adoc:2036
#, fuzzy, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:55
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-smallrye-reactive-messaging-kafka</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Block title
#: upstream/_guides/kafka.adoc:58 upstream/_guides/kafka.adoc:1728
#: upstream/_guides/kafka.adoc:1977 upstream/_guides/kafka.adoc:2046
#, fuzzy, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:61
#, no-wrap
msgid "implementation(\"io.quarkus:quarkus-smallrye-reactive-messaging-kafka\")\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:66
#, fuzzy
msgid "The extension includes `kafka-clients` version 3.2.1 as a transitive dependency and is compatible with Kafka brokers version 2.x."
msgstr "La extensión incluye la versión 3.1.0 de `kafka-clients` como dependencia transitiva y es compatible con los brokers de Kafka versión 2.x."

#. type: Title ==
#: upstream/_guides/kafka.adoc:68
#, fuzzy, no-wrap
msgid "Configuring Smallrye Kafka Connector"
msgstr "Configuración del conector Kafka de Smallrye"

#. type: Plain text
#: upstream/_guides/kafka.adoc:71
#, fuzzy
msgid "Because Smallrye Reactive Messaging framework supports different messaging backends like Apache Kafka, AMQP, Apache Camel, JMS, MQTT, etc., it employs a generic vocabulary:"
msgstr "Dado que el marco de mensajería reactiva de Smallrye soporta diferentes backends de mensajería como Apache Kafka, AMQP, Apache Camel, JMS, MQTT, etc., emplea un vocabulario genérico:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:73
#, fuzzy
msgid "Applications send and receive *messages*. A message wraps a _payload_ and can be extended with some _metadata_. With the Kafka connector, a _message_ corresponds to a Kafka _record_."
msgstr "Las aplicaciones envían y reciben *mensajes*. Un mensaje envuelve una _carga útil_ y puede ampliarse con algunos _metadatos_. Con el conector Kafka, un _mensaje_ corresponde a un _registro_ Kafka."

#. type: Plain text
#: upstream/_guides/kafka.adoc:74
#, fuzzy
msgid "Messages transit on *channels*. Application components connect to channels to publish and consume messages. The Kafka connector maps _channels_ to Kafka _topics_."
msgstr "Los mensajes transitan por *los* canales. Los componentes de la aplicación se conectan a los canales para publicar y consumir mensajes. El conector Kafka asigna _canales_ a _temas_ Kafka."

#. type: Plain text
#: upstream/_guides/kafka.adoc:75
#, fuzzy
msgid "Channels are connected to message backends using *connectors*. Connectors are configured to map incoming messages to a specific channel (consumed by the application) and collect outgoing messages sent to a specific channel. Each connector is dedicated to a specific messaging technology. For example, the connector dealing with Kafka is named `smallrye-kafka`."
msgstr "Los canales se conectan a los backends de mensajes mediante *conectores*. Los conectores se configuran para asignar los mensajes entrantes a un canal específico (consumido por la aplicación) y recoger los mensajes salientes enviados a un canal específico. Cada conector está dedicado a una tecnología de mensajería específica. Por ejemplo, el conector que se ocupa de Kafka se llama `smallrye-kafka`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:77
#, fuzzy
msgid "A minimal configuration for the Kafka connector with an incoming channel looks like the following:"
msgstr "Una configuración mínima para el conector Kafka con un canal de entrada tiene el siguiente aspecto:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:82
#, no-wrap
msgid ""
"%prod.kafka.bootstrap.servers=kafka:9092 <1>\n"
"mp.messaging.incoming.prices.connector=smallrye-kafka <2>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:86
#, fuzzy
msgid "Configure the broker location for the production profile. You can configure it globally or per channel using `mp.messaging.incoming.$channel.bootstrap.servers` property.  In dev mode and when running tests, xref:kafka-dev-services[Dev Services for Kafka] automatically starts a Kafka broker.  When not provided this property defaults to `localhost:9092`."
msgstr "Configure la ubicación del broker para el perfil de producción. Puedes configurarlo globalmente o por canal usando la propiedad `mp.messaging.incoming.$channel.bootstrap.servers`. En modo dev y cuando se ejecutan pruebas,  link:#kafka-dev-services[[kafka-dev-services]] inicia automáticamente un broker de Kafka. Cuando no se proporciona esta propiedad, el valor predeterminado es `localhost:9092`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:87
#, fuzzy
msgid "Configure the connector to manage the prices channel. By default, the topic name is same as the channel name. You can configure the topic attribute to override it."
msgstr "Configure el conector para gestionar el canal de precios. Por defecto, el nombre del tema es el mismo que el del canal. Puede configurar el atributo del tema para anularlo."

#. type: Plain text
#: upstream/_guides/kafka.adoc:89
#, fuzzy
msgid "The `%prod` prefix indicates that the property is only used when the application runs in prod mode (so not in dev or test). Refer to the xref:config-reference.adoc#profiles[Profile documentation] for further details."
msgstr "El prefijo `%prod` indica que la propiedad sólo se utiliza cuando la aplicación se ejecuta en modo prod (es decir, no en dev o test). Consulte la  link:config-reference.html#profiles[documentación del perfil] para obtener más detalles."

#. type: Block title
#: upstream/_guides/kafka.adoc:91
#, fuzzy, no-wrap
msgid "Connector auto-attachment"
msgstr "Conexión automática de los conectores"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:96
#, fuzzy
msgid "If you have a single connector on your classpath, you can omit the `connector` attribute configuration.  Quarkus automatically associates _orphan_ channels to the (unique) connector found on the classpath.  _Orphans_ channels are outgoing channels without a downstream consumer or incoming channels without an upstream producer."
msgstr "Si tiene un solo conector en su classpath, puede omitir la configuración del atributo `connector`. Quarkus asocia automáticamente los canales _huérfanos_ al conector (único) que se encuentra en el classpath. Los canales _huérfanos_ son canales salientes sin un consumidor descendente o canales entrantes sin un productor ascendente."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:98
#, fuzzy
msgid "This auto-attachment can be disabled using:"
msgstr "Esta autoadhesión se puede desactivar mediante:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:102
#, no-wrap
msgid "quarkus.reactive-messaging.auto-connector-attachment=false\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:105
#, fuzzy, no-wrap
msgid "Receiving messages from Kafka"
msgstr "Recepción de mensajes de Kafka"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:108
#, fuzzy
msgid "Continuing from the previous minimal configuration, your Quarkus application can receive message payload directly:"
msgstr "Continuando con la configuración mínima anterior, su aplicación Quarkus puede recibir la carga útil de los mensajes directamente:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:112 upstream/_guides/kafka.adoc:2592
#: upstream/_guides/kafka.adoc:2673
#, no-wrap
msgid "import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:114 upstream/_guides/kafka.adoc:737
#: upstream/_guides/kafka.adoc:1214 upstream/_guides/kafka.adoc:1257
#: upstream/_guides/kafka.adoc:1281 upstream/_guides/kafka.adoc:1319
#: upstream/_guides/kafka.adoc:1390 upstream/_guides/kafka.adoc:1413
#: upstream/_guides/kafka.adoc:1455 upstream/_guides/kafka.adoc:1625
#, no-wrap
msgid "import jakarta.enterprise.context.ApplicationScoped;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:117
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class PriceConsumer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:122
#, no-wrap
msgid ""
"    @Incoming(\"prices\")\n"
"    public void consume(double price) {\n"
"        // process your price.\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:124 upstream/_guides/kafka.adoc:270
#: upstream/_guides/kafka.adoc:604 upstream/_guides/kafka.adoc:630
#: upstream/_guides/kafka.adoc:922 upstream/_guides/kafka.adoc:1272
#: upstream/_guides/kafka.adoc:1304 upstream/_guides/kafka.adoc:1342
#: upstream/_guides/kafka.adoc:1403 upstream/_guides/kafka.adoc:1431
#: upstream/_guides/kafka.adoc:1483 upstream/_guides/kafka.adoc:1586
#: upstream/_guides/kafka.adoc:1644 upstream/_guides/kafka.adoc:2031
#: upstream/_guides/kafka.adoc:2114 upstream/_guides/kafka.adoc:2580
#: upstream/_guides/kafka.adoc:2660 upstream/_guides/kafka.adoc:2693
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:127
#, fuzzy
msgid "There are several other ways your application can consume incoming messages:"
msgstr "Existen otras formas en las que tu aplicación puede consumir los mensajes entrantes:"

#. type: Block title
#: upstream/_guides/kafka.adoc:128
#, fuzzy, no-wrap
msgid "Message"
msgstr "Mensaje"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:140
#, no-wrap
msgid ""
"@Incoming(\"prices\")\n"
"public CompletionStage<Void> consume(Message<Double> msg) {\n"
"    // access record metadata\n"
"    var metadata = msg.getMetadata(IncomingKafkaRecordMetadata.class).orElseThrow();\n"
"    // process the message payload.\n"
"    double price = msg.getPayload();\n"
"    // Acknowledge the incoming message (commit the offset)\n"
"    return msg.ack();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:144
#, fuzzy
msgid "The `Message` type lets the consuming method access the incoming message metadata and handle the acknowledgment manually.  We'll explore different acknowledgment strategies in xref:commit-strategies[Commit Strategies]."
msgstr "El tipo `Message` permite al método consumidor acceder a los metadatos del mensaje entrante y gestionar el acuse de recibo manualmente. Exploraremos diferentes estrategias de acuse de recibo en  link:#commit-strategies[[commit-strategies]]."

#. type: Plain text
#: upstream/_guides/kafka.adoc:146
#, fuzzy
msgid "If you want to access the Kafka record objects directly, use:"
msgstr "Si quiere acceder directamente a los objetos de registro de Kafka, utilice"

#. type: Block title
#: upstream/_guides/kafka.adoc:147
#, fuzzy, no-wrap
msgid "ConsumerRecord"
msgstr "ConsumerRecord"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:158
#, no-wrap
msgid ""
"@Incoming(\"prices\")\n"
"public void consume(ConsumerRecord<String, Double> record) {\n"
"    String key = record.key(); // Can be `null` if the incoming record has no key\n"
"    String value = record.value(); // Can be `null` if the incoming record has no value\n"
"    String topic = record.topic();\n"
"    int partition = record.partition();\n"
"    // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:162
#, fuzzy
msgid "`ConsumerRecord` is provided by the underlying Kafka client and can be injected directly to the consumer method.  Another simpler approach consists in using `Record`:"
msgstr "`ConsumerRecord` es proporcionada por el cliente Kafka subyacente y puede ser inyectada directamente en el método del consumidor. Otro enfoque más sencillo consiste en utilizar `Record`:"

#. type: Block title
#: upstream/_guides/kafka.adoc:163
#, fuzzy, no-wrap
msgid "Record"
msgstr "Registro"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:171
#, no-wrap
msgid ""
"@Incoming(\"prices\")\n"
"public void consume(Record<String, Double> record) {\n"
"    String key = record.key(); // Can be `null` if the incoming record has no key\n"
"    String value = record.value(); // Can be `null` if the incoming record has no value\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:174
#, fuzzy
msgid "`Record` is a simple wrapper around key and payload of the incoming Kafka record."
msgstr "`Record` es una simple envoltura alrededor de la clave y la carga útil del registro Kafka entrante."

#. type: Block title
#: upstream/_guides/kafka.adoc:175
#, fuzzy, no-wrap
msgid "@Channel"
msgstr "@Canal"

#. type: Plain text
#: upstream/_guides/kafka.adoc:178
#, fuzzy
msgid "Alternatively, your application can inject a `Multi` in your bean and subscribe to its events as the following example:"
msgstr "Alternativamente, tu aplicación puede inyectar un `Multi` en tu bean y suscribirse a sus eventos como en el siguiente ejemplo:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:183
#, fuzzy, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import org.eclipse.microprofile.reactive.messaging.Channel;\n"
msgstr "`org.eclipse.microprofile.reactive.messaging.Channel`"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:190
#, no-wrap
msgid ""
"import jakarta.inject.Inject;\n"
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.Produces;\n"
"import jakarta.ws.rs.core.MediaType;\n"
"import org.jboss.resteasy.reactive.RestStreamElementType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:193 upstream/_guides/kafka.adoc:1003
#: upstream/_guides/kafka.adoc:1048 upstream/_guides/kafka.adoc:1084
#, no-wrap
msgid ""
"@Path(\"/prices\")\n"
"public class PriceResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:197
#, no-wrap
msgid ""
"    @Inject\n"
"    @Channel(\"prices\")\n"
"    Multi<Double> prices;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:205
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/prices\")\n"
"    @RestStreamElementType(MediaType.TEXT_PLAIN)\n"
"    public Multi<Double> stream() {\n"
"        return prices;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:209
#, fuzzy
msgid "This is a good example of how to integrate a Kafka consumer with another downstream, in this example exposing it as a Server-Sent Events endpoint."
msgstr "Este es un buen ejemplo de cómo integrar un consumidor de Kafka con otro downstream, en este ejemplo exponiéndolo como un endpoint de Server-Sent Events."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:215
#, fuzzy
msgid "When consuming messages with `@Channel`, the application code is responsible for the subscription.  In the example above, the RESTEasy Reactive endpoint handles that for you."
msgstr "Al consumir mensajes con `@Channel`, el código de la aplicación es responsable de la suscripción. En el ejemplo anterior, el punto final de RESTEasy Reactive se encarga de ello."

#. type: Plain text
#: upstream/_guides/kafka.adoc:218
#, fuzzy
msgid "Following types can be injected as channels:"
msgstr "Los siguientes tipos pueden ser inyectados como canales:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:222
#, no-wrap
msgid "@Inject @Channel(\"prices\") Multi<Double> streamOfPayloads;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:224
#, no-wrap
msgid "@Inject @Channel(\"prices\") Multi<Message<Double>> streamOfMessages;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:226
#, no-wrap
msgid "@Inject @Channel(\"prices\") Publisher<Double> publisherOfPayloads;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:228
#, no-wrap
msgid "@Inject @Channel(\"prices\") Publisher<Message<Double>> publisherOfMessages;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:233
#, fuzzy
msgid "As with the previous `Message` example, if your injected channel receives payloads (`Multi<T>`), it acknowledges the message automatically, and support multiple subscribers.  If you injected channel receives Message (`Multi<Message<T>>`), you will be responsible for the acknowledgment and broadcasting.  We will explore sending broadcast messages in xref:broadcasting-messages-on-multiple-consumers[Broadcasting messages on multiple consumers]."
msgstr "Al igual que en el ejemplo anterior de `Message`, si su canal inyectado recibe cargas útiles ( `Multi&amp;lt;T&amp;gt;`), acusa recibo del mensaje automáticamente, y admite múltiples suscriptores. Si su canal inyectado recibe mensajes ( `Multi&amp;lt;Message&amp;lt;T&amp;gt;&amp;gt;`), será responsable del acuse de recibo y de la difusión. Exploraremos el envío de mensajes de difusión en  link:#broadcasting-messages-on-multiple-consumers[[broadcasting-messages-on-multiple-consumers]]."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:238
#, fuzzy
msgid "Injecting `@Channel(\"prices\")` or having `@Incoming(\"prices\")` does not automatically configure the application to consume messages from Kafka.  You need to configure an inbound connector with `mp.messaging.incoming.prices\\...` or have an `@Outgoing(\"prices\")` method somewhere in your application (in which case, `prices` will be an in-memory channel)."
msgstr "Inyectar `@Channel(\"prices\")` o tener `@Incoming(\"prices\")` no configura automáticamente la aplicación para consumir mensajes de Kafka. Necesitas configurar un conector de entrada con `mp.messaging.incoming.prices...` o tener un método `@Outgoing(\"prices\")` en algún lugar de tu aplicación (en cuyo caso, `prices` será un canal en memoria)."

#. type: Title ===
#: upstream/_guides/kafka.adoc:241
#, fuzzy, no-wrap
msgid "Blocking processing"
msgstr "Bloqueo del tratamiento"

#. type: Plain text
#: upstream/_guides/kafka.adoc:247
#, fuzzy
msgid "Reactive Messaging invokes your method on an I/O thread.  See the xref:quarkus-reactive-architecture.adoc[Quarkus Reactive Architecture documentation] for further details on this topic.  But, you often need to combine Reactive Messaging with blocking processing such as database interactions.  For this, you need to use the `@Blocking` annotation indicating that the processing is _blocking_ and should not be run on the caller thread."
msgstr "La mensajería reactiva invoca su método en un hilo de E/S. Consulta la  link:quarkus-reactive-architecture.html[documentación de la Arquitectura Reactiva de Quarkus] para más detalles sobre este tema. Pero, a menudo necesitas combinar la Mensajería Reactiva con el procesamiento de bloqueo, como las interacciones con la base de datos. Para ello, es necesario utilizar la anotación `@Blocking` indicando que el procesamiento es _de_ bloqueo y no debe ejecutarse en el hilo de la llamada."

#. type: Plain text
#: upstream/_guides/kafka.adoc:249
#, fuzzy
msgid "For example, The following code illustrates how you can store incoming payloads to a database using Hibernate with Panache:"
msgstr "Por ejemplo, el siguiente código ilustra cómo puede almacenar las cargas útiles entrantes en una base de datos utilizando Hibernate con Panache:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:254
#, no-wrap
msgid ""
"import io.smallrye.reactive.messaging.annotations.Blocking;\n"
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:257 upstream/_guides/kafka.adoc:2590
#, no-wrap
msgid ""
"import jakarta.enterprise.context.ApplicationScoped;\n"
"import jakarta.transaction.Transactional;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:260
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class PriceStorage {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:268
#, no-wrap
msgid ""
"    @Incoming(\"prices\")\n"
"    @Transactional\n"
"    public void store(int priceInUsd) {\n"
"        Price price = new Price();\n"
"        price.value = priceInUsd;\n"
"        price.persist();\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:273
#, fuzzy
msgid "The complete example is available in the `kafka-panache-quickstart` link:{quickstarts-tree-url}/kafka-panache-quickstart[directory]."
msgstr "El ejemplo completo está disponible en `kafka-panache-quickstart` {quickstarts-tree-url}/kafka-panache-quickstart[directorio]."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:277
#, fuzzy
msgid "There are 2 `@Blocking` annotations:"
msgstr "Hay 2 anotaciones en `@Blocking`:"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:279
#, fuzzy
msgid "`io.smallrye.reactive.messaging.annotations.Blocking`"
msgstr "`io.smallrye.reactive.messaging.annotations.Blocking`"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:280
#, fuzzy
msgid "`io.smallrye.common.annotation.Blocking`"
msgstr "`io.smallrye.common.annotation.Blocking`"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:285
#, fuzzy
msgid "They have the same effect.  Thus, you can use both.  The first one provides more fine-grained tuning such as the worker pool to use and whether it preserves the order.  The second one, used also with other reactive features of Quarkus, uses the default worker pool and preserves the order."
msgstr "Tienen el mismo efecto. Por lo tanto, puede utilizar ambos. El primero proporciona un ajuste más fino, como el grupo de trabajadores a utilizar y si preserva el orden. El segundo, utilizado también con otras características reactivas de Quarkus, utiliza el grupo de trabajadores por defecto y preserva el orden."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:287
#, fuzzy
msgid "Detailed information on the usage of `@Blocking` annotation can be found in https://smallrye.io/smallrye-reactive-messaging/latest/concepts/blocking/[SmallRye Reactive Messaging – Handling blocking execution]."
msgstr "Puede encontrar información detallada sobre el uso de la anotación `@Blocking` en  link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.1/advanced/blocking.html[SmallRye Reactive Messaging - Handling blocking execution]."

#. type: Block title
#: upstream/_guides/kafka.adoc:290
#, fuzzy, no-wrap
msgid "@RunOnVirtualThread"
msgstr "@RunOnVirtualThread"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:293
#, fuzzy
msgid "For running the blocking processing on Java _virtual threads_, see the xref:messaging-virtual-threads.adoc[Quarkus Virtual Thread support with Reactive Messaging documentation]."
msgstr "Para ejecutar el procesamiento de bloqueo en _hilos virtuales_ Java, véase la  link:messaging-virtual-threads.html[documentación Quarkus Virtual Thread support with Reactive Messaging]."

#. type: Block title
#: upstream/_guides/kafka.adoc:296
#, fuzzy, no-wrap
msgid "@Transactional"
msgstr "@Transactional"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:299
#, fuzzy
msgid "If your method is annotated with `@Transactional`, it will be considered _blocking_ automatically, even if the method is not annotated with `@Blocking`."
msgstr "Si su método está anotado con `@Transactional`, se considerará automáticamente _bloqueante_, incluso si el método no está anotado con `@Blocking`."

#. type: Title ===
#: upstream/_guides/kafka.adoc:301
#, fuzzy, no-wrap
msgid "Acknowledgment Strategies"
msgstr "Estrategias de reconocimiento"

#. type: Plain text
#: upstream/_guides/kafka.adoc:309
#, fuzzy
msgid "All messages received by a consumer must be acknowledged.  In the absence of acknowledgment, the processing is considered in error.  If the consumer method receives a `Record` or a payload, the message will be acked on method return, also known as `Strategy.POST_PROCESSING`.  If the consumer method returns another reactive stream or `CompletionStage`, the message will be acked when the downstream message is acked.  You can override the default behavior to ack the message on arrival (`Strategy.PRE_PROCESSING`), or do not ack the message at all (`Strategy.NONE`) on the consumer method as in the following example:"
msgstr "Todos los mensajes recibidos por un consumidor deben ser reconocidos. En ausencia de acuse de recibo, el procesamiento se considera un error. Si el método consumidor recibe un `Record` o una carga útil, el mensaje será acuse de recibo al retorno del método, también conocido como `Strategy.POST_PROCESSING`. Si el método consumidor devuelve otro flujo reactivo o `CompletionStage`, el mensaje será acuse de recibo cuando el mensaje descendente sea acuse de recibo. Puedes anular el comportamiento por defecto para ack el mensaje a su llegada ( `Strategy.PRE_PROCESSING`), o no ack el mensaje en absoluto ( `Strategy.NONE`) en el método consumidor como en el siguiente ejemplo:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:317
#, no-wrap
msgid ""
"@Incoming(\"prices\")\n"
"@Acknowledgment(Acknowledgment.Strategy.PRE_PROCESSING)\n"
"public void process(double price) {\n"
"    // process price\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:321
#, fuzzy
msgid "If the consumer method receives a `Message`, the acknowledgment strategy is `Strategy.MANUAL` and the consumer method is in charge of ack/nack the message."
msgstr "Si el método consumidor recibe un `Message`, la estrategia de acuse de recibo es `Strategy.MANUAL` y el método consumidor se encarga de ack/nack el mensaje."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:329
#, no-wrap
msgid ""
"@Incoming(\"prices\")\n"
"public CompletionStage<Void> process(Message<Double> msg) {\n"
"    // process price\n"
"    return msg.ack();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:332
#, fuzzy
msgid "As mentioned above, the method can also override the acknowledgment strategy to `PRE_PROCESSING` or `NONE`."
msgstr "Como se mencionó anteriormente, el método también puede anular la estrategia de reconocimiento a `PRE_PROCESSING` o `NONE`."

#. type: Title ===
#: upstream/_guides/kafka.adoc:334
#, fuzzy, no-wrap
msgid "Commit Strategies"
msgstr "Estrategias de compromiso"

#. type: Plain text
#: upstream/_guides/kafka.adoc:340
#, fuzzy
msgid "When a message produced from a Kafka record is acknowledged, the connector invokes a commit strategy.  These strategies decide when the consumer offset for a specific topic/partition is committed.  Committing an offset indicates that all previous records have been processed.  It is also the position where the application would restart the processing after a crash recovery or a restart."
msgstr "Cuando un mensaje producido a partir de un registro de Kafka es reconocido, el conector invoca una estrategia de confirmación. Estas estrategias deciden cuándo se compromete el desplazamiento del consumidor para un tema/partición específico. La confirmación de un desplazamiento indica que todos los registros anteriores han sido procesados. También es la posición en la que la aplicación reiniciaría el procesamiento después de una recuperación de un fallo o un reinicio."

#. type: Plain text
#: upstream/_guides/kafka.adoc:343
#, fuzzy
msgid "Committing every offset has performance penalties as Kafka offset management can be slow.  However, not committing the offset often enough may lead to message duplication if the application crashes between two commits."
msgstr "Confirmar cada offset tiene penalizaciones de rendimiento, ya que la gestión de offset de Kafka puede ser lenta. Sin embargo, no consignar el desplazamiento con suficiente frecuencia puede conducir a la duplicación de mensajes si la aplicación se bloquea entre dos consignaciones."

#. type: Plain text
#: upstream/_guides/kafka.adoc:345
#, fuzzy
msgid "The Kafka connector supports three strategies:"
msgstr "El conector Kafka admite tres estrategias:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:354
#, fuzzy
msgid "`throttled` keeps track of received messages and commits an offset of the latest acked message in sequence (meaning, all previous messages were also acked).  This strategy guarantees at-least-once delivery even if the channel performs asynchronous processing.  The connector tracks the received records and periodically (period specified by `auto.commit.interval.ms`, default: 5000 ms) commits the highest consecutive offset.  The connector will be marked as unhealthy if a message associated with a record is not acknowledged in `throttled.unprocessed-record-max-age.ms` (default: 60000 ms).  Indeed, this strategy cannot commit the offset as soon as a single record processing fails.  If `throttled.unprocessed-record-max-age.ms` is set to less than or equal to `0`, it does not perform any health check verification.  Such a setting might lead to running out of memory if there are \"poison pill\" messages (that are never acked).  This strategy is the default if `enable.auto.commit` is not explicitly set to true."
msgstr "`throttled` mantiene un registro de los mensajes recibidos y consigna un desplazamiento del último mensaje accionado en la secuencia (lo que significa que todos los mensajes anteriores también fueron accionados). Esta estrategia garantiza la entrega al menos una vez, incluso si el canal realiza un procesamiento asíncrono. El conector rastrea los registros recibidos y periódicamente (periodo especificado por `auto.commit.interval.ms`, por defecto: 5000 ms) consigna el mayor desplazamiento consecutivo. El conector se marcará como no saludable si un mensaje asociado a un registro no es reconocido en `throttled.unprocessed-record-max-age.ms` (por defecto: 60000 ms). De hecho, esta estrategia no puede consignar el desplazamiento en cuanto falla el procesamiento de un solo registro (véase  link:#error-handling[[error-handling]] para configurar lo que ocurre cuando falla el procesamiento). Si `throttled.unprocessed-record-max-age.ms` se establece como menor o igual que `0`, no realiza ninguna verificación de salud. Esta configuración puede llevar a que se agote la memoria si hay mensajes de \"píldora venenosa\" (que nunca se aceptan). Esta estrategia es la predeterminada si `enable.auto.commit` no se establece explícitamente como verdadera."

#. type: Plain text
#: upstream/_guides/kafka.adoc:362
#, fuzzy
msgid "`checkpoint` allows persisting consumer offsets on a **state store**, instead of committing them back to the Kafka broker.  Using the `CheckpointMetadata` API, consumer code can persist a _processing state_ with the record offset to mark the progress of a consumer.  When the processing continues from a previously persisted offset, it seeks the Kafka consumer to that offset and also restores the persisted state, continuing the stateful processing from where it left off.  The checkpoint strategy holds locally the processing state associated with the latest offset, and persists it periodically to the state store (period specified by `auto.commit.interval.ms` (default: 5000)).  The connector will be marked as unhealthy if no processing state is persisted to the state store in `checkpoint.unsynced-state-max-age.ms` (default: 10000).  If `checkpoint.unsynced-state-max-age.ms` is set to less than or equal to 0, it does not perform any health check verification.  For more information, see xref:stateful-processing-checkpointing[Stateful processing with Checkpointing]"
msgstr "`checkpoint` permite la persistencia de los desplazamientos de los consumidores en un *almacén de estados*, en lugar de devolverlos al corredor de Kafka. Utilizando la API `CheckpointMetadata`, el código del consumidor puede persistir un _estado_ de procesamiento con el desplazamiento de registro para marcar el progreso de un consumidor. Cuando el procesamiento continúa desde un desplazamiento persistido previamente, busca el consumidor Kafka a ese desplazamiento y también restaura el estado persistido, continuando el procesamiento de estado desde donde lo dejó. La estrategia de punto de control mantiene localmente el estado de procesamiento asociado con el último desplazamiento, y lo persiste periódicamente en el almacén de estado (período especificado por `auto.commit.interval.ms` (por defecto: 5000)). El conector se marcará como no saludable si no se persiste ningún estado de procesamiento al almacén de estado en `checkpoint.unsynced-state-max-age.ms` (por defecto: 10000). Si `checkpoint.unsynced-state-max-age.ms` es menor o igual a 0, no realiza ninguna verificación de estado. Para obtener más información, consulte  link:#Stateful processing with Checkpointing[[Stateful processing with Checkpointing]]."

#. type: Plain text
#: upstream/_guides/kafka.adoc:366
#, fuzzy
msgid "`latest` commits the record offset received by the Kafka consumer as soon as the associated message is acknowledged (if the offset is higher than the previously committed offset).  This strategy provides at-least-once delivery if the channel processes the message without performing any asynchronous processing.  This strategy should not be used in high load environment, as offset commit is expensive. However, it reduces the risk of duplicates."
msgstr "`latest` consigna el desplazamiento del registro recibido por el consumidor de Kafka tan pronto como el mensaje asociado es reconocido (si el desplazamiento es mayor que el desplazamiento previamente consignado). Esta estrategia proporciona una entrega al menos una vez si el canal procesa el mensaje sin realizar ningún procesamiento asíncrono. Esta estrategia no debe utilizarse en entornos de alta carga, ya que la confirmación del desplazamiento es costosa. Sin embargo, reduce el riesgo de duplicados."

#. type: Plain text
#: upstream/_guides/kafka.adoc:372
#, fuzzy
msgid "`ignore` performs no commit. This strategy is the default strategy when the consumer is explicitly configured with `enable.auto.commit` to true.  It delegates the offset commit to the underlying Kafka client.  When `enable.auto.commit` is `true` this strategy **DOES NOT** guarantee at-least-once delivery.  SmallRye Reactive Messaging processes records asynchronously, so offsets may be committed for records that have been polled but not yet processed.  In case of a failure, only records that were not committed yet will be re-processed."
msgstr "`ignore` no realiza ninguna confirmación. Esta estrategia es la estrategia por defecto cuando el consumidor está configurado explícitamente con `enable.auto.commit` a true. Delega la confirmación del desplazamiento al cliente Kafka subyacente. Cuando `enable.auto.commit` es `true` esta estrategia *NO* garantiza la entrega al menos una vez. SmallRye Reactive Messaging procesa los registros de forma asíncrona, por lo que los offsets pueden ser confirmados para los registros que han sido encuestados pero aún no procesados. En caso de fallo, sólo se volverán a procesar los registros que aún no se hayan consignado."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:377
#, fuzzy
msgid "The Kafka connector disables the Kafka auto commit when it is not explicitly enabled. This behavior differs from the traditional Kafka consumer.  If high throughput is important for you, and you are not limited by the downstream, we recommend to either:"
msgstr "El conector Kafka deshabilita el auto commit de Kafka cuando no está explícitamente habilitado. Este comportamiento difiere del consumidor tradicional de Kafka. Si el alto rendimiento es importante para usted, y no está limitado por el flujo descendente, le recomendamos que lo haga:"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:379
#, fuzzy
msgid "use the `throttled` policy,"
msgstr "utilizar la política de `throttled`,"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:380
#, fuzzy
msgid "or set `enable.auto.commit` to true and annotate the consuming method with `@Acknowledgment(Acknowledgment.Strategy.NONE)`."
msgstr "o establecer `enable.auto.commit` como verdadero y anotar el método de consumo con `@Acknowledgment(Acknowledgment.Strategy.NONE)`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:384
#, fuzzy
msgid "Smallrye Reactive Messaging enables implementing custom commit strategies.  See https://smallrye.io/smallrye-reactive-messaging/latest/kafka/receiving-kafka-records/#acknowledgement[SmallRye Reactive Messaging documentation] for more information."
msgstr "Puede encontrar más detalles sobre la configuración de SmallRye Reactive Messaging en la  link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.1/kafka/kafka.html[documentación de SmallRye Reactive Messaging - Kafka Connector]."

#. type: Title ===
#: upstream/_guides/kafka.adoc:386
#, fuzzy, no-wrap
msgid "Error Handling Strategies"
msgstr "Estrategias de gestión de errores"

#. type: Plain text
#: upstream/_guides/kafka.adoc:389
#, fuzzy
msgid "If a message produced from a Kafka record is nacked, a failure strategy is applied. The Kafka connector supports three strategies:"
msgstr "Si un mensaje producido a partir de un registro de Kafka es nacked, se aplica una estrategia de fallo. El conector Kafka soporta tres estrategias:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:391
#, fuzzy
msgid "`fail`: fail the application, no more records will be processed (default strategy). The offset of the record that has not been processed correctly is not committed."
msgstr "`fail`: falla la aplicación, no se procesarán más registros (estrategia por defecto). El desplazamiento del registro que no se ha procesado correctamente no se compromete."

#. type: Plain text
#: upstream/_guides/kafka.adoc:392
#, fuzzy
msgid "`ignore`: the failure is logged, but the processing continue. The offset of the record that has not been processed correctly is committed."
msgstr "`ignore`El fallo se registra, pero el procesamiento continúa. Se consigna el desplazamiento del registro que no se ha procesado correctamente."

#. type: Plain text
#: upstream/_guides/kafka.adoc:393
#, fuzzy
msgid "`dead-letter-queue`: the offset of the record that has not been processed correctly is committed, but the record is written to a Kafka dead letter topic."
msgstr "`dead-letter-queue`: el desplazamiento del registro que no se ha procesado correctamente se consigna, pero el registro se escribe en un tema de letra muerta de Kafka."

#. type: Plain text
#: upstream/_guides/kafka.adoc:395
#, fuzzy
msgid "The strategy is selected using the `failure-strategy` attribute."
msgstr "La estrategia se selecciona mediante el atributo `failure-strategy`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:397
#, fuzzy
msgid "In the case of `dead-letter-queue`, you can configure the following attributes:"
msgstr "En el caso de `dead-letter-queue`, puede configurar los siguientes atributos:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:399
#, fuzzy
msgid "`dead-letter-queue.topic`: the topic to use to write the records not processed correctly, default is `dead-letter-topic-$channel`, with `$channel` being the name of the channel."
msgstr "`dead-letter-queue.topic`: el tema a utilizar para escribir los registros no procesados correctamente, por defecto es `dead-letter-topic-$channel`, siendo `$channel` el nombre del canal."

#. type: Plain text
#: upstream/_guides/kafka.adoc:400
#, fuzzy
msgid "`dead-letter-queue.key.serializer`: the serializer used to write the record key on the dead letter queue. By default, it deduces the serializer from the key deserializer."
msgstr "`dead-letter-queue.key.serializer`: el serializador utilizado para escribir la clave de registro en la cola de letra muerta. Por defecto, deduce el serializador del deserializador de la clave."

#. type: Plain text
#: upstream/_guides/kafka.adoc:401
#, fuzzy
msgid "`dead-letter-queue.value.serializer`: the serializer used to write the record value on the dead letter queue. By default, it deduces the serializer from the value deserializer."
msgstr "`dead-letter-queue.value.serializer`: el serializador utilizado para escribir el valor del registro en la cola de letra muerta. Por defecto, deduce el serializador del deserializador del valor."

#. type: Plain text
#: upstream/_guides/kafka.adoc:403
#, fuzzy
msgid "The record written on the dead letter queue contains a set of additional headers about the original record:"
msgstr "El registro escrito en la cola de la letra muerta contiene un conjunto de cabeceras adicionales sobre el registro original:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:405
#, fuzzy, no-wrap
msgid "*dead-letter-reason*: the reason of the failure\n"
msgstr "*dead-letter-reason*: la razón del fracaso"

#. type: Plain text
#: upstream/_guides/kafka.adoc:406
#, fuzzy, no-wrap
msgid "*dead-letter-cause*: the cause of the failure if any\n"
msgstr "*causa de la letra muerta*: la causa del fallo, si la hay"

#. type: Plain text
#: upstream/_guides/kafka.adoc:407
#, fuzzy, no-wrap
msgid "*dead-letter-topic*: the original topic of the record\n"
msgstr "*dead-letter-topic*: el tema original del disco"

#. type: Plain text
#: upstream/_guides/kafka.adoc:408
#, fuzzy, no-wrap
msgid "*dead-letter-partition*: the original partition of the record (integer mapped to String)\n"
msgstr "*dead-letter-partition*: la partición original del registro (entero mapeado a String)"

#. type: Plain text
#: upstream/_guides/kafka.adoc:409
#, fuzzy, no-wrap
msgid "*dead-letter-offset*: the original offset of the record (long mapped to String)\n"
msgstr "*dead-letter-offset*: el offset original del registro (long mapped to String)"

#. type: Plain text
#: upstream/_guides/kafka.adoc:412
#, fuzzy
msgid "Smallrye Reactive Messaging enables implementing custom failure strategies.  See https://smallrye.io/smallrye-reactive-messaging/latest/kafka/receiving-kafka-records/#acknowledgement[SmallRye Reactive Messaging documentation] for more information."
msgstr "Puede encontrar más detalles sobre la configuración de SmallRye Reactive Messaging en la  link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.1/kafka/kafka.html[documentación de SmallRye Reactive Messaging - Kafka Connector]."

#. type: Title ====
#: upstream/_guides/kafka.adoc:413
#, fuzzy, no-wrap
msgid "Retrying processing"
msgstr "Reintento de procesamiento"

#. type: Plain text
#: upstream/_guides/kafka.adoc:416
#, fuzzy
msgid "You can combine Reactive Messaging with https://github.com/smallrye/smallrye-fault-tolerance[SmallRye Fault Tolerance], and retry processing if it failed:"
msgstr "Puede combinar la Mensajería Reactiva con la  link:https://github.com/smallrye/smallrye-fault-tolerance[Tolerancia a Fallos de SmallRye], y reintentar el procesamiento si ha fallado:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:424
#, no-wrap
msgid ""
"@Incoming(\"kafka\")\n"
"@Retry(delay = 10, maxRetries = 5)\n"
"public void consume(String v) {\n"
"   // ... retry if this method throws an exception\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:427
#, fuzzy
msgid "You can configure the delay, the number of retries, the jitter, etc."
msgstr "Puedes configurar el retraso, el número de reintentos, el jitter, etc."

#. type: Plain text
#: upstream/_guides/kafka.adoc:429
#, fuzzy
msgid "If your method returns a `Uni` or `CompletionStage`, you need to add the `@NonBlocking` annotation:"
msgstr "Si su método devuelve un `Uni` o `CompletionStage`, debe añadir la anotación `@NonBlocking`:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:438
#, no-wrap
msgid ""
"@Incoming(\"kafka\")\n"
"@Retry(delay = 10, maxRetries = 5)\n"
"@NonBlocking\n"
"public Uni<String> consume(String v) {\n"
"   // ... retry if this method throws an exception or the returned Uni produce a failure\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:443
#, fuzzy
msgid "The `@NonBlocking` annotation is only required with SmallRye Fault Tolerance 5.1.0 and earlier.  Starting with SmallRye Fault Tolerance 5.2.0 (available since Quarkus 2.1.0.Final), it is not necessary.  See https://smallrye.io/docs/smallrye-fault-tolerance/5.2.0/usage/extra.html#_non_compatible_mode[SmallRye Fault Tolerance documentation] for more information."
msgstr "La anotación `@NonBlocking` sólo es necesaria con SmallRye Fault Tolerance 5.1.0 y anteriores. A partir de SmallRye Fault Tolerance 5.2.0 (disponible desde Quarkus 2.1.0.Final), no es necesaria. Consulte  link:https://smallrye.io/docs/smallrye-fault-tolerance/5.2.0/usage/extra.html#_non_compatible_mode[la documentación] de SmallRye Fault Tolerance para obtener más información."

#. type: Plain text
#: upstream/_guides/kafka.adoc:447
#, fuzzy
msgid "The incoming messages are acknowledged only once the processing completes successfully.  So, it commits the offset after the successful processing.  If the processing still fails, even after all retries, the message is _nacked_ and the failure strategy is applied."
msgstr "Los mensajes entrantes se reconocen sólo una vez que el procesamiento se completa con éxito. Por lo tanto, se compromete el desplazamiento después del procesamiento exitoso. Si el procesamiento sigue fallando, incluso después de todos los reintentos, el mensaje es _nacked_ y se aplica la estrategia de fracaso."

#. type: Title ====
#: upstream/_guides/kafka.adoc:448
#, fuzzy, no-wrap
msgid "Handling Deserialization Failures"
msgstr "Gestión de los fallos de deserialización"

#. type: Plain text
#: upstream/_guides/kafka.adoc:452
#, fuzzy
msgid "When a deserialization failure occurs, you can intercept it and provide a failure strategy.  To achieve this, you need to create a bean implementing `DeserializationFailureHandler<T>` interface:"
msgstr "Cuando se produce un fallo de deserialización, puedes interceptarlo y proporcionar una estrategia de fallo. Para ello, es necesario crear un bean que implemente la interfaz `DeserializationFailureHandler&amp;lt;T&amp;gt;`:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:459
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"@Identifier(\"failure-retry\") // Set the name of the failure handler\n"
"public class MyDeserializationFailureHandler\n"
"    implements DeserializationFailureHandler<JsonObject> { // Specify the expected type\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:468
#, no-wrap
msgid ""
"    @Override\n"
"    public JsonObject decorateDeserialization(Uni<JsonObject> deserialization, String topic, boolean isKey,\n"
"            String deserializer, byte[] data, Headers headers) {\n"
"        return deserialization\n"
"                    .onFailure().retry().atMost(3)\n"
"                    .await().atMost(Duration.ofMillis(200));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:471
#, fuzzy
msgid "To use this failure handler, the bean must be exposed with the `@Identifier` qualifier and the connector configuration must specify the attribute `mp.messaging.incoming.$channel.[key|value]-deserialization-failure-handler` (for key or value deserializers)."
msgstr "Para utilizar este gestor de fallos, el bean debe estar expuesto con el calificador `@Identifier` y la configuración del conector debe especificar el atributo `mp.messaging.incoming.$channel.[key|value]-deserialization-failure-handler` (para deserializadores de claves o valores)."

#. type: Plain text
#: upstream/_guides/kafka.adoc:474
#, fuzzy
msgid "The handler is called with details of the deserialization, including the action represented as `Uni<T>`.  On the deserialization `Uni` failure strategies like retry, providing a fallback value or applying timeout can be implemented."
msgstr "El manejador es llamado con los detalles de la deserialización, incluyendo la acción representada como `Uni&amp;lt;T&amp;gt;`. En la deserialización `Uni` se pueden implementar estrategias de fallo como reintentar, proporcionar un valor de retorno o aplicar un tiempo de espera."

#. type: Title ===
#: upstream/_guides/kafka.adoc:475
#, fuzzy, no-wrap
msgid "Consumer Groups"
msgstr "Grupos de consumidores"

#. type: Plain text
#: upstream/_guides/kafka.adoc:482
#, fuzzy
msgid "In Kafka, a consumer group is a set of consumers which cooperate to consume data from a topic.  A topic is divided into a set of partitions.  The partitions of a topic are assigned among the consumers in the group, effectively allowing to scale consumption throughput.  Note that each partition is assigned to a single consumer from a group.  However, a consumer can be assigned multiple partitions if the number of partitions is greater than the number of consumer in the group."
msgstr "En Kafka, un grupo de consumidores es un conjunto de consumidores que cooperan para consumir datos de un tema. Un tema se divide en un conjunto de particiones. Las particiones de un tema se asignan entre los consumidores del grupo, lo que permite escalar el rendimiento del consumo. Hay que tener en cuenta que cada partición se asigna a un solo consumidor de un grupo. Sin embargo, a un consumidor se le pueden asignar múltiples particiones si el número de particiones es mayor que el número de consumidores del grupo."

#. type: Plain text
#: upstream/_guides/kafka.adoc:484
#, fuzzy
msgid "Let's explore briefly different producer/consumer patterns and how to implement them using Quarkus:"
msgstr "Exploremos brevemente diferentes patrones de productor/consumidor y cómo implementarlos usando Quarkus:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:486
#, fuzzy, no-wrap
msgid "*Single consumer thread inside a consumer group*\n"
msgstr "*Hilo de consumo único dentro de un grupo de consumo*"

#. type: Plain text
#: upstream/_guides/kafka.adoc:490
#, fuzzy
msgid "This is the default behavior of an application subscribing to a Kafka topic: Each Kafka connector will create a single consumer thread and place it inside a single consumer group.  Consumer group id defaults to the application name as set by the `quarkus.application.name` configuration property.  It can also be set using the `kafka.group.id` property."
msgstr "Este es el comportamiento por defecto de una aplicación que se suscribe a un tema de Kafka: Cada conector Kafka creará un único hilo consumidor y lo colocará dentro de un único grupo consumidor. El identificador del grupo de consumidores es, por defecto, el nombre de la aplicación establecido por la propiedad de configuración `quarkus.application.name`. También puede establecerse mediante la propiedad `kafka.group.id`."

#. type: Named 'alt' AttributeList argument for macro 'image'
#: upstream/_guides/kafka.adoc:491 upstream/_guides/kafka.adoc:499
#: upstream/_guides/kafka.adoc:506 upstream/_guides/kafka.adoc:514
#, fuzzy, no-wrap
msgid "Architecture,"
msgstr "Arquitectura,"

#. type: Target for macro image
#: upstream/_guides/kafka.adoc:491
#, no-wrap
msgid "kafka-one-app-one-consumer.png"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:494
#, fuzzy, no-wrap
msgid "*Multiple consumer threads inside a consumer group*\n"
msgstr "*Múltiples hilos de consumo dentro de un grupo de consumo*"

#. type: Plain text
#: upstream/_guides/kafka.adoc:498
#, fuzzy
msgid "For a given application instance, the number of consumers inside the consumer group can be configured using `mp.messaging.incoming.$channel.partitions` property.  The partitions of the subscribed topic will be divided among the consumer threads.  Note that if the `partitions` value exceed the number of partitions of the topic, some consumer threads won't be assigned any partitions."
msgstr "Para una instancia de aplicación dada, el número de consumidores dentro del grupo de consumidores puede ser configurado usando la propiedad `mp.messaging.incoming.$channel.partitions`. Las particiones del tema suscrito se dividirán entre los hilos consumidores. Ten en cuenta que si el valor de `partitions` supera el número de particiones del tema, a algunos hilos consumidores no se les asignará ninguna partición."

#. type: Target for macro image
#: upstream/_guides/kafka.adoc:499
#, no-wrap
msgid "kafka-one-app-two-consumers.png"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:502
#, fuzzy, no-wrap
msgid "*Multiple consumer applications inside a consumer group*\n"
msgstr "*Múltiples aplicaciones de consumo dentro de un grupo de consumidores*"

#. type: Plain text
#: upstream/_guides/kafka.adoc:505
#, fuzzy
msgid "Similar to the previous example, multiple instances of an application can subscribe to a single consumer group, configured via `mp.messaging.incoming.$channel.group.id` property, or left default to the application name.  This in turn will divide partitions of the topic among application instances."
msgstr "Al igual que en el ejemplo anterior, múltiples instancias de una aplicación pueden suscribirse a un único grupo de consumidores, configurado a través de la propiedad `mp.messaging.incoming.$channel.group.id`, o dejado por defecto al nombre de la aplicación. Esto, a su vez, dividirá las particiones del tema entre las instancias de la aplicación."

#. type: Target for macro image
#: upstream/_guides/kafka.adoc:506
#, no-wrap
msgid "kafka-two-app-one-consumer-group.png"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:509
#, fuzzy, no-wrap
msgid "*Pub/Sub: Multiple consumer groups subscribed to a topic*\n"
msgstr "*Pub/Sub: Múltiples grupos de consumidores suscritos a un tema*"

#. type: Plain text
#: upstream/_guides/kafka.adoc:513
#, fuzzy
msgid "Lastly different applications can subscribe independently to same topics using different *consumer group ids*.  For example, messages published to a topic called _orders_ can be consumed independently on two consumer applications, one with `mp.messaging.incoming.orders.group.id=invoicing` and second with `mp.messaging.incoming.orders.group.id=shipping`.  Different consumer groups can thus scale independently according to the message consumption requirements."
msgstr "Por último, diferentes aplicaciones pueden suscribirse de forma independiente a los mismos temas utilizando diferentes *identificadores de grupo de consumidores*. Por ejemplo, los mensajes publicados en un tema llamado _pedidos_ pueden ser consumidos independientemente en dos aplicaciones consumidoras, una con `mp.messaging.incoming.orders.group.id=invoicing` y la segunda con `mp.messaging.incoming.orders.group.id=shipping`. De este modo, diferentes grupos de consumidores pueden escalar de forma independiente según las necesidades de consumo de mensajes."

#. type: Target for macro image
#: upstream/_guides/kafka.adoc:514
#, no-wrap
msgid "kafka-two-app-two-consumer-groups.png"
msgstr ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:522
#, fuzzy
msgid "A common business requirement is to consume and process Kafka records in order.  The Kafka broker preserves order of records inside a partition and not inside a topic.  Therefore, it is important to think about how records are partitioned inside a topic.  The default partitioner uses record key hash to compute the partition for a record, or when the key is not defined, chooses a partition randomly per batch or records."
msgstr "Un requisito empresarial común es consumir y procesar los registros de Kafka en orden. El broker Kafka preserva el orden de los registros dentro de una partición y no dentro de un tema. Por lo tanto, es importante pensar en cómo se particionan los registros dentro de un tema. El particionador por defecto utiliza el hash de la clave del registro para calcular la partición de un registro, o cuando la clave no está definida, elige una partición al azar por lote o registros."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:525
#, fuzzy
msgid "During normal operation, a Kafka consumer preserves the order of records inside each partition assigned to it.  Smallrye Reactive Messaging keeps this order for processing, unless `@Blocking(ordered = false)` is used (see xref:blocking-processing[Blocking processing])."
msgstr "Durante el funcionamiento normal, un consumidor de Kafka conserva el orden de los registros dentro de cada partición que se le asigna. Smallrye Reactive Messaging mantiene este orden para el procesamiento, a menos que se utilice `@Blocking(ordered = false)` (ver  link:#blocking-processing[[blocking-processing]])."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:527
#, fuzzy
msgid "Note that due to consumer rebalances, Kafka consumers only guarantee at-least-once processing of single records, meaning that uncommitted records _can_ be processed again by consumers."
msgstr "Tenga en cuenta que, debido a los reequilibrios de los consumidores, los consumidores de Kafka sólo garantizan el procesamiento de una sola vez de los registros individuales, lo que significa que los registros no comprometidos _pueden_ ser procesados de nuevo por los consumidores."

#. type: Title ====
#: upstream/_guides/kafka.adoc:529
#, fuzzy, no-wrap
msgid "Consumer Rebalance Listener"
msgstr "Escucha del reequilibrio de los consumidores"

#. type: Plain text
#: upstream/_guides/kafka.adoc:536
#, fuzzy
msgid "Inside a consumer group, as new group members arrive and old members leave, the partitions are re-assigned so that each member receives a proportional share of the partitions.  This is known as rebalancing the group.  To handle offset commit and assigned partitions yourself, you can provide a consumer rebalance listener.  To achieve this, implement the `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` interface and expose it as a CDI bean with the `@Idenfier` qualifier.  A common use case is to store offset in a separate data store to implement exactly-once semantic, or starting the processing at a specific offset."
msgstr "Dentro de un grupo de consumidores, a medida que llegan nuevos miembros del grupo y se van los antiguos, se reasignan las particiones para que cada miembro reciba una parte proporcional de las mismas. Esto se conoce como reequilibrar el grupo. Para manejar el compromiso de compensación y las particiones asignadas por ti mismo, puedes proporcionar un oyente de rebalanceo del consumidor. Para lograrlo, implemente la interfaz `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` y expóngala como un bean CDI con el calificador `@Idenfier`. Un caso de uso común es almacenar el desplazamiento en un almacén de datos separado para implementar la semántica \"exactamente una vez\", o iniciar el procesamiento en un desplazamiento específico."

#. type: Plain text
#: upstream/_guides/kafka.adoc:540
#, fuzzy
msgid "The listener is invoked every time the consumer topic/partition assignment changes.  For example, when the application starts, it invokes the `partitionsAssigned` callback with the initial set of topics/partitions associated with the consumer.  If, later, this set changes, it calls the `partitionsRevoked` and `partitionsAssigned` callbacks again, so you can implement custom logic."
msgstr "El escuchador es invocado cada vez que la asignación de temas/particiones del consumidor cambia. Por ejemplo, cuando la aplicación se inicia, invoca la llamada de retorno `partitionsAssigned` con el conjunto inicial de temas/particiones asociados al consumidor. Si, más tarde, este conjunto cambia, llama a las devoluciones de llamada `partitionsRevoked` y `partitionsAssigned` de nuevo, por lo que puedes implementar una lógica personalizada."

#. type: Plain text
#: upstream/_guides/kafka.adoc:543
#, fuzzy
msgid "Note that the rebalance listener methods are called from the Kafka polling thread and **will** block the caller thread until completion.  That’s because the rebalance protocol has synchronization barriers, and using asynchronous code in a rebalance listener may be executed after the synchronization barrier."
msgstr "Tenga en cuenta que los métodos del rebalance listener son llamados desde el hilo de sondeo de Kafka *y* bloquearán el hilo de la persona que llama hasta que se complete. Esto se debe a que el protocolo de reequilibrio tiene barreras de sincronización, y el uso de código asíncrono en un receptor de reequilibrio puede ejecutarse después de la barrera de sincronización."

#. type: Plain text
#: upstream/_guides/kafka.adoc:545
#, fuzzy
msgid "When topics/partitions are assigned or revoked from a consumer, it pauses the message delivery and resumes once the rebalance completes."
msgstr "Cuando se asignan o revocan temas/particiones de un consumidor, se pausa la entrega de mensajes y se reanuda una vez completado el reequilibrio."

#. type: Plain text
#: upstream/_guides/kafka.adoc:549
#, fuzzy
msgid "If the rebalance listener handles offset commit on behalf of the user (using the `NONE` commit strategy), the rebalance listener must commit the offset synchronously in the partitionsRevoked callback.  We also recommend applying the same logic when the application stops."
msgstr "Si el rebalance listener maneja la confirmación del offset en nombre del usuario (usando la estrategia de confirmación `NONE` ), el rebalance listener debe confirmar el offset de forma sincrónica en el callback partitionsRevoked. También recomendamos aplicar la misma lógica cuando la aplicación se detenga."

#. type: Plain text
#: upstream/_guides/kafka.adoc:551
#, fuzzy
msgid "Unlike the `ConsumerRebalanceListener` from Apache Kafka, the `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` methods pass the Kafka Consumer and the set of topics/partitions."
msgstr "A diferencia del `ConsumerRebalanceListener` de Apache Kafka, los métodos de `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` pasan el consumidor de Kafka y el conjunto de temas/particiones."

#. type: Plain text
#: upstream/_guides/kafka.adoc:555
#, fuzzy
msgid "In the following example we set up a consumer that always starts on messages from at most 10 minutes ago (or offset 0).  First we need to provide a bean that implements `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` and is annotated with `io.smallrye.common.annotation.Identifier`.  We then must configure our inbound connector to use this bean."
msgstr "En el siguiente ejemplo configuramos un consumidor que siempre se inicia con los mensajes de hace 10 minutos como máximo (o el offset 0). Primero tenemos que proporcionar un bean que implemente `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` y que esté anotado con `io.smallrye.common.annotation.Identifier`. Luego debemos configurar nuestro conector de entrada para que utilice este bean."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:559 upstream/_guides/kafka.adoc:609
#, no-wrap
msgid "package inbound;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:565
#, no-wrap
msgid ""
"import io.smallrye.common.annotation.Identifier;\n"
"import io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener;\n"
"import org.apache.kafka.clients.consumer.Consumer;\n"
"import org.apache.kafka.clients.consumer.OffsetAndTimestamp;\n"
"import org.apache.kafka.clients.consumer.TopicPartition;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:571
#, no-wrap
msgid ""
"import jakarta.enterprise.context.ApplicationScoped;\n"
"import java.util.Collection;\n"
"import java.util.HashMap;\n"
"import java.util.Map;\n"
"import java.util.logging.Logger;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:575
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"@Identifier(\"rebalanced-example.rebalancer\")\n"
"public class KafkaRebalancedConsumerRebalanceListener implements KafkaConsumerRebalanceListener {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:577
#, no-wrap
msgid "    private static final Logger LOGGER = Logger.getLogger(KafkaRebalancedConsumerRebalanceListener.class.getName());\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:589
#, no-wrap
msgid ""
"    /**\n"
"     * When receiving a list of partitions, will search for the earliest offset within 10 minutes\n"
"     * and seek the consumer to it.\n"
"     *\n"
"     * @param consumer   underlying consumer\n"
"     * @param partitions set of assigned topic partitions\n"
"     */\n"
"    @Override\n"
"    public void onPartitionsAssigned(Consumer<?, ?> consumer, Collection<TopicPartition> partitions) {\n"
"        long now = System.currentTimeMillis();\n"
"        long shouldStartAt = now - 600_000L; //10 minute ago\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:602
#, no-wrap
msgid ""
"        Map<TopicPartition, Long> request = new HashMap<>();\n"
"        for (TopicPartition partition : partitions) {\n"
"            LOGGER.info(\"Assigned \" + partition);\n"
"            request.put(partition, shouldStartAt);\n"
"        }\n"
"        Map<TopicPartition, OffsetAndTimestamp> offsets = consumer.offsetsForTimes(request);\n"
"        for (Map.Entry<TopicPartition, OffsetAndTimestamp> position : offsets.entrySet()) {\n"
"            long target = position.getValue() == null ? 0L : position.getValue().offset();\n"
"            LOGGER.info(\"Seeking position \" + target + \" for \" + position.getKey());\n"
"            consumer.seek(position.getKey(), target);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:613
#, no-wrap
msgid ""
"import io.smallrye.reactive.messaging.kafka.IncomingKafkaRecord;\n"
"import org.eclipse.microprofile.reactive.messaging.Acknowledgment;\n"
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:617
#, no-wrap
msgid ""
"import jakarta.enterprise.context.ApplicationScoped;\n"
"import java.util.concurrent.CompletableFuture;\n"
"import java.util.concurrent.CompletionStage;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:620
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class KafkaRebalancedConsumer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:628
#, no-wrap
msgid ""
"    @Incoming(\"rebalanced-example\")\n"
"    @Acknowledgment(Acknowledgment.Strategy.NONE)\n"
"    public CompletionStage<Void> consume(IncomingKafkaRecord<Integer, String> message) {\n"
"        // We don't need to ACK messages because in this example,\n"
"        // we set offset during consumer rebalance\n"
"        return CompletableFuture.completedFuture(null);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:634
#, fuzzy
msgid "To configure the inbound connector to use the provided listener, we either set the consumer rebalance listener’s identifier: `mp.messaging.incoming.rebalanced-example.consumer-rebalance-listener.name=rebalanced-example.rebalancer`"
msgstr "Para configurar el conector de entrada para que utilice la escucha proporcionada, establecemos el identificador de la escucha de reequilibrio del consumidor: `mp.messaging.incoming.rebalanced-example.consumer-rebalance-listener.name=rebalanced-example.rebalancer`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:636
#, fuzzy
msgid "Or have the listener’s name be the same as the group id:"
msgstr "O que el nombre del oyente sea el mismo que el identificador del grupo:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:638
#, fuzzy
msgid "`mp.messaging.incoming.rebalanced-example.group.id=rebalanced-example.rebalancer`"
msgstr "`mp.messaging.incoming.rebalanced-example.group.id=rebalanced-example.rebalancer`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:640
#, fuzzy
msgid "Setting the consumer rebalance listener’s name takes precedence over using the group id."
msgstr "La configuración del nombre del consumidor de rebalanceo tiene prioridad sobre el uso del id del grupo."

#. type: Title ====
#: upstream/_guides/kafka.adoc:641
#, fuzzy, no-wrap
msgid "Using unique consumer groups"
msgstr "Utilizar grupos de consumidores únicos"

#. type: Plain text
#: upstream/_guides/kafka.adoc:644
#, fuzzy
msgid "If you want to process all the records from a topic (from its beginning), you need:"
msgstr "Si quieres procesar todos los registros de un tema (desde su inicio), necesitas:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:646
#, fuzzy
msgid "to set `auto.offset.reset = earliest`"
msgstr "para establecer `auto.offset.reset = earliest`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:647
#, fuzzy
msgid "assign your consumer to a consumer group not used by any other application."
msgstr "asignar su consumidor a un grupo de consumidores que no sea utilizado por ninguna otra aplicación."

#. type: Plain text
#: upstream/_guides/kafka.adoc:650
#, fuzzy
msgid "Quarkus generates a UUID that changes between two executions (including in dev mode).  So, you are sure no other consumer uses it, and you receive a new unique group id every time your application starts."
msgstr "Quarkus genera un UUID que cambia entre dos ejecuciones (incluso en modo dev). Así, se asegura de que ningún otro consumidor lo utilice, y recibe un nuevo id de grupo único cada vez que su aplicación se inicia."

#. type: Plain text
#: upstream/_guides/kafka.adoc:652
#, fuzzy
msgid "You can use that generated UUID as the consumer group as follows:"
msgstr "Puede utilizar ese UUID generado como grupo de consumidores de la siguiente manera:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:657
#, no-wrap
msgid ""
"mp.messaging.incoming.your-channel.auto.offset.reset=earliest\n"
"mp.messaging.incoming.your-channel.group.id=${quarkus.uuid}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:660
#, fuzzy
msgid "If the `group.id` attribute is not set, it defaults the `quarkus.application.name` configuration property."
msgstr "Si no se establece el atributo `group.id`, se establece por defecto la propiedad de configuración `quarkus.application.name`."

#. type: Title ===
#: upstream/_guides/kafka.adoc:661
#, fuzzy, no-wrap
msgid "Receiving Kafka Records in Batches"
msgstr "Recepción de registros Kafka por lotes"

#. type: Plain text
#: upstream/_guides/kafka.adoc:665
#, fuzzy
msgid "By default, incoming methods receive each Kafka record individually.  Under the hood, Kafka consumer clients poll the broker constantly and receive records in batches, presented inside the `ConsumerRecords` container."
msgstr "Por defecto, los métodos entrantes reciben cada registro de Kafka individualmente. Bajo el capó, los clientes consumidores de Kafka sondean el broker constantemente y reciben registros en lotes, presentados dentro del contenedor `ConsumerRecords`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:667
#, fuzzy
msgid "In *batch* mode, your application can receive all the records returned by the consumer *poll* in one go."
msgstr "En el modo *por lotes*, su aplicación puede recibir todos los registros devueltos por el *sondeo de* consumidores de una sola vez."

#. type: Plain text
#: upstream/_guides/kafka.adoc:669
#, fuzzy
msgid "To achieve this you need to specify a compatible container type to receive all the data:"
msgstr "Para ello, es necesario especificar un tipo de contenedor compatible para recibir todos los datos:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:678
#, no-wrap
msgid ""
"@Incoming(\"prices\")\n"
"public void consume(List<Double> prices) {\n"
"    for (double price : prices) {\n"
"        // process price\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:682
#, fuzzy
msgid "The incoming method can also receive `Message<List<Payload>>`, `KafkaRecordBatch<Key, Payload>`, and `ConsumerRecords<Key, Payload>` types.  They give access to record details such as offset or timestamp:"
msgstr "El método de entrada también puede recibir `Message&amp;lt;List&amp;lt;Payload&amp;gt;&amp;gt;`, `KafkaRecordBatch&amp;lt;Key, Payload&amp;gt;` `ConsumerRecords&amp;lt;Key, Payload&amp;gt;` tipos. Permiten acceder a los detalles del registro, como el desplazamiento o la marca de tiempo:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:695
#, no-wrap
msgid ""
"@Incoming(\"prices\")\n"
"public CompletionStage<Void> consumeMessage(KafkaRecordBatch<String, Double> records) {\n"
"    for (KafkaRecord<String, Double> record : records) {\n"
"        String payload = record.getPayload();\n"
"        String topic = record.getTopic();\n"
"        // process messages\n"
"    }\n"
"    // ack will commit the latest offsets (per partition) of the batch.\n"
"    return records.ack();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:700
#, fuzzy
msgid "Note that the successful processing of the incoming record batch will commit the latest offsets for each partition received inside the batch.  The configured commit strategy will be applied for these records only."
msgstr "Tenga en cuenta que el procesamiento exitoso del lote de registros entrantes consignará los últimos desplazamientos para cada partición recibida dentro del lote. La estrategia de consignación configurada se aplicará únicamente a estos registros."

#. type: Plain text
#: upstream/_guides/kafka.adoc:702
#, fuzzy
msgid "Conversely, if the processing throws an exception, all messages are _nacked_, applying the failure strategy for all the records inside the batch."
msgstr "A la inversa, si el procesamiento lanza una excepción, todos los mensajes se _anulan_, aplicando la estrategia de fallo para todos los registros dentro del lote."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:707
#, fuzzy
msgid "Quarkus autodetects batch types for incoming channels and sets batch configuration automatically.  You can configure batch mode explicitly with `mp.messaging.incoming.$channel.batch` property."
msgstr "Quarkus autodetecta los tipos de lotes para los canales entrantes y establece la configuración de los lotes automáticamente. Puede configurar el modo de lote explícitamente con la propiedad `mp.messaging.incoming.$channel.batch`."

#. type: Title ===
#: upstream/_guides/kafka.adoc:710
#, fuzzy, no-wrap
msgid "Stateful processing with Checkpointing"
msgstr "Procesamiento por estados con Checkpointing"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:715
#, fuzzy
msgid "The `checkpoint` commit strategy is an experimental feature and can change in the future."
msgstr "La `KafkaClientService` es una API experimental y puede cambiar en el futuro."

#. type: Plain text
#: upstream/_guides/kafka.adoc:722
#, fuzzy
msgid "Smallrye Reactive Messaging `checkpoint` commit strategy allows consumer applications to process messages in a stateful manner, while also respecting Kafka consumer scalability.  An incoming channel with `checkpoint` commit strategy persists consumer offsets on an external xref:state-stores[state store], such as a relational database or a key-value store.  As a result of processing consumed records, the consumer application can accumulate an internal state for each topic-partition assigned to the Kafka consumer.  This local state will be periodically persisted to the state store and will be associated with the offset of the record that produced it."
msgstr "Smallrye Reactive Messaging `checkpoint` commit strategy permite a las aplicaciones consumidoras procesar mensajes de una manera con estado, respetando al mismo tiempo la escalabilidad del consumidor Kafka. Un canal entrante con la estrategia de commit `checkpoint` persiste los offsets del consumidor en un  link:#state-stores[almacén de estado] externo, como una base de datos relacional o un almacén de valores clave. Como resultado del procesamiento de los registros consumidos, la aplicación consumidora puede acumular un estado interno para cada topic-partition asignada al consumidor Kafka. Este estado local se persistirá periódicamente en el almacén de estado y se asociará con el desplazamiento del registro que lo produjo."

#. type: Plain text
#: upstream/_guides/kafka.adoc:726
#, fuzzy
msgid "This strategy does not commit any offsets to the Kafka broker, so when new partitions get assigned to the consumer, i.e. consumer restarts or consumer group instances scale, the consumer resumes the processing from the latest _checkpointed_ offset with its saved state."
msgstr "Esta estrategia no compromete ningún offset en el broker de Kafka, por lo que cuando se asignan nuevas particiones al consumidor, es decir, cuando se reinicia el consumidor o se escalan las instancias del grupo de consumidores, el consumidor reanuda el procesamiento desde el último offset _comprobado_ con su estado guardado."

#. type: Plain text
#: upstream/_guides/kafka.adoc:729
#, fuzzy
msgid "The `@Incoming` channel consumer code can manipulate the processing state through the `CheckpointMetadata` API.  For example, a consumer calculating the moving average of prices received on a Kafka topic would look the following:"
msgstr "El código del consumidor del canal `@Incoming` puede manipular el estado de procesamiento a través de la API `CheckpointMetadata`. Por ejemplo, un consumidor que calcule la media móvil de los precios recibidos en un tema Kafka tendría el siguiente aspecto:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:733 upstream/_guides/kafka.adoc:833
#: upstream/_guides/kafka.adoc:2480 upstream/_guides/kafka.adoc:2528
#: upstream/_guides/kafka.adoc:2569 upstream/_guides/kafka.adoc:2587
#: upstream/_guides/kafka.adoc:2617 upstream/_guides/kafka.adoc:2649
#: upstream/_guides/kafka.adoc:2668 upstream/_guides/kafka.adoc:2713
#: upstream/_guides/kafka.adoc:2756 upstream/_guides/kafka.adoc:2798
#: upstream/_guides/kafka.adoc:2905
#, no-wrap
msgid "package org.acme;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:735 upstream/_guides/kafka.adoc:2482
#: upstream/_guides/kafka.adoc:2530 upstream/_guides/kafka.adoc:2758
#, no-wrap
msgid "import java.util.concurrent.CompletionStage;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:740
#, no-wrap
msgid ""
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
"import org.eclipse.microprofile.reactive.messaging.Message;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:743
#, no-wrap
msgid ""
"import io.smallrye.reactive.messaging.kafka.KafkaRecord;\n"
"import io.smallrye.reactive.messaging.kafka.commit.CheckpointMetadata;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:746
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class MeanCheckpointConsumer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:751
#, no-wrap
msgid ""
"    @Incoming(\"prices\")\n"
"    public CompletionStage<Void> consume(Message<Double> record) {\n"
"        // Get the `CheckpointMetadata` from the incoming message\n"
"        CheckpointMetadata<AveragePrice> checkpoint = CheckpointMetadata.fromMessage(record);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:755
#, no-wrap
msgid ""
"        // `CheckpointMetadata` allows transforming the processing state\n"
"        // Applies the given function, starting from the value `0.0` when no previous state exists\n"
"        checkpoint.transform(new AveragePrice(), average -> average.update(record.getPayload()), /* persistOnAck */ true);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:760
#, no-wrap
msgid ""
"        // `persistOnAck` flag set to true, ack will persist the processing state\n"
"        // associated with the latest offset (per partition).\n"
"        return record.ack();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:764
#, no-wrap
msgid ""
"    static class AveragePrice {\n"
"        long count;\n"
"        double mean;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:771
#, no-wrap
msgid ""
"        AveragePrice update(double newPrice) {\n"
"            mean += ((newPrice - mean) / ++count);\n"
"            return this;\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:777
#, fuzzy
msgid "The `transform` method applies the transformation function to the current state, producing a changed state and registering it locally for checkpointing.  By default, the local state is persisted to the state store periodically, period specified by `auto.commit.interval.ms`, (default: 5000).  If `persistOnAck` flag is given, the latest state is persisted to the state store eagerly on message acknowledgment.  The `setNext` method works similarly directly setting the latest state."
msgstr "El método `transform` aplica la función de transformación al estado actual, produciendo un estado modificado y registrándolo localmente para su comprobación. Por defecto, el estado local se persiste en el almacén de estado periódicamente, período especificado por `auto.commit.interval.ms`, (por defecto: 5000). Si se indica `persistOnAck`, el estado más reciente se transfiere al almacén de estado de forma inmediata tras el acuse de recibo del mensaje. El método `setNext` funciona de forma similar estableciendo directamente el último estado."

#. type: Plain text
#: upstream/_guides/kafka.adoc:780
#, fuzzy
msgid "The checkpoint commit strategy tracks when a processing state is last persisted for each topic-partition.  If an outstanding state change can not be persisted for `checkpoint.unsynced-state-max-age.ms` (default: 10000), the channel is marked unhealthy."
msgstr "La estrategia de confirmación de puntos de control realiza un seguimiento de cuándo se persistió por última vez un estado de procesamiento para cada tema-partición. Si un cambio de estado pendiente no puede ser persistido por `checkpoint.unsynced-state-max-age.ms` (por defecto: 10000), el canal se marca como no saludable."

#. type: Title ====
#: upstream/_guides/kafka.adoc:782
#, fuzzy, no-wrap
msgid "State stores"
msgstr "Tiendas estatales"

#. type: Plain text
#: upstream/_guides/kafka.adoc:788
#, fuzzy
msgid "State store implementations determine where and how the processing states are persisted.  This is configured by the `mp.messaging.incoming.[channel-name].checkpoint.state-store` property.  The serialization of state objects depends on the state store implementation.  In order to instruct state stores for serialization can require configuring the class name of state objects using `mp.messaging.incoming.[channel-name].checkpoint.state-type` property."
msgstr "Las implementaciones del almacén de estados determinan dónde y cómo se persisten los estados de procesamiento. Esto se configura mediante la propiedad `mp.messaging.incoming.[channel-name].checkpoint.state-store`. La serialización de los objetos de estado depende de la implementación del almacén de estado. Con el fin de instruir a los almacenes de estado para la serialización puede requerir configurar el nombre de clase de los objetos de estado utilizando la propiedad `mp.messaging.incoming.[channel-name].checkpoint.state-type`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:790
#, fuzzy
msgid "Quarkus provides following state store implementations:"
msgstr "Quarkus proporciona las siguientes implementaciones de almacenes de estado:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:795
#, fuzzy
msgid "`quarkus-redis`: Uses the xref:redis-reference.adoc[`quarkus-redis-client`] extension to persist processing states.  Jackson is used to serialize processing state in Json. For complex objects it is required to configure the `checkpoint.state-type` property with the class name of the object.  By default, the state store uses the default redis client, but if a xref:redis-reference.adoc#default-and-named-clients[named client] is to be used, the client name can be specified using the `mp.messaging.incoming.[channel-name].checkpoint.quarkus-redis.client-name` property.  Processing states will be stored in Redis using the key naming scheme `[consumer-group-id]:[topic]:[partition]`."
msgstr "`quarkus-redis`: Utiliza la extensión  link:redis-reference.html[`quarkus-redis-client`] para persistir los estados de procesamiento. Jackson se utiliza para serializar el estado de procesamiento en Json. Para objetos complejos se requiere configurar la propiedad `checkpoint.state-type` con el nombre de la clase del objeto. Por defecto, el almacén de estados utiliza el cliente redis por defecto, pero si se quiere utilizar un  link:https://quarkus.io/guides/redis-reference#default-and-named-clients[cliente con nombre], se puede especificar el nombre del cliente utilizando la propiedad `mp.messaging.incoming.[channel-name].checkpoint.quarkus-redis.client-name`. Los estados de procesamiento se almacenarán en Redis utilizando el esquema de nomenclatura de claves `[consumer-group-id]:[topic]:[partition]`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:797 upstream/_guides/kafka.adoc:818
#, fuzzy
msgid "For example the configuration of the previous code would be the following:"
msgstr "Por ejemplo la configuración del código anterior sería la siguiente:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:810
#, no-wrap
msgid ""
"mp.messaging.incoming.prices.group.id=prices-checkpoint\n"
"# ...\n"
"mp.messaging.incoming.prices.commit-strategy=checkpoint\n"
"mp.messaging.incoming.prices.checkpoint.state-store=quarkus-redis\n"
"mp.messaging.incoming.prices.checkpoint.state-type=org.acme.MeanCheckpointConsumer.AveragePrice\n"
"# ...\n"
"# if using a named redis client\n"
"mp.messaging.incoming.prices.checkpoint.quarkus-redis.client-name=my-redis\n"
"quarkus.redis.my-redis.hosts=redis://localhost:7000\n"
"quarkus.redis.my-redis.password=<redis-pwd>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:816
#, fuzzy
msgid "`quarkus-hibernate-reactive`: Uses the xref:hibernate-reactive.adoc[`quarkus-hibernate-reactive`] extension to persist processing states.  Processing state objects are required to be a Jakarta Persistence entity and extend the `CheckpointEntity` class, which handles object identifiers composed of the consumer group id, topic and partition.  Therefore, the class name of the entity needs to be configured using the `checkpoint.state-type` property."
msgstr "`quarkus-hibernate-reactive`: Utiliza la extensión  link:hibernate-reactive.html[`quarkus-hibernate-reactive`] para persistir los estados de procesamiento. Se requiere que los objetos de estado de procesamiento sean una entidad JPA y extiendan la clase `CheckpointEntity`, que maneja identificadores de objetos compuestos por el id del grupo consumidor, el tema y la partición. Por lo tanto, el nombre de la clase de la entidad necesita ser configurado usando la propiedad `checkpoint.state-type`."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:826
#, no-wrap
msgid ""
"mp.messaging.incoming.prices.group.id=prices-checkpoint\n"
"# ...\n"
"mp.messaging.incoming.prices.commit-strategy=checkpoint\n"
"mp.messaging.incoming.prices.checkpoint.state-store=quarkus-hibernate-reactive\n"
"mp.messaging.incoming.prices.checkpoint.state-type=org.acme.AveragePriceEntity\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:829
#, fuzzy
msgid "With `AveragePriceEntity` being a Jakarta Persistence entity extending `CheckpointEntity`:"
msgstr "Siendo `AveragePriceEntity` una entidad JPA que extiende `CheckpointEntity`:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:835 upstream/_guides/kafka.adoc:2571
#: upstream/_guides/kafka.adoc:2651
#, no-wrap
msgid "import jakarta.persistence.Entity;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:837
#, fuzzy, no-wrap
msgid "import io.quarkus.smallrye.reactivemessaging.kafka.CheckpointEntity;\n"
msgstr "`io.smallrye.reactive.messaging.annotations.Blocking`"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:842
#, no-wrap
msgid ""
"@Entity\n"
"public class AveragePriceEntity extends CheckpointEntity {\n"
"    public long count;\n"
"    public double mean;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:848
#, no-wrap
msgid ""
"    public AveragePriceEntity update(double newPrice) {\n"
"        mean += ((newPrice - mean) / ++count);\n"
"        return this;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:852
#, fuzzy
msgid "`quarkus-hibernate-orm`: Uses the xref:hibernate-orm.adoc[`quarkus-hibernate-orm`] extension to persist processing states.  It is similar to the previous state store, but it uses Hibernate ORM instead of Hibernate Reactive."
msgstr "`quarkus-hibernate-orm`: Utiliza la extensión  link:hibernate-orm.html[`quarkus-hibernate-orm`] para persistir los estados de procesamiento. Es similar al almacén de estados anterior, pero utiliza Hibernate ORM en lugar de Hibernate Reactive."

#. type: Plain text
#: upstream/_guides/kafka.adoc:854
#, fuzzy
msgid "When configured, it can use a named `persistence-unit` for the checkpointing state store:"
msgstr "Cuando está configurado, puede utilizar un nombre `persistence-unit` para el almacén de estado de comprobación:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:868
#, no-wrap
msgid ""
"mp.messaging.incoming.prices.commit-strategy=checkpoint\n"
"mp.messaging.incoming.prices.checkpoint.state-store=quarkus-hibernate-orm\n"
"mp.messaging.incoming.prices.checkpoint.state-type=org.acme.AveragePriceEntity\n"
"mp.messaging.incoming.prices.checkpoint.quarkus-hibernate-orm.persistence-unit=prices\n"
"# ... Setup \"prices\" persistence unit\n"
"quarkus.datasource.\"prices\".db-kind=postgresql\n"
"quarkus.datasource.\"prices\".username=<your username>\n"
"quarkus.datasource.\"prices\".password=<your password>\n"
"quarkus.datasource.\"prices\".jdbc.url=jdbc:postgresql://localhost:5432/hibernate_orm_test\n"
"quarkus.hibernate-orm.\"prices\".datasource=prices\n"
"quarkus.hibernate-orm.\"prices\".packages=org.acme\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:872
#, fuzzy
msgid "For instructions on how to implement custom state stores, see https://smallrye.io/smallrye-reactive-messaging/3.22.0/kafka/receiving-kafka-records/#implementing-state-stores[Implementing State Stores]."
msgstr "Puede encontrar más detalles sobre la configuración de SmallRye Reactive Messaging en la  link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.1/kafka/kafka.html[documentación de SmallRye Reactive Messaging - Kafka Connector]."

#. type: Title ==
#: upstream/_guides/kafka.adoc:873
#, fuzzy, no-wrap
msgid "Sending messages to Kafka"
msgstr "Envío de mensajes a Kafka"

#. type: Plain text
#: upstream/_guides/kafka.adoc:876
#, fuzzy
msgid "Configuration for the Kafka connector outgoing channels is similar to that of incoming:"
msgstr "La configuración de los canales salientes del conector Kafka es similar a la de los entrantes:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:882
#, no-wrap
msgid ""
"%prod.kafka.bootstrap.servers=kafka:9092 <1>\n"
"mp.messaging.outgoing.prices-out.connector=smallrye-kafka <2>\n"
"mp.messaging.outgoing.prices-out.topic=prices <3>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:887
#, fuzzy
msgid "Configure the broker location for the production profile. You can configure it globally or per channel using `mp.messaging.outgoing.$channel.bootstrap.servers` property.  In dev mode and when running tests, xref:kafka-dev-services[Dev Services for Kafka] automatically starts a Kafka broker.  When not provided, this property defaults to `localhost:9092`."
msgstr "Configure la ubicación del broker para el perfil de producción. Puedes configurarlo globalmente o por canal usando la propiedad `mp.messaging.outgoing.$channel.bootstrap.servers`. En modo dev y cuando se ejecutan pruebas,  link:#kafka-dev-services[[kafka-dev-services]] inicia automáticamente un broker de Kafka. Cuando no se proporciona, esta propiedad es por defecto `localhost:9092`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:888
#, fuzzy
msgid "Configure the connector to manage the `prices-out` channel."
msgstr "Configure el conector para gestionar el canal `prices-out`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:889
#, fuzzy
msgid "By default, the topic name is same as the channel name. You can configure the topic attribute to override it."
msgstr "Por defecto, el nombre del tema es el mismo que el del canal. Puede configurar el atributo de tema para anularlo."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:894
#, fuzzy
msgid "Inside application configuration, channel names are unique.  Therefore, if you'd like to configure an incoming and outgoing channel on the same topic, you will need to name channels differently (like in the examples of this guide, `mp.messaging.incoming.prices` and `mp.messaging.outgoing.prices-out`)."
msgstr "Dentro de la configuración de la aplicación, los nombres de los canales son únicos. Por lo tanto, si desea configurar un canal de entrada y otro de salida en el mismo tema, deberá nombrar los canales de forma diferente (como en los ejemplos de esta guía, `mp.messaging.incoming.prices` y `mp.messaging.outgoing.prices-out`)."

#. type: Plain text
#: upstream/_guides/kafka.adoc:898
#, fuzzy
msgid "Then, your application can generate messages and publish them to the `prices-out` channel.  It can use `double` payloads as in the following snippet:"
msgstr "Entonces, su aplicación puede generar mensajes y publicarlos en el canal `prices-out`. Puede utilizar las cargas útiles de `double` como en el siguiente fragmento:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:903
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:907
#, no-wrap
msgid ""
"import jakarta.enterprise.context.ApplicationScoped;\n"
"import java.time.Duration;\n"
"import java.util.Random;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:910
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class KafkaPriceProducer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:912 upstream/_guides/kafka.adoc:1224
#: upstream/_guides/kafka.adoc:1264
#, no-wrap
msgid "    private final Random random = new Random();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:920
#, no-wrap
msgid ""
"    @Outgoing(\"prices-out\")\n"
"    public Multi<Double> generate() {\n"
"        // Build an infinite stream of random prices\n"
"        // It emits a price every second\n"
"        return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n"
"            .map(x -> random.nextDouble());\n"
"    }\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:927
#, fuzzy
msgid "You should not call methods annotated with `@Incoming` and/or `@Outgoing` directly from your code. They are invoked by the framework. Having user code invoking them would not have the expected outcome."
msgstr "No debe llamar a los métodos anotados con `@Incoming` y/o `@Outgoing` directamente desde su código. Son invocados por el framework. Tener código de usuario invocándolos no tendría el resultado esperado."

#. type: Plain text
#: upstream/_guides/kafka.adoc:931
#, fuzzy
msgid "Note that the `generate` method returns a `Multi<Double>`, which implements the Reactive Streams `Publisher` interface.  This publisher will be used by the framework to generate messages and send them to the configured Kafka topic."
msgstr "Observa que el método `generate` devuelve un `Multi&amp;lt;Double&amp;gt;`, que implementa la interfaz Reactive Streams `Publisher`. Este editor será utilizado por el framework para generar mensajes y enviarlos al tema Kafka configurado."

#. type: Plain text
#: upstream/_guides/kafka.adoc:933
#, fuzzy
msgid "Instead of returning a payload, you can return a `io.smallrye.reactive.messaging.kafka.Record` to send key/value pairs:"
msgstr "En lugar de devolver una carga útil, puede devolver un `io.smallrye.reactive.messaging.kafka.Record` para enviar pares clave/valor:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:941
#, no-wrap
msgid ""
"@Outgoing(\"out\")\n"
"public Multi<Record<String, Double>> generate() {\n"
"    return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n"
"        .map(x -> Record.of(\"my-key\", random.nextDouble()));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:944
#, fuzzy
msgid "Payload can be wrapped inside `org.eclipse.microprofile.reactive.messaging.Message` to have more control on the written records:"
msgstr "La carga útil se puede envolver dentro de `org.eclipse.microprofile.reactive.messaging.Message` para tener más control sobre los registros escritos:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:957
#, no-wrap
msgid ""
"@Outgoing(\"generated-price\")\n"
"public Multi<Message<Double>> generate() {\n"
"    return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n"
"            .map(x -> Message.of(random.nextDouble())\n"
"                    .addMetadata(OutgoingKafkaRecordMetadata.<String>builder()\n"
"                            .withKey(\"my-key\")\n"
"                            .withTopic(\"my-key-prices\")\n"
"                            .withHeaders(new RecordHeaders().add(\"my-header\", \"value\".getBytes()))\n"
"                            .build()));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:962
#, fuzzy
msgid "`OutgoingKafkaRecordMetadata` allows to set metadata attributes of the Kafka record, such as `key`, `topic`, `partition` or `timestamp`.  One use case is to dynamically select the destination topic of a message.  In this case, instead of configuring the topic inside your application configuration file, you need to use the outgoing metadata to set the name of the topic."
msgstr "`OutgoingKafkaRecordMetadata` permite establecer atributos de metadatos del registro Kafka, como `key`, `topic`, `partition` o `timestamp`. Un caso de uso es seleccionar dinámicamente el tema de destino de un mensaje. En este caso, en lugar de configurar el tema dentro del archivo de configuración de la aplicación, es necesario utilizar los metadatos de salida para establecer el nombre del tema."

#. type: Plain text
#: upstream/_guides/kafka.adoc:965
#, fuzzy
msgid "Other than method signatures returning a Reactive Stream `Publisher` (`Multi` being an implementation of `Publisher`), outgoing method can also return single message.  In this case the producer will use this method as generator to create an infinite stream."
msgstr "Además de las firmas de los métodos que devuelven un flujo reactivo `Publisher` ( `Multi` es una implementación de `Publisher`), el método de salida también puede devolver un solo mensaje. En este caso, el productor utilizará este método como generador para crear un flujo infinito."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:969
#, no-wrap
msgid "@Outgoing(\"prices-out\") T generate(); // T excluding void\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:971
#, no-wrap
msgid "@Outgoing(\"prices-out\") Message<T> generate();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:973
#, no-wrap
msgid "@Outgoing(\"prices-out\") Uni<T> generate();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:975
#, no-wrap
msgid "@Outgoing(\"prices-out\") Uni<Message<T>> generate();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:977
#, no-wrap
msgid "@Outgoing(\"prices-out\") CompletionStage<T> generate();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:979
#, no-wrap
msgid "@Outgoing(\"prices-out\") CompletionStage<Message<T>> generate();\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/kafka.adoc:981
#, fuzzy, no-wrap
msgid "Sending messages with @Emitter"
msgstr "Envío de mensajes con @Emitter"

#. type: Plain text
#: upstream/_guides/kafka.adoc:984
#, fuzzy
msgid "Sometimes, you need to have an imperative way of sending messages."
msgstr "A veces, es necesario tener una forma imperativa de enviar mensajes."

#. type: Plain text
#: upstream/_guides/kafka.adoc:987
#, fuzzy
msgid "For example, if you need to send a message to a stream when receiving a POST request inside a REST endpoint.  In this case, you cannot use `@Outgoing` because your method has parameters."
msgstr "Por ejemplo, si necesitas enviar un mensaje a un stream cuando recibes una petición POST dentro de un endpoint REST. En este caso, no puede utilizar `@Outgoing` porque su método tiene parámetros."

#. type: Plain text
#: upstream/_guides/kafka.adoc:989
#, fuzzy
msgid "For this, you can use an `Emitter`."
msgstr "Para ello, puede utilizar un `Emitter`."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:994 upstream/_guides/kafka.adoc:2490
#: upstream/_guides/kafka.adoc:2538 upstream/_guides/kafka.adoc:2765
#, no-wrap
msgid ""
"import org.eclipse.microprofile.reactive.messaging.Channel;\n"
"import org.eclipse.microprofile.reactive.messaging.Emitter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1000 upstream/_guides/kafka.adoc:1045
#: upstream/_guides/kafka.adoc:1079
#, no-wrap
msgid ""
"import jakarta.inject.Inject;\n"
"import jakarta.ws.rs.POST;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.Consumes;\n"
"import jakarta.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1007
#, no-wrap
msgid ""
"    @Inject\n"
"    @Channel(\"price-create\")\n"
"    Emitter<Double> priceEmitter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1014
#, no-wrap
msgid ""
"    @POST\n"
"    @Consumes(MediaType.TEXT_PLAIN)\n"
"    public void addPrice(Double price) {\n"
"        CompletionStage<Void> ack = priceEmitter.send(price);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1017
#, fuzzy
msgid "Sending a payload returns a `CompletionStage`, completed when the message is acked. If the message transmission fails, the `CompletionStage` is completed exceptionally with the reason of the nack."
msgstr "El envío de una carga útil devuelve un `CompletionStage`, completado cuando el mensaje es aceptado. Si la transmisión del mensaje falla, el `CompletionStage` se completa excepcionalmente con la razón del nack."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:1021
#, fuzzy
msgid "The `Emitter` configuration is done the same way as the other stream configuration used by `@Incoming` and `@Outgoing`."
msgstr "La configuración de `Emitter` se realiza de la misma manera que la otra configuración de flujo utilizada por `@Incoming` y `@Outgoing`."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:1030
#, fuzzy
msgid "Using the `Emitter` you are sending messages from your imperative code to reactive messaging.  These messages are stored in a queue until they are sent.  If the Kafka producer client can't keep up with messages trying to be sent over to Kafka, this queue can become a memory hog and you may even run out of memory.  You can use `@OnOverflow` to configure back-pressure strategy.  It lets you configure the size of the queue (default is 256) and the strategy to apply when the buffer size is reached. Available strategies are `DROP`, `LATEST`, `FAIL`, `BUFFER`, `UNBOUNDED_BUFFER` and `NONE`."
msgstr "Utilizando el `Emitter` estás enviando mensajes desde tu código imperativo a la mensajería reactiva. Estos mensajes se almacenan en una cola hasta que se envían. Si el cliente productor de Kafka no puede mantener el ritmo de los mensajes que intentan ser enviados a Kafka, esta cola puede convertirse en un acaparador de memoria y puede incluso quedarse sin memoria. Puedes utilizar `@OnOverflow` para configurar la estrategia de back-pressure. Te permite configurar el tamaño de la cola (por defecto es 256) y la estrategia a aplicar cuando se alcanza el tamaño del buffer. Las estrategias disponibles son `DROP`, `LATEST`, `FAIL`, `BUFFER`, `UNBOUNDED_BUFFER` y `NONE`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1033
#, fuzzy
msgid "With the `Emitter` API, you can also encapsulate the outgoing payload inside `Message<T>`. As with the previous examples, `Message` lets you handle the ack/nack cases differently."
msgstr "Con la API `Emitter`, también puedes encapsular la carga útil saliente dentro de `Message&amp;lt;T&amp;gt;`. Como en los ejemplos anteriores, `Message` te permite manejar los casos de ack/nack de forma diferente."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1039
#, no-wrap
msgid ""
"import java.util.concurrent.CompletableFuture;\n"
"import org.eclipse.microprofile.reactive.messaging.Channel;\n"
"import org.eclipse.microprofile.reactive.messaging.Emitter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1050
#, no-wrap
msgid "    @Inject @Channel(\"price-create\") Emitter<Double> priceEmitter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1065
#, no-wrap
msgid ""
"    @POST\n"
"    @Consumes(MediaType.TEXT_PLAIN)\n"
"    public void addPrice(Double price) {\n"
"        priceEmitter.send(Message.of(price)\n"
"            .withAck(() -> {\n"
"                // Called when the message is acked\n"
"                return CompletableFuture.completedFuture(null);\n"
"            })\n"
"            .withNack(throwable -> {\n"
"                // Called when the message is nacked\n"
"                return CompletableFuture.completedFuture(null);\n"
"            }));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1069
#, fuzzy
msgid "If you prefer using Reactive Stream APIs, you can use `MutinyEmitter` that will return `Uni<Void>` from the `send` method.  You can therefore use Mutiny APIs for handling downstream messages and errors."
msgstr "Si prefiere utilizar las APIs de flujo reactivo, puede utilizar `MutinyEmitter` que devolverá `Uni&amp;lt;Void&amp;gt;` desde el método `send`. Por lo tanto, puedes utilizar las APIs de Mutiny para manejar los mensajes y errores de la corriente descendente."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1073 upstream/_guides/kafka.adoc:1321
#: upstream/_guides/kafka.adoc:2803
#, no-wrap
msgid "import org.eclipse.microprofile.reactive.messaging.Channel;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1081
#, no-wrap
msgid "import io.smallrye.reactive.messaging.MutinyEmitter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1088
#, no-wrap
msgid ""
"    @Inject\n"
"    @Channel(\"price-create\")\n"
"    MutinyEmitter<Double> priceEmitter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1097
#, no-wrap
msgid ""
"    @POST\n"
"    @Consumes(MediaType.TEXT_PLAIN)\n"
"    public Uni<String> addPrice(Double price) {\n"
"        return quoteRequestEmitter.send(price)\n"
"                .map(x -> \"ok\")\n"
"                .onFailure().recoverWithItem(\"ko\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1101
#, fuzzy
msgid "It is also possible to block on sending the event to the emitter with the `sendAndAwait` method.  It will only return from the method when the event is acked or nacked by the receiver."
msgstr "También es posible bloquear el envío del evento al emisor con el método `sendAndAwait`. Sólo se retornará del método cuando el evento sea accionado o nacked por el receptor."

#. type: Block title
#: upstream/_guides/kafka.adoc:1103
#, fuzzy, no-wrap
msgid "Deprecation"
msgstr "Depreciación"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:1106
#, fuzzy
msgid "The `io.smallrye.reactive.messaging.annotations.Emitter`, `io.smallrye.reactive.messaging.annotations.Channel` and `io.smallrye.reactive.messaging.annotations.OnOverflow` classes are now deprecated and replaced by:"
msgstr "Las clases `io.smallrye.reactive.messaging.annotations.Emitter`, `io.smallrye.reactive.messaging.annotations.Channel` y `io.smallrye.reactive.messaging.annotations.OnOverflow` están ahora obsoletas y se sustituyen por:"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:1108
#, fuzzy
msgid "`org.eclipse.microprofile.reactive.messaging.Emitter`"
msgstr "`org.eclipse.microprofile.reactive.messaging.Emitter`"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:1109
#, fuzzy
msgid "`org.eclipse.microprofile.reactive.messaging.Channel`"
msgstr "`org.eclipse.microprofile.reactive.messaging.Channel`"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:1110
#, fuzzy
msgid "`org.eclipse.microprofile.reactive.messaging.OnOverflow`"
msgstr "`org.eclipse.microprofile.reactive.messaging.OnOverflow`"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:1112
#, fuzzy
msgid "The new `Emitter.send` method returns a `CompletionStage` completed when the produced message is acknowledged."
msgstr "El nuevo método `Emitter.send` devuelve un `CompletionStage` completado cuando el mensaje producido es reconocido."

#. type: Block title
#: upstream/_guides/kafka.adoc:1115
#, fuzzy, no-wrap
msgid "Depreciation"
msgstr "Depreciación"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:1118
#, fuzzy
msgid "`MutinyEmitter#send(Message msg)` method is deprecated in favor of following methods receiving `Message` for emitting:"
msgstr "`MutinyEmitter#send(Message msg)` queda obsoleto en favor de los siguientes métodos que reciben `Message` para su emisión:"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:1120
#, fuzzy
msgid "`<M extends Message<? extends T>> Uni<Void> sendMessage(M msg)`"
msgstr "`&amp;lt;M extends Message&amp;lt;? extends T&amp;gt;&amp;gt; Uni&amp;lt;Void&amp;gt; sendMessage(M msg)`"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:1121
#, fuzzy
msgid "`<M extends Message<? extends T>> void sendMessageAndAwait(M msg)`"
msgstr "`&amp;lt;M extends Message&amp;lt;? extends T&amp;gt;&amp;gt; void sendMessageAndAwait(M msg)`"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:1122
#, fuzzy
msgid "`<M extends Message<? extends T>> Cancellable sendMessageAndForget(M msg)`"
msgstr "`&amp;lt;M extends Message&amp;lt;? extends T&amp;gt;&amp;gt; Cancellable sendMessageAndForget(M msg)`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1126
#, fuzzy
msgid "More information on how to use `Emitter` can be found in https://smallrye.io/smallrye-reactive-messaging/latest/concepts/emitter/[SmallRye Reactive Messaging – Emitters and Channels]"
msgstr "Puede encontrar más información sobre cómo utilizar `Emitter` en  link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.1/emitter/emitter.html#_emitter_and_channel[SmallRye Reactive Messaging - Emitters and Channels]"

#. type: Title ===
#: upstream/_guides/kafka.adoc:1127
#, fuzzy, no-wrap
msgid "Write Acknowledgement"
msgstr "Escriba el acuse de recibo"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1131
#, fuzzy
msgid "When Kafka broker receives a record, its acknowledgement can take time depending on the configuration.  Also, it stores in-memory the records that cannot be written."
msgstr "Cuando el broker Kafka recibe un registro, su acuse de recibo puede tardar dependiendo de la configuración. Además, almacena en memoria los registros que no se pueden escribir."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1134
#, fuzzy
msgid "By default, the connector does wait for Kafka to acknowledge the record to continue the processing (acknowledging the received Message).  You can disable this by setting the `waitForWriteCompletion` attribute to `false`."
msgstr "Por defecto, el conector espera a que Kafka reconozca el registro para continuar el procesamiento (reconociendo el mensaje recibido). Puede desactivar esto estableciendo el atributo `waitForWriteCompletion` a `false`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1136
#, fuzzy
msgid "Note that the `acks` attribute has a huge impact on the record acknowledgement."
msgstr "Tenga en cuenta que el atributo `acks` tiene un gran impacto en el reconocimiento del registro."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1138
#, fuzzy
msgid "If a record cannot be written, the message is nacked."
msgstr "Si no se puede escribir un registro, el mensaje es nacked."

#. type: Title ===
#: upstream/_guides/kafka.adoc:1139
#, fuzzy, no-wrap
msgid "Backpressure"
msgstr "Contrapresión"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1143
#, fuzzy
msgid "The Kafka outbound connector handles back-pressure, monitoring the number of in-flight messages waiting to be written to the Kafka broker.  The number of in-flight messages is configured using the `max-inflight-messages` attribute and defaults to 1024."
msgstr "El conector de salida de Kafka maneja la presión de retorno, monitoreando el número de mensajes en vuelo que esperan ser escritos en el broker de Kafka. El número de mensajes en vuelo se configura mediante el atributo `max-inflight-messages` y su valor predeterminado es 1024."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1148
#, fuzzy
msgid "The connector only sends that amount of messages concurrently.  No other messages will be sent until at least one in-flight message gets acknowledged by the broker.  Then, the connector writes a new message to Kafka when one of the broker’s in-flight messages get acknowledged.  Be sure to configure Kafka’s `batch.size` and `linger.ms` accordingly."
msgstr "El conector sólo envía esa cantidad de mensajes simultáneamente. No se enviará ningún otro mensaje hasta que el corredor reconozca al menos un mensaje en vuelo. Entonces, el conector escribe un nuevo mensaje en Kafka cuando uno de los mensajes en vuelo del broker es reconocido. Asegúrese de configurar las direcciones `batch.size` y `linger.ms` de Kafka en consecuencia."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1151
#, fuzzy
msgid "You can also remove the limit of in-flight messages by setting `max-inflight-messages` to `0`.  However, note that the Kafka producer may block if the number of requests reaches `max.in.flight.requests.per.connection`."
msgstr "También puede eliminar el límite de mensajes en vuelo configurando `max-inflight-messages` a `0`. Sin embargo, tenga en cuenta que el productor de Kafka puede bloquearse si el número de peticiones alcanza `max.in.flight.requests.per.connection`."

#. type: Title ===
#: upstream/_guides/kafka.adoc:1152
#, fuzzy, no-wrap
msgid "Retrying message dispatch"
msgstr "Reintento de envío de mensajes"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1157
#, fuzzy
msgid "When the Kafka producer receives an error from the server, if it is a transient, recoverable error, the client will retry sending the batch of messages.  This behavior is controlled by `retries` and `retry.backoff.ms` parameters.  In addition to this, SmallRye Reactive Messaging will retry individual messages on recoverable errors, depending on the `retries` and `delivery.timeout.ms` parameters."
msgstr "Cuando el productor de Kafka recibe un error del servidor, si se trata de un error transitorio y recuperable, el cliente volverá a intentar enviar el lote de mensajes. Este comportamiento está controlado por los parámetros `retries` y `retry.backoff.ms`. Además, SmallRye Reactive Messaging reintentará enviar mensajes individuales en caso de errores recuperables, dependiendo de los parámetros `retries` y `delivery.timeout.ms`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1160
#, fuzzy
msgid "Note that while having retries in a reliable system is a best practice, the `max.in.flight.requests.per.connection` parameter defaults to `5`, meaning that the order of the messages is not guaranteed.  If the message order is a must for your use case, setting `max.in.flight.requests.per.connection` to `1` will make sure a single batch of messages is sent at a time, in the expense of limiting the throughput of the producer."
msgstr "Ten en cuenta que aunque tener reintentos en un sistema fiable es una buena práctica, el parámetro `max.in.flight.requests.per.connection` viene por defecto a `5`, lo que significa que el orden de los mensajes no está garantizado. Si el orden de los mensajes es una necesidad para tu caso de uso, establecer `max.in.flight.requests.per.connection` a `1` se asegurará de que se envíe un solo lote de mensajes a la vez, a costa de limitar el rendimiento del productor."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1162
#, fuzzy
msgid "For applying retry mechanism on processing errors, see the section on xref:retrying-processing[Retrying processing]."
msgstr "Para aplicar el mecanismo de reintento en los errores de procesamiento, véase la sección  link:#retrying-processing[[reintentar-procesar]]."

#. type: Title ===
#: upstream/_guides/kafka.adoc:1163
#, fuzzy, no-wrap
msgid "Handling Serialization Failures"
msgstr "Gestión de los fallos de serialización"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1167
#, fuzzy
msgid "For Kafka producer client serialization failures are not recoverable, thus the message dispatch is not retried. In these cases you may need to apply a failure strategy for the serializer.  To achieve this, you need to create a bean implementing `SerializationFailureHandler<T>` interface:"
msgstr "Para el cliente productor de Kafka los fallos de serialización no son recuperables, por lo que el envío de mensajes no se reintenta. En estos casos es necesario aplicar una estrategia de fallos para el serializador. Para ello, es necesario crear un bean que implemente la interfaz `SerializationFailureHandler&amp;lt;T&amp;gt;`:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1174
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"@Identifier(\"failure-fallback\") // Set the name of the failure handler\n"
"public class MySerializationFailureHandler\n"
"    implements SerializationFailureHandler<JsonObject> { // Specify the expected type\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1183
#, no-wrap
msgid ""
"    @Override\n"
"    public byte[] decorateSerialization(Uni<byte[]> serialization, String topic, boolean isKey,\n"
"        String serializer, Object data, Headers headers) {\n"
"        return serialization\n"
"                    .onFailure().retry().atMost(3)\n"
"                    .await().indefinitely();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1186
#, fuzzy
msgid "To use this failure handler, the bean must be exposed with the `@Identifier` qualifier and the connector configuration must specify the attribute `mp.messaging.outgoing.$channel.[key|value]-serialization-failure-handler` (for key or value serializers)."
msgstr "Para utilizar este gestor de fallos, el bean debe estar expuesto con el calificador `@Identifier` y la configuración del conector debe especificar el atributo `mp.messaging.outgoing.$channel.[key|value]-serialization-failure-handler` (para serializadores de claves o valores)."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1189
#, fuzzy
msgid "The handler is called with details of the serialization, including the action represented as `Uni<byte[]>`.  Note that the method must await on the result and return the serialized byte array."
msgstr "El manejador es llamado con los detalles de la serialización, incluyendo la acción representada como `Uni&amp;lt;byte[]&amp;gt;`. Tenga en cuenta que el método debe esperar en el resultado y devolver la matriz de bytes serializada."

#. type: Title ===
#: upstream/_guides/kafka.adoc:1190
#, fuzzy, no-wrap
msgid "In-memory channels"
msgstr "Canales en memoria"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1195
#, fuzzy
msgid "In some use cases, it is convenient to use the messaging patterns to transfer messages inside the same application.  When you don't connect a channel to a messaging backend like Kafka, everything happens in-memory, and the streams are created by chaining methods together.  Each chain is still a reactive stream and enforces the back-pressure protocol."
msgstr "En algunos casos de uso, es conveniente utilizar los patrones de mensajería para transferir mensajes dentro de la misma aplicación. Cuando no se conecta un canal a un backend de mensajería como Kafka, todo ocurre en memoria, y los flujos se crean encadenando métodos. Cada cadena sigue siendo un flujo reactivo y aplica el protocolo de retroalimentación."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1199
#, fuzzy
msgid "The framework verifies that the producer/consumer chain is complete, meaning that if the application writes messages into an in-memory channel (using a method with only `@Outgoing`, or an `Emitter`), it must also consume the messages from within the application (using a method with only `@Incoming` or using an unmanaged stream)."
msgstr "El marco de trabajo verifica que la cadena productor/consumidor está completa, lo que significa que si la aplicación escribe mensajes en un canal en memoria (usando un método con sólo `@Outgoing`, o un `Emitter`), también debe consumir los mensajes desde dentro de la aplicación (usando un método con sólo `@Incoming` o usando un flujo no gestionado)."

#. type: Title ===
#: upstream/_guides/kafka.adoc:1201
#, fuzzy, no-wrap
msgid "Broadcasting messages on multiple consumers"
msgstr "Difusión de mensajes en múltiples consumidores"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1206
#, fuzzy
msgid "By default, a channel can be linked to a single consumer, using `@Incoming` method or `@Channel` reactive stream.  At application startup, channels are verified to form a chain of consumers and producers with single consumer and producer.  You can override this behavior by setting `mp.messaging.$channel.broadcast=true` on a channel."
msgstr "Por defecto, un canal puede estar vinculado a un solo consumidor, utilizando el método `@Incoming` o el flujo reactivo `@Channel`. Al iniciar la aplicación, los canales se verifican para formar una cadena de consumidores y productores con un solo consumidor y productor. Puedes anular este comportamiento configurando `mp.messaging.$channel.broadcast=true` en un canal."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1208
#, fuzzy
msgid "In case of in-memory channels, `@Broadcast` annotation can be used on the `@Outgoing` method. For example,"
msgstr "En el caso de los canales en memoria, se puede utilizar la anotación `@Broadcast` en el método `@Outgoing`. Por ejemplo,"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1212 upstream/_guides/kafka.adoc:1255
#, no-wrap
msgid "import java.util.Random;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1217 upstream/_guides/kafka.adoc:1284
#: upstream/_guides/kafka.adoc:1388 upstream/_guides/kafka.adoc:1416
#, no-wrap
msgid ""
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1219
#, no-wrap
msgid "import io.smallrye.reactive.messaging.annotations.Broadcast;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1222
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class MultipleConsumer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1230
#, no-wrap
msgid ""
"    @Outgoing(\"in-memory-channel\")\n"
"    @Broadcast\n"
"    double generate() {\n"
"        return random.nextDouble();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1235
#, no-wrap
msgid ""
"    @Incoming(\"in-memory-channel\")\n"
"    void consumeAndLog(double price) {\n"
"        System.out.println(price);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1242
#, no-wrap
msgid ""
"    @Incoming(\"in-memory-channel\")\n"
"    @Outgoing(\"prices2\")\n"
"    double consumeAndSend(double price) {\n"
"        return price;\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:1248
#, fuzzy
msgid "Reciprocally, multiple producers on the same channel can be merged by setting `mp.messaging.incoming.$channel.merge=true`.  On the `@Incoming` methods, you can control how multiple channels are merged using the `@Merge` annotation."
msgstr "Recíprocamente, se pueden fusionar múltiples productores en el mismo canal estableciendo `mp.messaging.incoming.$channel.merge=true`. En los métodos de `@Incoming`, se puede controlar cómo se fusionan varios canales utilizando la anotación `@Merge`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1251
msgid "Repeating the `@Outgoing` annotation on outbound or processing methods allows another way of dispatching messages to multiple outgoing channels:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1259
#, fuzzy, no-wrap
msgid "import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
msgstr "`org.eclipse.microprofile.reactive.messaging.Emitter`"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1262
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class MultipleProducers {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1270
#, no-wrap
msgid ""
"    @Outgoing(\"generated\")\n"
"    @Outgoing(\"generated-2\")\n"
"    double priceBroadcast() {\n"
"        return random.nextDouble();\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1277
msgid "In the previous example generated price will be broadcast to both outbound channels.  The following example selectively sends messages to multiple outgoing channels using the `Targeted` container object, containing key as channel name and value as message payload."
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1286
#, fuzzy, no-wrap
msgid "import io.smallrye.reactive.messaging.Targeted;\n"
msgstr "`io.smallrye.reactive.messaging.annotations.Blocking`"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1289
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class TargetedProducers {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1302
#, no-wrap
msgid ""
"    @Incoming(\"in\")\n"
"    @Outgoing(\"out1\")\n"
"    @Outgoing(\"out2\")\n"
"    @Outgoing(\"out3\")\n"
"    public Targeted process(double price) {\n"
"        Targeted targeted = Targeted.of(\"out1\", \"Price: \" + price,\n"
"                \"out2\", \"Quote: \" + price);\n"
"        if (price > 90.0) {\n"
"            return targeted.with(\"out3\", price);\n"
"        }\n"
"        return targeted;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1307
msgid "Note that xref:serialization-autodetection[the auto-detection for Kafka serializers] doesn't work for signatures using the `Targeted`."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1309
#, fuzzy
msgid "For more details on using multiple outgoings, please refer to the http://smallrye.io/smallrye-reactive-messaging/4.10.0/concepts/outgoings/[SmallRye Reactive Messaging documentation]."
msgstr "Puede encontrar información detallada sobre el uso de la anotación `@Blocking` en  link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.1/advanced/blocking.html[SmallRye Reactive Messaging - Handling blocking execution]."

#. type: Title ===
#: upstream/_guides/kafka.adoc:1310
#, fuzzy, no-wrap
msgid "Kafka Transactions"
msgstr "@Transactional"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1315
#, fuzzy
msgid "Kafka transactions enable atomic writes to multiple Kafka topics and partitions.  The Kafka connector provides `KafkaTransactions` custom emitter for writing Kafka records inside a transaction.  It can be injected as a regular emitter `@Channel`:"
msgstr "Las transacciones de Kafka permiten realizar escrituras atómicas en múltiples temas y particiones de Kafka. El conector Kafka proporciona `KafkaTransactions` emisor personalizado para escribir registros Kafka dentro de una transacción. Se puede inyectar como un emisor normal `@Channel`:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1325
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Uni;\n"
"import io.smallrye.reactive.messaging.kafka.KafkaRecord;\n"
"import io.smallrye.reactive.messaging.kafka.transactions.KafkaTransactions;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1328
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class KafkaTransactionalProducer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1331
#, no-wrap
msgid ""
"    @Channel(\"tx-out-example\")\n"
"    KafkaTransactions<String> txProducer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1340
#, no-wrap
msgid ""
"    public Uni<Void> emitInTransaction() {\n"
"        return txProducer.withTransaction(emitter -> {\n"
"            emitter.send(KafkaRecord.of(1, \"a\"));\n"
"            emitter.send(KafkaRecord.of(2, \"b\"));\n"
"            emitter.send(KafkaRecord.of(3, \"c\"));\n"
"            return Uni.createFrom().voidItem();\n"
"        });\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1345
#, fuzzy
msgid "The function given to the `withTransaction` method receives a `TransactionalEmitter` for producing records, and returns a `Uni` that provides the result of the transaction."
msgstr "La función dada al método `withTransaction` recibe un `TransactionalEmitter` para producir registros, y devuelve un `Uni` que proporciona el resultado de la transacción."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1347
#, fuzzy
msgid "If the processing completes successfully, the producer is flushed and the transaction is committed."
msgstr "Si el proceso se completa con éxito, el productor se vacía y la transacción se confirma."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1348
#, fuzzy
msgid "If the processing throws an exception, returns a failing `Uni`, or marks the `TransactionalEmitter` for abort, the transaction is aborted."
msgstr "Si el procesamiento lanza una excepción, devuelve un fallo `Uni`, o marca la `TransactionalEmitter` para abortar, la transacción se cancela."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1352
#, fuzzy
msgid "Kafka transactional producers require configuring `acks=all` client property, and a unique id for `transactional.id`, which implies `enable.idempotence=true`.  When Quarkus detects the use of `KafkaTransactions` for an outgoing channel it configures these properties on the channel, providing a default value of `\"${quarkus.application.name}-${channelName}\"` for `transactional.id` property."
msgstr "Los productores transaccionales de Kafka requieren configurar la propiedad de cliente `acks=all`, y un id único para `transactional.id`, lo que implica `enable.idempotence=true`. Cuando Quarkus detecta el uso de `KafkaTransactions` para un canal de salida, configura estas propiedades en el canal, proporcionando un valor por defecto de `\"${quarkus.application.name}-${channelName}\"` para la propiedad `transactional.id`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1354
#, fuzzy
msgid "Note that for production use the `transactional.id` must be unique across all application instances."
msgstr "Tenga en cuenta que para el uso en producción el `transactional.id` debe ser único en todas las instancias de la aplicación."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:1362
#, fuzzy
msgid "While a normal message emitter would support concurrent calls to `send` methods and consequently queues outgoing messages to be written to Kafka, a `KafkaTransactions` emitter only supports one transaction at a time.  A transaction is considered in progress from the call to the `withTransaction` until the returned `Uni` results in success or failure.  While a transaction is in progress, subsequent calls to the `withTransaction`, including nested ones inside the given function, will throw `IllegalStateException`."
msgstr "Mientras que un emisor de mensajes normal soportaría llamadas concurrentes a los métodos de `send` y, en consecuencia, pondría en cola los mensajes salientes para ser escritos en Kafka, un emisor de `KafkaTransactions` sólo soporta una transacción a la vez. Se considera que una transacción está en curso desde la llamada a `withTransaction` hasta que el `Uni` devuelto resulta en éxito o en fracaso. Mientras una transacción está en curso, las siguientes llamadas a `withTransaction`, incluyendo las anidadas dentro de la función dada, lanzarán `IllegalStateException`."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:1366
#, fuzzy
msgid "Note that in Reactive Messaging, the execution of processing methods, is already serialized, unless `@Blocking(ordered = false)` is used.  If `withTransaction` can be called concurrently, for example from a REST endpoint, it is recommended to limit the concurrency of the execution.  This can be done using the `@Bulkhead` annotation from xref:smallrye-fault-tolerance.adoc[_Microprofile Fault Tolerance_]."
msgstr "Tenga en cuenta que en Reactive Messaging, la ejecución de los métodos de procesamiento, ya está serializada, a menos que se utilice `@Blocking(ordered = false)`. Si `withTransaction` puede ser llamado concurrentemente, por ejemplo desde un endpoint REST, se recomienda limitar la concurrencia de la ejecución. Esto puede hacerse utilizando la anotación `@Bulkhead` de  link:https://quarkus.io/guides/smallrye-fault-tolerance[_Microprofile Fault Tolerance_]."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:1368
#, fuzzy
msgid "An example usage can be found in xref:chaining-kafka-transactions-with-hibernate-reactive-transactions[Chaining Kafka Transactions with Hibernate Reactive transactions]."
msgstr "Se puede encontrar un ejemplo de uso en  link:#chaining-kafka-transactions-with-hibernate-reactive-transactions[[chaining-kafka-transactions-with-hibernate-reactive-transactions]]."

#. type: Title ====
#: upstream/_guides/kafka.adoc:1370
#, fuzzy, no-wrap
msgid "Transaction-aware consumers"
msgstr "Consumidores conscientes de las transacciones"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1373
#, fuzzy
msgid "If you'd like to consume records only written and committed inside a Kafka transaction you need to configure the `isolation.level` property on the incoming channel as such:"
msgstr "Si desea consumir registros sólo escritos y consignados dentro de una transacción Kafka, debe configurar la propiedad `isolation.level` en el canal de entrada como tal:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1377
#, no-wrap
msgid "mp.messaging.incoming.prices-in.isolation.level=read_committed\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:1379
#, fuzzy, no-wrap
msgid "Processing Messages"
msgstr "Procesamiento de mensajes"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1383
#, fuzzy
msgid "Applications streaming data often need to consume some events from a topic, process them and publish the result to a different topic.  A processor method can be simply implemented using both the `@Incoming` and `@Outgoing` annotations:"
msgstr "Las aplicaciones que transmiten datos a menudo necesitan consumir algunos eventos de un tema, procesarlos y publicar el resultado en un tema diferente. Un método de procesamiento puede implementarse de forma sencilla utilizando las anotaciones `@Incoming` y `@Outgoing`:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1393 upstream/_guides/kafka.adoc:1421
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class PriceProcessor {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1395 upstream/_guides/kafka.adoc:1423
#: upstream/_guides/kafka.adoc:1634
#, no-wrap
msgid "    private static final double CONVERSION_RATE = 0.88;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1401
#, no-wrap
msgid ""
"    @Incoming(\"price-in\")\n"
"    @Outgoing(\"price-out\")\n"
"    public double process(double price) {\n"
"        return price * CONVERSION_RATE;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1407
#, fuzzy
msgid "The parameter of the `process` method is the incoming message payload, whereas the return value will be used as the outgoing message payload.  Previously mentioned signatures for parameter and return types are also supported, such as `Message<T>`, `Record<K, V>`, etc."
msgstr "El parámetro del método `process` es la carga útil del mensaje entrante, mientras que el valor de retorno se utilizará como carga útil del mensaje saliente. También se admiten las firmas mencionadas anteriormente para los tipos de parámetro y retorno, como `Message&amp;lt;T&amp;gt;`, `Record&amp;lt;K, V&amp;gt;`, etc."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1409
#, fuzzy
msgid "You can apply asynchronous stream processing by consuming and returning reactive stream `Multi<T>` type:"
msgstr "Puede aplicar el procesamiento asíncrono de flujos consumiendo y devolviendo flujos reactivos del tipo `Multi&amp;lt;T&amp;gt;`:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1418
#, no-wrap
msgid "import io.smallrye.mutiny.Multi;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1429
#, no-wrap
msgid ""
"    @Incoming(\"price-in\")\n"
"    @Outgoing(\"price-out\")\n"
"    public Multi<Double> process(Multi<Integer> prices) {\n"
"        return prices.filter(p -> p > 100).map(p -> p * CONVERSION_RATE);\n"
"    }\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/kafka.adoc:1433
#, fuzzy, no-wrap
msgid "Propagating Record Key"
msgstr "Propagación de la clave de registro"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1436
#, fuzzy
msgid "When processing messages, you can propagate incoming record key to the outgoing record."
msgstr "Al procesar los mensajes, puede propagar la clave del registro de entrada al registro de salida."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1439
#, fuzzy
msgid "Enabled with `mp.messaging.outgoing.$channel.propagate-record-key=true` configuration, record key propagation produces the outgoing record with the same _key_ as the incoming record."
msgstr "Si se activa con la configuración de `mp.messaging.outgoing.$channel.propagate-record-key=true`, la propagación de la clave del registro produce el registro saliente con la misma _clave_ que el registro entrante."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1442
#, fuzzy
msgid "If the outgoing record already contains a _key_, it *won't be overridden* by the incoming record key.  If the incoming record does have a _null_ key, the `mp.messaging.outgoing.$channel.key` property is used."
msgstr "Si el registro saliente ya contiene una _clave_, ésta *no será anulada* por la clave del registro entrante. Si el registro entrante sí tiene una clave _nula_, se utilizará la propiedad `mp.messaging.outgoing.$channel.key`."

#. type: Title ===
#: upstream/_guides/kafka.adoc:1443
#, fuzzy, no-wrap
msgid "Exactly-Once Processing"
msgstr "Reintento de procesamiento"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1447
#, fuzzy
msgid "Kafka Transactions allows managing consumer offsets inside a transaction, together with produced messages.  This enables coupling a consumer with a transactional producer in a _consume-transform-produce_ pattern, also known as *exactly-once processing*."
msgstr "Kafka Transactions permite gestionar los desplazamientos de los consumidores dentro de una transacción, junto con los mensajes producidos. Esto permite acoplar un consumidor con un productor transaccional en un patrón de _consumo-transformación-producción_, también conocido como *procesamiento exactamente único*."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1449
#, fuzzy
msgid "The `KafkaTransactions` custom emitter provides a way to apply exactly-once processing to an incoming Kafka message inside a transaction."
msgstr "El emisor personalizado `KafkaTransactions` proporciona una forma de aplicar un procesamiento exactamente único a un mensaje Kafka entrante dentro de una transacción."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1451
#, fuzzy
msgid "The following example includes a batch of Kafka records inside a transaction."
msgstr "El siguiente ejemplo incluye un lote de registros Kafka dentro de una transacción."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1459
#, no-wrap
msgid ""
"import org.eclipse.microprofile.reactive.messaging.Channel;\n"
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
"import org.eclipse.microprofile.reactive.messaging.OnOverflow;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1464
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Uni;\n"
"import io.smallrye.reactive.messaging.kafka.KafkaRecord;\n"
"import io.smallrye.reactive.messaging.kafka.KafkaRecordBatch;\n"
"import io.smallrye.reactive.messaging.kafka.transactions.KafkaTransactions;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1467
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class KafkaExactlyOnceProcessor {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1471
#, no-wrap
msgid ""
"    @Channel(\"prices-out\")\n"
"    @OnOverflow(value = OnOverflow.Strategy.BUFFER, bufferSize = 500) // <3>\n"
"    KafkaTransactions<Integer> txProducer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1481
#, no-wrap
msgid ""
"    @Incoming(\"prices-in\")\n"
"    public Uni<Void> emitInTransaction(KafkaRecordBatch<String, Integer> batch) { // <1>\n"
"        return txProducer.withTransactionAndAck(batch, emitter -> { // <2>\n"
"            for (KafkaRecord<String, Integer> record : batch) {\n"
"                emitter.send(KafkaRecord.of(record.getKey(), record.getPayload() + 1)); // <3>\n"
"            }\n"
"            return Uni.createFrom().voidItem();\n"
"        });\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1487
#, fuzzy
msgid "It is recommended to use exactly-once processing along with the batch consumption mode.  While it is possible to use it with a single Kafka message, it'll have a significant performance impact."
msgstr "Se recomienda utilizar el procesamiento \"exactly-once\" junto con el modo de consumo por lotes. Aunque es posible utilizarlo con un solo mensaje de Kafka, tendrá un impacto significativo en el rendimiento."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1488
#, fuzzy
msgid "The consumed `KafkaRecordBatch` message is passed to the `KafkaTransactions#withTransactionAndAck` in order to handle the offset commits and message acks."
msgstr "El mensaje consumido de `KafkaRecordBatch` se pasa a `KafkaTransactions#withTransactionAndAck` para manejar los commits y los acks de los mensajes."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1491
#, fuzzy
msgid "The `send` method writes records to Kafka inside the transaction, without waiting for send receipt from the broker.  Messages pending to be written to Kafka will be buffered, and flushed before committing the transaction.  It is therefore recommended configuring the `@OnOverflow` `bufferSize` in order to fit enough messages, for example the `max.poll.records`, maximum amount of records returned in a batch."
msgstr "El método `send` escribe registros en Kafka dentro de la transacción, sin esperar a la recepción del envío por parte del broker. Los mensajes pendientes de escribir en Kafka se almacenarán en el buffer, y se descargarán antes de consignar la transacción. Por lo tanto, se recomienda configurar el método `@OnOverflow` `bufferSize` con el fin de que quepan suficientes mensajes, por ejemplo el `max.poll.records`, cantidad máxima de registros devueltos en un lote."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1493
#, fuzzy
msgid "If the processing completes successfully, _before committing the transaction_, the topic partition offsets of the given batch message will be committed to the transaction."
msgstr "Si el procesamiento se completa con éxito, _antes de consignar la_ transacción, los offsets de partición de temas del mensaje de lote dado se consignarán en la transacción."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1494
#, fuzzy
msgid "If the processing needs to abort, _after aborting the transaction_, the consumer's position is reset to the last committed offset, effectively resuming the consumption from that offset. If no consumer offset has been committed to a topic-partition, the consumer's position is reset to the beginning of the topic-partition, _even if the offset reset policy is `latest`_."
msgstr "Si el procesamiento necesita ser abortado, _después de abortar la transacción_, la posición del consumidor se restablece al último offset comprometido, reanudando efectivamente el consumo desde ese offset. Si no se ha comprometido ningún desplazamiento del consumidor en una partición de temas, la posición del consumidor se restablece al principio de la partición de temas, _incluso si la política de restablecimiento del desplazamiento es `última`_."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1497
#, fuzzy
msgid "When using exactly-once processing, consumed message offset commits are handled by the transaction and therefore the application should not commit offsets through other means.  The consumer should have `enable.auto.commit=false` (the default) and set explicitly `commit-strategy=ignore`:"
msgstr "Cuando se utiliza el procesamiento \"exactly-once\", los commits de los mensajes consumidos son manejados por la transacción y, por lo tanto, la aplicación no debería comprometer los offsets a través de otros medios. El consumidor debe tener `enable.auto.commit=false` (el valor por defecto) y establecer explícitamente `commit-strategy=ignore`:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1502
#, no-wrap
msgid ""
"mp.messaging.incoming.prices-in.commit-strategy=ignore\n"
"mp.messaging.incoming.prices-in.failure-strategy=ignore\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/kafka.adoc:1504
#, fuzzy, no-wrap
msgid "Error handling for the exactly-once processing"
msgstr "Tratamiento de errores para el procesamiento de exactamente una vez"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1508
#, fuzzy
msgid "The `Uni` returned from the `KafkaTransactions#withTransaction` will yield a failure if the transaction fails and is aborted.  The application can choose to handle the error case, but if a failing `Uni` is returned from the `@Incoming` method, the incoming channel will effectively fail and stop the reactive stream."
msgstr "El `Uni` devuelto desde el `KafkaTransactions#withTransaction` dará un fallo si la transacción falla y es abortada. La aplicación puede elegir manejar el caso de error, pero si se devuelve un `Uni` fallido desde el método `@Incoming`, el canal de entrada fallará efectivamente y detendrá el flujo reactivo."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1512
#, fuzzy
msgid "The `KafkaTransactions#withTransactionAndAck` method acks and nacks the message but will *not* return a failing `Uni`.  Nacked messages will be handled by the failure strategy of the incoming channel, (see xref:error-handling[Error Handling Strategies]).  Configuring `failure-strategy=ignore` simply resets the Kafka consumer to the last committed offsets and resumes the consumption from there."
msgstr "El método `KafkaTransactions#withTransactionAndAck` acciona y naca el mensaje pero *no* devolverá un fallo `Uni`. Los mensajes nacked serán manejados por la estrategia de fallos del canal entrante, (ver  link:#error-handling[[error-handling]]). La configuración de `failure-strategy=ignore` simplemente restablece el consumidor de Kafka a las últimas compensaciones comprometidas y reanuda el consumo desde allí."

#. type: Title ==
#: upstream/_guides/kafka.adoc:1515
#, fuzzy, no-wrap
msgid "Accessing Kafka clients directly"
msgstr "Acceso directo a los clientes de Kafka"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1519
#, fuzzy
msgid "In rare cases, you may need to access the underlying Kafka clients.  `KafkaClientService` provides thread-safe access to `Producer` and `Consumer`."
msgstr "En casos excepcionales, es posible que necesite acceder a los clientes de Kafka subyacentes. `KafkaClientService` proporciona un acceso a prueba de hilos a `Producer` y `Consumer`."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1525
#, no-wrap
msgid ""
"import jakarta.enterprise.context.ApplicationScoped;\n"
"import jakarta.enterprise.event.Observes;\n"
"import jakarta.inject.Inject;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1527
#, no-wrap
msgid "import org.apache.kafka.clients.producer.ProducerRecord;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1532
#, no-wrap
msgid ""
"import io.quarkus.runtime.StartupEvent;\n"
"import io.smallrye.reactive.messaging.kafka.KafkaClientService;\n"
"import io.smallrye.reactive.messaging.kafka.KafkaConsumer;\n"
"import io.smallrye.reactive.messaging.kafka.KafkaProducer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1535
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class PriceSender {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1538
#, no-wrap
msgid ""
"    @Inject\n"
"    KafkaClientService clientService;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1545
#, no-wrap
msgid ""
"    void onStartup(@Observes StartupEvent startupEvent) {\n"
"        KafkaProducer<String, Double> producer = clientService.getProducer(\"generated-price\");\n"
"        producer.runOnSendingThread(client -> client.send(new ProducerRecord<>(\"prices\", 2.4)))\n"
"            .await().indefinitely();\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:1550
#, fuzzy
msgid "The `KafkaClientService` is an experimental API and can change in the future."
msgstr "La `KafkaClientService` es una API experimental y puede cambiar en el futuro."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1553
#, fuzzy
msgid "You can also get the Kafka configuration injected to your application and create Kafka producer, consumer and admin clients directly:"
msgstr "También puede obtener la configuración de Kafka inyectada en su aplicación y crear clientes productores, consumidores y administradores de Kafka directamente:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1560
#, no-wrap
msgid ""
"import io.smallrye.common.annotation.Identifier;\n"
"import org.apache.kafka.clients.admin.AdminClient;\n"
"import org.apache.kafka.clients.admin.AdminClientConfig;\n"
"import org.apache.kafka.clients.admin.KafkaAdminClient;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1566
#, no-wrap
msgid ""
"import jakarta.enterprise.context.ApplicationScoped;\n"
"import jakarta.enterprise.inject.Produces;\n"
"import jakarta.inject.Inject;\n"
"import java.util.HashMap;\n"
"import java.util.Map;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1569
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class KafkaClients {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1573
#, no-wrap
msgid ""
"    @Inject\n"
"    @Identifier(\"default-kafka-broker\")\n"
"    Map<String, Object> config;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1584
#, no-wrap
msgid ""
"    @Produces\n"
"    AdminClient getAdmin() {\n"
"        Map<String, Object> copy = new HashMap<>();\n"
"        for (Map.Entry<String, Object> entry : config.entrySet()) {\n"
"            if (AdminClientConfig.configNames().contains(entry.getKey())) {\n"
"                copy.put(entry.getKey(), entry.getValue());\n"
"            }\n"
"        }\n"
"        return KafkaAdminClient.create(copy);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1591
#, fuzzy
msgid "The `default-kafka-broker` configuration map contains all application properties prefixed with `kafka.` or `KAFKA_`.  For more configuration options check out xref:kafka-configuration-resolution[Kafka Configuration Resolution]."
msgstr "El mapa de configuración `default-kafka-broker` contiene todas las propiedades de la aplicación prefijadas con `kafka.` o `KAFKA_`. Para más opciones de configuración, consulte  link:#kafka-configuration-resolution[[kafka-configuration-resolution]]."

#. type: Title ==
#: upstream/_guides/kafka.adoc:1593
#, fuzzy, no-wrap
msgid "JSON serialization"
msgstr "Serialización JSON"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1596
#, fuzzy
msgid "Quarkus has built-in capabilities to deal with JSON Kafka messages."
msgstr "Quarkus tiene capacidades incorporadas para tratar con mensajes JSON Kafka."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1598
#, fuzzy
msgid "Imagine we have a `Fruit` data class as follows:"
msgstr "Imaginemos que tenemos una clase de datos `Fruit` como la siguiente:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1602
#, no-wrap
msgid "public class Fruit {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1605
#, no-wrap
msgid ""
"    public String name;\n"
"    public int price;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1608
#, no-wrap
msgid ""
"    public Fruit() {\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1614
#, no-wrap
msgid ""
"    public Fruit(String name, int price) {\n"
"        this.name = name;\n"
"        this.price = price;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1617
#, fuzzy
msgid "And we want to use it to receive messages from Kafka, make some price transformation, and send messages back to Kafka."
msgstr "Y queremos usarlo para recibir mensajes de Kafka, hacer alguna transformación de precios, y enviar mensajes de vuelta a Kafka."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1623
#, no-wrap
msgid ""
"import io.smallrye.reactive.messaging.annotations.Broadcast;\n"
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1632
#, no-wrap
msgid ""
"/**\n"
"* A bean consuming data from the \"fruit-in\" channel and applying some price conversion.\n"
"* The result is pushed to the \"fruit-out\" channel.\n"
"*/\n"
"@ApplicationScoped\n"
"public class FruitProcessor {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1642
#, no-wrap
msgid ""
"    @Incoming(\"fruit-in\")\n"
"    @Outgoing(\"fruit-out\")\n"
"    @Broadcast\n"
"    public Fruit process(Fruit fruit) {\n"
"        fruit.price = fruit.price * CONVERSION_RATE;\n"
"        return fruit;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1647
#, fuzzy
msgid "To do this, we will need to set up JSON serialization with Jackson or JSON-B."
msgstr "Para ello, necesitaremos configurar la serialización JSON con Jackson o JSON-B."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1649
#, fuzzy
msgid "With JSON serialization correctly configured, you can also use `Publisher<Fruit>` and `Emitter<Fruit>`."
msgstr "Con la serialización JSON correctamente configurada, también se puede utilizar `Publisher&amp;lt;Fruit&amp;gt;` y `Emitter&amp;lt;Fruit&amp;gt;`."

#. type: Title ===
#: upstream/_guides/kafka.adoc:1651
#, fuzzy, no-wrap
msgid "Serializing via Jackson"
msgstr "Serialización a través de Jackson"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1656
#, fuzzy
msgid "Quarkus has built-in support for JSON serialization and deserialization based on Jackson.  It will also xref:serialization-generation[generate] the serializer and deserializer for you, so you do not have to configure anything.  When generation is disabled, you can use the provided `ObjectMapperSerializer` and `ObjectMapperDeserializer` as explained below."
msgstr "Quarkus tiene soporte incorporado para la serialización y deserialización de JSON basado en Jackson. También  link:#serialization-generation[generará] el serializador y el deserializador por ti, así que no tienes que configurar nada. Cuando la generación está deshabilitada, puedes usar los `ObjectMapperSerializer` y `ObjectMapperDeserializer` proporcionados como se explica a continuación."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1659
#, fuzzy
msgid "There is an existing `ObjectMapperSerializer` that can be used to serialize all data objects via Jackson.  You may create an empty subclass if you want to use xref:serialization-autodetection[Serializer/deserializer autodetection]."
msgstr "Hay un `ObjectMapperSerializer` existente que se puede utilizar para serializar todos los objetos de datos a través de Jackson. Puedes crear una subclase vacía si quieres usar  link:#serialization-autodetection[[serialización-autodetección]]."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1663
#, fuzzy
msgid "By default, the `ObjectMapperSerializer` serializes null as the `\"null\"` String, this can be customized by setting the Kafka configuration property `json.serialize.null-as-null=true` which will serialize null as `null`.  This is handy when using a compacted topic, as `null` is used as a tombstone to know which messages delete during compaction phase."
msgstr "Por defecto, `ObjectMapperSerializer` serializa null como la cadena `\"null\"`, esto puede personalizarse estableciendo la propiedad de configuración de Kafka `json.serialize.null-as-null=true` que serializará null como `null`. Esto es útil cuando se utiliza un tema compactado, ya que `null` se utiliza como lápida para saber qué mensajes se eliminan durante la fase de compactación."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1666
#, fuzzy
msgid "The corresponding deserializer class needs to be subclassed.  So, let's create a `FruitDeserializer` that extends the `ObjectMapperDeserializer`."
msgstr "La clase deserializadora correspondiente necesita ser subclasificada. Por lo tanto, vamos a crear un `FruitDeserializer` que extienda el `ObjectMapperDeserializer`."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1670 upstream/_guides/kafka.adoc:1701
#, no-wrap
msgid "package com.acme.fruit.jackson;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1672 upstream/_guides/kafka.adoc:2619
#: upstream/_guides/kafka.adoc:2715
#, no-wrap
msgid "import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1678 upstream/_guides/kafka.adoc:2625
#: upstream/_guides/kafka.adoc:2721
#, no-wrap
msgid ""
"public class FruitDeserializer extends ObjectMapperDeserializer<Fruit> {\n"
"    public FruitDeserializer() {\n"
"        super(Fruit.class);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1681
#, fuzzy
msgid "Finally, configure your channels to use the Jackson serializer and deserializer."
msgstr "Por último, configure sus canales para utilizar el serializador y el deserializador de Jackson."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1687
#, no-wrap
msgid ""
"# Configure the Kafka source (we read from it)\n"
"mp.messaging.incoming.fruit-in.topic=fruit-in\n"
"mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jackson.FruitDeserializer\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1691
#, no-wrap
msgid ""
"# Configure the Kafka sink (we write to it)\n"
"mp.messaging.outgoing.fruit-out.topic=fruit-out\n"
"mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.ObjectMapperSerializer\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1695
#, fuzzy
msgid "Now, your Kafka messages will contain a Jackson serialized representation of your `Fruit` data object.  In this case, the `deserializer` configuration is not necessary as the xref:serialization-autodetection[Serializer/deserializer autodetection] is enabled by default."
msgstr "Ahora, tus mensajes de Kafka contarán con una representación serializada de Jackson de tu objeto de datos `Fruit`. En este caso, la configuración de `deserializer` no es necesaria ya que la  link:#serialization-autodetection[[serialización-autodetección] ] está habilitada por defecto."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1697
#, fuzzy
msgid "If you want to deserialize a list of fruits, you need to create a deserializer with a Jackson `TypeReference` denoted the generic collection used."
msgstr "Si quieres deserializar una lista de frutas, necesitas crear un deserializador con un Jackson `TypeReference` que denote la colección genérica utilizada."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1705
#, no-wrap
msgid ""
"import java.util.List;\n"
"import com.fasterxml.jackson.core.type.TypeReference;\n"
"import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1711
#, no-wrap
msgid ""
"public class ListOfFruitDeserializer extends ObjectMapperDeserializer<List<Fruit>> {\n"
"    public ListOfFruitDeserializer() {\n"
"        super(new TypeReference<List<Fruit>>() {});\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/kafka.adoc:1714
#, fuzzy, no-wrap
msgid "Serializing via JSON-B"
msgstr "Serialización mediante JSON-B"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1717
#, fuzzy
msgid "First, you need to include the `quarkus-jsonb` extension."
msgstr "En primer lugar, debe incluir la extensión `quarkus-jsonb`."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1725
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-jsonb</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1731
#, no-wrap
msgid "implementation(\"io.quarkus:quarkus-jsonb\")\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1735
#, fuzzy
msgid "There is an existing `JsonbSerializer` that can be used to serialize all data objects via JSON-B.  You may create an empty subclass if you want to use xref:serialization-autodetection[Serializer/deserializer autodetection]."
msgstr "Hay un `JsonbSerializer` existente que se puede utilizar para serializar todos los objetos de datos a través de JSON-B. Puedes crear una subclase vacía si quieres usar  link:#serialization-autodetection[[serialización-autodetección]]."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1739
#, fuzzy
msgid "By default, the `JsonbSerializer` serializes null as the `\"null\"` String, this can be customized by setting the Kafka configuration property `json.serialize.null-as-null=true` which will serialize null as `null`.  This is handy when using a compacted topic, as `null` is used as a tombstone to know which messages delete during compaction phase."
msgstr "Por defecto, `JsonbSerializer` serializa null como la cadena `\"null\"`, esto puede personalizarse estableciendo la propiedad de configuración de Kafka `json.serialize.null-as-null=true` que serializará null como `null`. Esto es útil cuando se utiliza un tema compactado, ya que `null` se utiliza como lápida para saber qué mensajes se eliminan durante la fase de compactación."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1742
#, fuzzy
msgid "The corresponding deserializer class needs to be subclassed.  So, let's create a `FruitDeserializer` that extends the generic `JsonbDeserializer`."
msgstr "La clase deserializadora correspondiente necesita ser subclasificada. Por lo tanto, vamos a crear un `FruitDeserializer` que extienda el genérico `JsonbDeserializer`."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1746
#, no-wrap
msgid "package com.acme.fruit.jsonb;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1748
#, no-wrap
msgid "import io.quarkus.kafka.client.serialization.JsonbDeserializer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1754
#, no-wrap
msgid ""
"public class FruitDeserializer extends JsonbDeserializer<Fruit> {\n"
"    public FruitDeserializer() {\n"
"        super(Fruit.class);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1757
#, fuzzy
msgid "Finally, configure your channels to use the JSON-B serializer and deserializer."
msgstr "Por último, configura tus canales para que utilicen el serializador y deserializador JSON-B."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1764
#, no-wrap
msgid ""
"# Configure the Kafka source (we read from it)\n"
"mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n"
"mp.messaging.incoming.fruit-in.topic=fruit-in\n"
"mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jsonb.FruitDeserializer\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1769
#, no-wrap
msgid ""
"# Configure the Kafka sink (we write to it)\n"
"mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n"
"mp.messaging.outgoing.fruit-out.topic=fruit-out\n"
"mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1772
#, fuzzy
msgid "Now, your Kafka messages will contain a JSON-B serialized representation of your `Fruit` data object."
msgstr "Ahora, sus mensajes Kafka contarán con una representación serializada JSON-B de su objeto de datos `Fruit`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1774
#, fuzzy
msgid "If you want to deserialize a list of fruits, you need to create a deserializer with a `Type` denoted the generic collection used."
msgstr "Si quieres deserializar una lista de frutas, necesitas crear un deserializador con un `Type` que denote la colección genérica utilizada."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1782
#, no-wrap
msgid ""
"package com.acme.fruit.jsonb;\n"
"import java.lang.reflect.Type;\n"
"import java.util.ArrayList;\n"
"import java.util.List;\n"
"import io.quarkus.kafka.client.serialization.JsonbDeserializer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1788
#, no-wrap
msgid ""
"public class ListOfFruitDeserializer extends JsonbDeserializer<List<Fruit>> {\n"
"    public ListOfFruitDeserializer() {\n"
"        super(new ArrayList<MyEntity>() {}.getClass().getGenericSuperclass());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1792
#, fuzzy
msgid "If you don't want to create a deserializer for each data object, you can use the generic `io.vertx.kafka.client.serialization.JsonObjectDeserializer` that will deserialize to a `io.vertx.core.json.JsonObject`. The corresponding serializer can also be used: `io.vertx.kafka.client.serialization.JsonObjectSerializer`."
msgstr "Si no se quiere crear un deserializador para cada objeto de datos, se puede utilizar el genérico `io.vertx.kafka.client.serialization.JsonObjectDeserializer` que deserializará a un `io.vertx.core.json.JsonObject`. También se puede utilizar el serializador correspondiente: `io.vertx.kafka.client.serialization.JsonObjectSerializer`."

#. type: Title ==
#: upstream/_guides/kafka.adoc:1793
#, fuzzy, no-wrap
msgid "Avro Serialization"
msgstr "Serialización Avro"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1796 upstream/_guides/kafka.adoc:1890
#, fuzzy
msgid "This is described in a dedicated guide: xref:kafka-schema-registry-avro.adoc[Using Apache Kafka with Schema Registry and Avro]."
msgstr "Esto se describe en una guía dedicada:  link:kafka-schema-registry-avro.html[Uso de Apache Kafka con Schema Registry y Avro]."

#. type: Title ==
#: upstream/_guides/kafka.adoc:1798
#, fuzzy, no-wrap
msgid "Serializer/deserializer autodetection"
msgstr "Autodetección del serializador/deserializador"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1802
#, fuzzy
msgid "When using SmallRye Reactive Messaging with Kafka (`io.quarkus:quarkus-smallrye-reactive-messaging-kafka`), Quarkus can often automatically detect the correct serializer and deserializer class.  This autodetection is based on declarations of `@Incoming` and `@Outgoing` methods, as well as injected ``@Channel``s."
msgstr "Cuando se utiliza SmallRye Reactive Messaging con Kafka ( `io.quarkus:quarkus-smallrye-reactive-messaging-kafka`), Quarkus puede a menudo detectar automáticamente la clase correcta de serializador y deserializador. Esta autodetección se basa en las declaraciones de los métodos `@Incoming` y `@Outgoing`, así como en los inyectados `@Channel`s."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1804
#, fuzzy
msgid "For example, if you declare"
msgstr "Por ejemplo, si declara"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1811
#, no-wrap
msgid ""
"@Outgoing(\"generated-price\")\n"
"public Multi<Integer> generate() {\n"
"    ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1814
#, fuzzy
msgid "and your configuration indicates that the `generated-price` channel uses the `smallrye-kafka` connector, then Quarkus will automatically set the `value.serializer` to Kafka's built-in `IntegerSerializer`."
msgstr "y su configuración indica que el canal `generated-price` utiliza el conector `smallrye-kafka`, entonces Quarkus configurará automáticamente el `value.serializer` con el `IntegerSerializer` incorporado de Kafka."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1816
#, fuzzy
msgid "Similarly, if you declare"
msgstr "Del mismo modo, si se declara"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1823
#, no-wrap
msgid ""
"@Incoming(\"my-kafka-records\")\n"
"public void consume(KafkaRecord<Long, byte[]> record) {\n"
"    ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1826
#, fuzzy
msgid "and your configuration indicates that the `my-kafka-records` channel uses the `smallrye-kafka` connector, then Quarkus will automatically set the `key.deserializer` to Kafka's built-in `LongDeserializer`, as well as the `value.deserializer` to `ByteArrayDeserializer`."
msgstr "y su configuración indica que el canal `my-kafka-records` utiliza el conector `smallrye-kafka`, entonces Quarkus configurará automáticamente el `key.deserializer` al `LongDeserializer` incorporado de Kafka, así como el `value.deserializer` a `ByteArrayDeserializer`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1828
#, fuzzy
msgid "Finally, if you declare"
msgstr "Por último, si declara"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1834
#, no-wrap
msgid ""
"@Inject\n"
"@Channel(\"price-create\")\n"
"Emitter<Double> priceEmitter;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1837
#, fuzzy
msgid "and your configuration indicates that the `price-create` channel uses the `smallrye-kafka` connector, then Quarkus will automatically set the `value.serializer` to Kafka's built-in `DoubleSerializer`."
msgstr "y su configuración indica que el canal `price-create` utiliza el conector `smallrye-kafka`, entonces Quarkus configurará automáticamente el `value.serializer` con el `DoubleSerializer` incorporado de Kafka."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1839
#, fuzzy
msgid "The full set of types supported by the serializer/deserializer autodetection is:"
msgstr "El conjunto completo de tipos soportados por la autodetección del serializador/deserializador es:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1841
#, fuzzy
msgid "`short` and `java.lang.Short`"
msgstr "`short` y `java.lang.Short`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1842
#, fuzzy
msgid "`int` and `java.lang.Integer`"
msgstr "`int` y `java.lang.Integer`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1843
#, fuzzy
msgid "`long` and `java.lang.Long`"
msgstr "`long` y `java.lang.Long`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1844
#, fuzzy
msgid "`float` and `java.lang.Float`"
msgstr "`float` y `java.lang.Float`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1845
#, fuzzy
msgid "`double` and `java.lang.Double`"
msgstr "`double` y `java.lang.Double`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1846
#, fuzzy
msgid "`byte[]`"
msgstr "`byte[]`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1847
#, fuzzy
msgid "`java.lang.String`"
msgstr "`java.lang.String`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1848
#, fuzzy
msgid "`java.util.UUID`"
msgstr "`java.util.UUID`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1849
#, fuzzy
msgid "`java.nio.ByteBuffer`"
msgstr "`java.nio.ByteBuffer`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1850
#, fuzzy
msgid "`org.apache.kafka.common.utils.Bytes`"
msgstr "`org.apache.kafka.common.utils.Bytes`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1851
#, fuzzy
msgid "`io.vertx.core.buffer.Buffer`"
msgstr "`io.vertx.core.buffer.Buffer`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1852
#, fuzzy
msgid "`io.vertx.core.json.JsonObject`"
msgstr "`io.vertx.core.json.JsonObject`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1853
#, fuzzy
msgid "`io.vertx.core.json.JsonArray`"
msgstr "`io.vertx.core.json.JsonArray`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1854
#, fuzzy
msgid "classes for which a direct implementation of `org.apache.kafka.common.serialization.Serializer<T>` / `org.apache.kafka.common.serialization.Deserializer<T>` is present."
msgstr "clases para las que existe una implementación directa de `org.apache.kafka.common.serialization.Serializer&amp;lt;T&amp;gt;` / `org.apache.kafka.common.serialization.Deserializer&amp;lt;T&amp;gt;`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1855
#, fuzzy
msgid "the implementation needs to specify the type argument `T` as the (de-)serialized type."
msgstr "la implementación necesita especificar el argumento de tipo `T` como el tipo (des)serializado."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1856
#, fuzzy
msgid "classes generated from Avro schemas, as well as Avro `GenericRecord`, if Confluent or Apicurio Registry _serde_ is present"
msgstr "clases generadas a partir de esquemas Avro, así como Avro `GenericRecord`, si Confluent o Apicurio Registry _serde_ está presente"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1857
#, fuzzy
msgid "in case multiple Avro serdes are present, serializer/deserializer must be configured manually for Avro-generated classes, because autodetection is impossible"
msgstr "en caso de que haya varios serdes Avro, el serializador/deserializador debe configurarse manualmente para las clases generadas por Avro, ya que la autodetección es imposible"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1858
#, fuzzy
msgid "see xref:kafka-schema-registry-avro.adoc[Using Apache Kafka with Schema Registry and Avro] for more information about using Confluent or Apicurio Registry libraries"
msgstr "Para más información sobre el uso de las librerías Confluent o Apicurio Registry, consulte  link:kafka-schema-registry-avro.html[Uso de Apache Kafka con Schema Registry y Avro]"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1859
#, fuzzy
msgid "classes for which a subclass of `ObjectMapperSerializer` / `ObjectMapperDeserializer` is present, as described in xref:jackson-serialization[Serializing via Jackson]"
msgstr "clases para las que existe una subclase de `ObjectMapperSerializer` / `ObjectMapperDeserializer`, como se describe en  link:#jackson-serialization[[jackson-serialization]]"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1860
#, fuzzy
msgid "it is technically not needed to subclass `ObjectMapperSerializer`, but in such case, autodetection isn't possible"
msgstr "técnicamente no es necesario subclasificar `ObjectMapperSerializer`, pero en tal caso, la autodetección no es posible"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1861
#, fuzzy
msgid "classes for which a subclass of `JsonbSerializer` / `JsonbDeserializer` is present, as described in xref:jsonb-serialization[Serializing via JSON-B]"
msgstr "clases para las que existe una subclase de `JsonbSerializer` / `JsonbDeserializer`, como se describe en  link:#jsonb-serialization[[jsonb-serialization]]"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1862
#, fuzzy
msgid "it is technically not needed to subclass `JsonbSerializer`, but in such case, autodetection isn't possible"
msgstr "técnicamente no es necesario subclasificar `JsonbSerializer`, pero en tal caso, la autodetección no es posible"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1864
#, fuzzy
msgid "If a serializer/deserializer is set by configuration, it won't be replaced by the autodetection."
msgstr "Si se establece un serializador/deserializador por configuración, no será reemplazado por la autodetección."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1867
#, fuzzy
msgid "In case you have any issues with serializer autodetection, you can switch it off completely by setting `quarkus.reactive-messaging.kafka.serializer-autodetection.enabled=false`.  If you find you need to do this, please file a bug in the link:https://github.com/quarkusio/quarkus/issues[Quarkus issue tracker] so we can fix whatever problem you have."
msgstr "En caso de que tengas algún problema con la autodetección del serializador, puedes desactivarla completamente configurando `quarkus.reactive-messaging.kafka.serializer-autodetection.enabled=false`. Si encuentras que necesitas hacer esto, por favor presenta un error en el  link:https://github.com/quarkusio/quarkus/issues[rastreador de problemas de Quarkus] para que podamos arreglar cualquier problema que tengas."

#. type: Title ==
#: upstream/_guides/kafka.adoc:1869
#, fuzzy, no-wrap
msgid "JSON Serializer/deserializer generation"
msgstr "Generación de serializadores/deserializadores JSON"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1871
#, fuzzy
msgid "Quarkus automatically generates serializers and deserializers for channels where:"
msgstr "Quarkus genera automáticamente serializadores y deserializadores para los canales donde:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1873
#, fuzzy
msgid "the serializer/deserializer is not configured"
msgstr "el serializador/deserializador no está configurado"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1874
#, fuzzy
msgid "the auto-detection did not find a matching serializer/deserializer"
msgstr "la autodetección no encontró un serializador/deserializador coincidente"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1876
#, fuzzy
msgid "It uses Jackson underneath."
msgstr "Utiliza a Jackson por debajo."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1878
#, fuzzy
msgid "This generation can be disabled using:"
msgstr "Esta generación se puede desactivar mediante:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1882
#, no-wrap
msgid "quarkus.reactive-messaging.kafka.serializer-generation.enabled=false\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1886
#, fuzzy
msgid "Generation does not support collections such as `List<Fruit>`.  Refer to xref:jackson-serialization[Serializing via Jackson] to write your own serializer/deserializer for this case."
msgstr "La generación no soporta colecciones como `List&amp;lt;Fruit&amp;gt;`. Consulte  link:#jackson-serialization[[jackson-serialization]] para escribir su propio serializador/deserializador para este caso."

#. type: Title ==
#: upstream/_guides/kafka.adoc:1887
#, fuzzy, no-wrap
msgid "Using Schema Registry"
msgstr "Uso del registro de esquemas"

#. type: Title ==
#: upstream/_guides/kafka.adoc:1892
#, fuzzy, no-wrap
msgid "Health Checks"
msgstr "Controles de salud"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1896
#, fuzzy
msgid "Quarkus provides several health checks for Kafka.  These checks are used in combination with the `quarkus-smallrye-health` extension."
msgstr "Quarkus proporciona varias comprobaciones de salud para Kafka. Estas comprobaciones se utilizan en combinación con la extensión `quarkus-smallrye-health`."

#. type: Title ===
#: upstream/_guides/kafka.adoc:1897
#, fuzzy, no-wrap
msgid "Kafka Broker Readiness Check"
msgstr "Comprobación de la disponibilidad del corredor Kafka"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1902
#, fuzzy
msgid "When using the `quarkus-kafka-client` extension, you can enable _readiness_ health check by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.  This check reports the status of the interaction with a _default_ Kafka broker (configured using `kafka.bootstrap.servers`).  It requires an _admin connection_ with the Kafka broker, and it is disabled by default.  If enabled, when you access the `/q/health/ready` endpoint of your application, you will have information about the connection validation status."
msgstr "Cuando se utiliza la extensión `quarkus-kafka-client`, se puede habilitar la comprobación de la salud _de la preparación_ estableciendo la propiedad `quarkus.kafka.health.enabled` a `true` en su `application.properties`. Esta comprobación informa del estado de la interacción con un broker Kafka _por_ defecto (configurado mediante `kafka.bootstrap.servers`). Requiere una _conexión de administrador_ con el broker Kafka, y está deshabilitada por defecto. Si está habilitada, cuando acceda al endpoint `/q/health/ready` de su aplicación, tendrá información sobre el estado de validación de la conexión."

#. type: Title ===
#: upstream/_guides/kafka.adoc:1903
#, fuzzy, no-wrap
msgid "Kafka Reactive Messaging Health Checks"
msgstr "Comprobaciones de salud de la mensajería reactiva de Kafka"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1905
#, fuzzy
msgid "When using Reactive Messaging and the Kafka connector, each configured channel (incoming or outgoing) provides _startup_, _liveness_ and _readiness_ checks."
msgstr "Cuando se utiliza la Mensajería Reactiva y el conector Kafka, cada canal configurado (entrante o saliente) proporciona comprobaciones de _inicio_, _capacidad_ y _disponibilidad_."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1907
#, fuzzy
msgid "The _startup_ check verifies that the communication with Kafka cluster is established."
msgstr "La comprobación de _inicio_ verifica que se ha establecido la comunicación con el clúster Kafka."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1908
#, fuzzy
msgid "The _liveness_ check captures any unrecoverable failure happening during the communication with Kafka."
msgstr "La comprobación _de la vitalidad_ captura cualquier fallo irrecuperable que se produzca durante la comunicación con Kafka."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1909
#, fuzzy
msgid "The _readiness_ check verifies that the Kafka connector is ready to consume/produce messages to the configured Kafka topics."
msgstr "La comprobación _de disponibilidad_ verifica que el conector Kafka está listo para consumir/producir mensajes a los temas Kafka configurados."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1911
#, fuzzy
msgid "For each channel, you can disable the checks using:"
msgstr "Para cada canal, puede desactivar las comprobaciones mediante:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1915
#, no-wrap
msgid "# Disable both liveness and readiness checks with `health-enabled=false`:\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1920
#, no-wrap
msgid ""
"# Incoming channel (receiving records form Kafka)\n"
"mp.messaging.incoming.your-channel.health-enabled=false\n"
"# Outgoing channel (writing records to Kafka)\n"
"mp.messaging.outgoing.your-channel.health-enabled=false\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1922
#, no-wrap
msgid "# Disable only the readiness check with `health-readiness-enabled=false`:\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1925
#, no-wrap
msgid ""
"mp.messaging.incoming.your-channel.health-readiness-enabled=false\n"
"mp.messaging.outgoing.your-channel.health-readiness-enabled=false\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1929
#, fuzzy
msgid "You can configure the `bootstrap.servers` for each channel using `mp.messaging.incoming|outgoing.$channel.bootstrap.servers` property.  Default is `kafka.bootstrap.servers`."
msgstr "Puede configurar el `bootstrap.servers` para cada canal utilizando la propiedad `mp.messaging.incoming|outgoing.$channel.bootstrap.servers`. Por defecto es `kafka.bootstrap.servers`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1933
#, fuzzy
msgid "Reactive Messaging _startup_ and _readiness_ checks offer two strategies.  The default strategy verifies that an active connection is established with the broker.  This approach is not intrusive as it's based on built-in Kafka client metrics."
msgstr "Las comprobaciones de _inicio_ y _preparación de_ la mensajería reactiva ofrecen dos estrategias. La estrategia por defecto verifica que se ha establecido una conexión activa con el broker. Este enfoque no es intrusivo, ya que se basa en las métricas incorporadas del cliente Kafka."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1937
#, fuzzy
msgid "Using the `health-topic-verification-enabled=true` attribute, _startup_ probe uses an _admin client_ to check for the list of topics.  Whereas the _readiness_ probe for an incoming channel checks that at least one partition is assigned for consumption, and for an outgoing channel checks that the topic used by the producer exist in the broker."
msgstr "Utilizando el atributo `health-topic-verification-enabled=true`, la sonda de _inicio_ utiliza un _cliente de administración_ para comprobar la lista de temas. Mientras que la sonda de _preparación_ para un canal entrante comprueba que al menos una partición está asignada para el consumo, y para un canal saliente comprueba que el tema utilizado por el productor existe en el broker."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1940
#, fuzzy
msgid "Note that to achieve this, an _admin connection_ is required.  You can adjust the timeout for topic verification calls to the broker using the `health-topic-verification-timeout` configuration."
msgstr "Tenga en cuenta que para lograr esto, se requiere una _conexión de administrador_. Puede ajustar el tiempo de espera para las llamadas de verificación de temas al agente mediante la configuración de `health-topic-verification-timeout`."

#. type: Title ==
#: upstream/_guides/kafka.adoc:1941
#, fuzzy, no-wrap
msgid "Kafka Streams"
msgstr "Kafka Streams"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1944
#, fuzzy
msgid "This is described in a dedicated guide: xref:kafka-streams.adoc[Using Apache Kafka Streams]."
msgstr "Esto se describe en una guía dedicada:  link:kafka-streams.html[Uso de Apache Kafka Streams]."

#. type: Title ==
#: upstream/_guides/kafka.adoc:1945
#, fuzzy, no-wrap
msgid "Using Snappy for message compression"
msgstr "Uso de Snappy para la compresión de mensajes"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1948
#, fuzzy
msgid "On _outgoing_ channels, you can enable Snappy compression by setting the `compression.type` attribute to `snappy`:"
msgstr "En los canales de _salida_, puedes activar la compresión Snappy configurando el atributo `compression.type` como `snappy`:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1952
#, no-wrap
msgid "mp.messaging.outgoing.fruit-out.compression.type=snappy\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1956
#, fuzzy
msgid "In JVM mode, it will work out of the box.  However, to compile your application to a native executable, you need to:"
msgstr "En el modo JVM, funcionará de forma inmediata. Sin embargo, para compilar su aplicación a un ejecutable nativo, necesita:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1958
#, fuzzy
msgid "Uses GraalVM 21.+"
msgstr "Utiliza GraalVM 21.+"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1959
#, fuzzy
msgid "Add `quarkus.kafka.snappy.enabled=true` to your `application.properties`"
msgstr "Añada `quarkus.kafka.snappy.enabled=true` a su `application.properties`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1961
#, fuzzy
msgid "In native mode, Snappy is disabled by default as the use of Snappy requires embedding a native library and unpacking it when the application starts."
msgstr "En el modo nativo, Snappy está desactivado por defecto, ya que el uso de Snappy requiere incrustar una biblioteca nativa y desempaquetarla cuando se inicia la aplicación."

#. type: Title ==
#: upstream/_guides/kafka.adoc:1962
#, fuzzy, no-wrap
msgid "Authentication with OAuth"
msgstr "Autenticación con OAuth"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1966
#, fuzzy
msgid "If your Kafka broker uses OAuth as authentication mechanism, you need to configure the Kafka consumer to enable this authentication process.  First, add the following dependency to your application:"
msgstr "Si tu broker de Kafka utiliza OAuth como mecanismo de autenticación, necesitas configurar el consumidor de Kafka para habilitar este proceso de autenticación. En primer lugar, añade la siguiente dependencia a tu aplicación:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1974
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.strimzi</groupId>\n"
"    <artifactId>kafka-oauth-client</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1980
#, no-wrap
msgid "implementation(\"io.strimzi:kafka-oauth-client\")\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1984
#, fuzzy
msgid "This dependency provides the callback handler required to handle the OAuth workflow.  Then, in the `application.properties`, add:"
msgstr "Esta dependencia proporciona el controlador de devolución de llamada necesario para manejar el flujo de trabajo de OAuth. A continuación, en la página `application.properties`, añade:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1994
#, no-wrap
msgid ""
"mp.messaging.connector.smallrye-kafka.security.protocol=SASL_PLAINTEXT\n"
"mp.messaging.connector.smallrye-kafka.sasl.mechanism=OAUTHBEARER\n"
"mp.messaging.connector.smallrye-kafka.sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n"
"  oauth.client.id=\"team-a-client\" \\\n"
"  oauth.client.secret=\"team-a-client-secret\" \\\n"
"  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n"
"mp.messaging.connector.smallrye-kafka.sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1996
#, no-wrap
msgid "quarkus.ssl.native=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1999
#, fuzzy
msgid "Update the `oauth.client.id`, `oauth.client.secret` and `oauth.token.endpoint.uri` values."
msgstr "Actualice los valores de `oauth.client.id`, `oauth.client.secret` y `oauth.token.endpoint.uri`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2001
#, fuzzy
msgid "OAuth authentication works for both JVM and native modes. Since SSL in not enabled by default in native mode, `quarkus.ssl.native=true` must be added to support JaasClientOauthLoginCallbackHandler, which uses SSL. (See the xref:native-and-ssl.adoc[Using SSL with Native Executables] guide for more details.)"
msgstr "La autenticación OAuth funciona tanto en el modo JVM como en el nativo. Dado que SSL no está habilitado por defecto en el modo nativo, se debe añadir `quarkus.ssl.native=true` para soportar JaasClientOauthLoginCallbackHandler, que utiliza SSL. (Para más detalles, consulte la guía  link:native-and-ssl.html[Using SSL with Native Executables] )."

#. type: Title ==
#: upstream/_guides/kafka.adoc:2002
#, fuzzy, no-wrap
msgid "Testing a Kafka application"
msgstr "Probar una aplicación Kafka"

#. type: Title ===
#: upstream/_guides/kafka.adoc:2004
#, fuzzy, no-wrap
msgid "Testing without a broker"
msgstr "Pruebas sin intermediario"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2008
#, fuzzy
msgid "It can be useful to test the application without having to start a Kafka broker.  To achieve this, you can _switch_ the channels managed by the Kafka connector to _in-memory_."
msgstr "Puede ser útil para probar la aplicación sin tener que iniciar un broker de Kafka. Para conseguirlo, puedes _cambiar_ los canales gestionados por el conector Kafka a _in-memory_."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2010
#, fuzzy
msgid "This approach only works for JVM tests. It cannot be used for native tests (because they do not support injection)."
msgstr "Este enfoque sólo funciona para las pruebas de la JVM. No se puede utilizar para las pruebas nativas (porque no soportan la inyección)."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2012
#, fuzzy
msgid "Let's say we want to test the following processor application:"
msgstr "Digamos que queremos probar la siguiente aplicación del procesador:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2017 upstream/_guides/kafka.adoc:2130
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class BeverageProcessor {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2029
#, no-wrap
msgid ""
"    @Incoming(\"orders\")\n"
"    @Outgoing(\"beverages\")\n"
"    Beverage process(Order order) {\n"
"        System.out.println(\"Order received \" + order.getProduct());\n"
"        Beverage beverage = new Beverage();\n"
"        beverage.setBeverage(order.getProduct());\n"
"        beverage.setCustomer(order.getCustomer());\n"
"        beverage.setOrderId(order.getOrderId());\n"
"        beverage.setPreparationState(\"RECEIVED\");\n"
"        return beverage;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2034
#, fuzzy
msgid "First, add the following test dependency to your application:"
msgstr "En primer lugar, añada la siguiente dependencia de prueba a su aplicación:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2043
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.smallrye.reactive</groupId>\n"
"    <artifactId>smallrye-reactive-messaging-in-memory</artifactId>\n"
"    <scope>test</scope>\n"
"</dependency>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2049
#, no-wrap
msgid "testImplementation(\"io.smallrye.reactive:smallrye-reactive-messaging-in-memory\")\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2052
#, fuzzy
msgid "Then, create a Quarkus Test Resource as follows:"
msgstr "A continuación, cree un recurso de prueba de Quarkus de la siguiente manera:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2056
#, no-wrap
msgid "public class KafkaTestResourceLifecycleManager implements QuarkusTestResourceLifecycleManager {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2066
#, no-wrap
msgid ""
"    @Override\n"
"    public Map<String, String> start() {\n"
"        Map<String, String> env = new HashMap<>();\n"
"        Map<String, String> props1 = InMemoryConnector.switchIncomingChannelsToInMemory(\"orders\");     // <1>\n"
"        Map<String, String> props2 = InMemoryConnector.switchOutgoingChannelsToInMemory(\"beverages\");  // <2>\n"
"        env.putAll(props1);\n"
"        env.putAll(props2);\n"
"        return env;  // <3>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2072
#, no-wrap
msgid ""
"    @Override\n"
"    public void stop() {\n"
"        InMemoryConnector.clear();  // <4>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2074
#, fuzzy
msgid "Switch the incoming channel `orders` (expecting messages from Kafka) to in-memory."
msgstr "Cambia el canal de entrada `orders` (que espera mensajes de Kafka) por uno en memoria."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2075
#, fuzzy
msgid "Switch the outgoing channel `beverages` (writing messages to Kafka) to in-memory."
msgstr "Cambiar el canal de salida `beverages` (escribir mensajes a Kafka) a in-memory."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2076
#, fuzzy
msgid "Builds and returns a `Map` containing all the properties required to configure the application to use in-memory channels."
msgstr "Construye y devuelve un `Map` que contiene todas las propiedades necesarias para configurar la aplicación para utilizar canales en memoria."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2077
#, fuzzy
msgid "When the test stops, clear the `InMemoryConnector` (discard all the received and sent messages)"
msgstr "Cuando la prueba se detenga, borre el `InMemoryConnector` (descarte todos los mensajes recibidos y enviados)"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2079
#, fuzzy
msgid "Create a Quarkus Test using the test resource created above:"
msgstr "Cree una prueba de Quarkus utilizando el recurso de prueba creado anteriormente:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2083 upstream/_guides/kafka.adoc:2142
#, no-wrap
msgid "import static org.awaitility.Awaitility.await;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2087 upstream/_guides/kafka.adoc:2146
#, no-wrap
msgid ""
"@QuarkusTest\n"
"@QuarkusTestResource(KafkaTestResourceLifecycleManager.class)\n"
"class BaristaTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2091
#, no-wrap
msgid ""
"    @Inject\n"
"    @Connector(\"smallrye-in-memory\")\n"
"    InMemoryConnector connector; // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2096
#, no-wrap
msgid ""
"    @Test\n"
"    void testProcessOrder() {\n"
"        InMemorySource<Order> ordersIn = connector.source(\"orders\");     // <2>\n"
"        InMemorySink<Beverage> beveragesOut = connector.sink(\"beverages\");  // <3>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2101
#, no-wrap
msgid ""
"        Order order = new Order();\n"
"        order.setProduct(\"coffee\");\n"
"        order.setName(\"Coffee lover\");\n"
"        order.setOrderId(\"1234\");\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2103
#, no-wrap
msgid "        ordersIn.send(order);  // <4>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2105
#, no-wrap
msgid "        await().<List<? extends Message<Beverage>>>until(beveragesOut::received, t -> t.size() == 1); // <5>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2112
#, no-wrap
msgid ""
"        Beverage queuedBeverage = beveragesOut.received().get(0).getPayload();\n"
"        Assertions.assertEquals(Beverage.State.READY, queuedBeverage.getPreparationState());\n"
"        Assertions.assertEquals(\"coffee\", queuedBeverage.getBeverage());\n"
"        Assertions.assertEquals(\"Coffee lover\", queuedBeverage.getCustomer());\n"
"        Assertions.assertEquals(\"1234\", queuedBeverage.getOrderId());\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2116
#, fuzzy
msgid "Inject the in-memory connector in your test class."
msgstr "Inyecte el conector en memoria en su clase de prueba."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2117
#, fuzzy
msgid "Retrieve the incoming channel (`orders`) - the channel must have been switched to in-memory in the test resource."
msgstr "Recuperar el canal de entrada ( `orders`) - el canal debe haber sido cambiado a la memoria en el recurso de prueba."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2118
#, fuzzy
msgid "Retrieve the outgoing channel (`beverages`) - the channel must have been switched to in-memory in the test resource."
msgstr "Recuperar el canal de salida ( `beverages`) - el canal debe haber sido cambiado a la memoria en el recurso de prueba."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2120
#, fuzzy
msgid "Use the `send` method to send a message to the `orders` channel.  The application will process this message and send a message to `beverages` channel."
msgstr "Utilice el método `send` para enviar un mensaje al canal `orders`. La aplicación procesará este mensaje y enviará un mensaje al canal `beverages`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2121
#, fuzzy
msgid "Use the `received` method on `beverages` channel to check the messages produced by the application."
msgstr "Utilice el método `received` en el canal `beverages` para comprobar los mensajes producidos por la aplicación."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2123
msgid "If your Kafka consumer is batch based, you will need to send a batch of messages to the channel as by creating them manually."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2125
msgid "For instance:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2137
#, no-wrap
msgid ""
"    @Incoming(\"orders\")\n"
"    CompletionStage<Void> process(KafkaRecordBatch<String, Order> orders) {\n"
"        System.out.println(\"Order received \" + orders.getPayload().size());\n"
"        return orders.ack();\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2149
#, no-wrap
msgid ""
"    @Inject\n"
"    @Connector(\"smallrye-in-memory\")\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2151
#, no-wrap
msgid "    InMemoryConnector connector;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2169
#, no-wrap
msgid ""
"    @Test\n"
"    void testProcessOrder() {\n"
"        InMemorySource<IncomingKafkaRecordBatch<String, Order>> ordersIn = connector.source(\"orders\");\n"
"        var committed = new AtomicBoolean(false);  // <1>\n"
"        var commitHandler = new KafkaCommitHandler() {\n"
"            @Override\n"
"            public <K, V> Uni<Void> handle(IncomingKafkaRecord<K, V> record) {\n"
"                committed.set(true);  // <2>\n"
"                return null;\n"
"            }\n"
"        };\n"
"        var failureHandler = new KafkaFailureHandler() {\n"
"            @Override\n"
"            public <K, V> Uni<Void> handle(IncomingKafkaRecord<K, V> record, Throwable reason, Metadata metadata) {\n"
"                return null;\n"
"            }\n"
"        };\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2178
#, no-wrap
msgid ""
"        Order order = new Order();\n"
"        order.setProduct(\"coffee\");\n"
"        order.setName(\"Coffee lover\");\n"
"        order.setOrderId(\"1234\");\n"
"        var record = new ConsumerRecord<>(\"topic\", 0, 0, \"key\", order);\n"
"        var records = new ConsumerRecords<>(Map.of(new TopicPartition(\"topic\", 1), List.of(record)));\n"
"        var batch = new IncomingKafkaRecordBatch<>(\n"
"            records, \"kafka\", 0, commitHandler, failureHandler, false, false);  // <3>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2180
#, no-wrap
msgid "        ordersIn.send(batch);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2184
#, no-wrap
msgid ""
"        await().until(committed::get);  // <4>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2186
msgid "Create an `AtomicBoolean` to track if the batch has been committed."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2187
msgid "Update `committed` when the batch is committed."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2188
msgid "Create a `IncomingKafkaRecordBatch` with a single record."
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2189
msgid "Wait until the batch is committed."
msgstr ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:2194
#, fuzzy
msgid "With in-memory channels we were able to test application code processing messages without starting a Kafka broker.  Note that different in-memory channels are independent, and switching channel connector to in-memory does not simulate message delivery between channels configured to the same Kafka topic."
msgstr "Con los canales en memoria pudimos probar el código de la aplicación que procesa los mensajes sin iniciar un broker de Kafka. Hay que tener en cuenta que los diferentes canales en memoria son independientes, y el cambio de conector de canal a en memoria no simula la entrega de mensajes entre canales configurados para el mismo tema de Kafka."

#. type: Title ===
#: upstream/_guides/kafka.adoc:2196
#, fuzzy, no-wrap
msgid "Testing using a Kafka broker"
msgstr "Pruebas con un broker de Kafka"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2201
#, fuzzy
msgid "If you are using xref:kafka-dev-services[Dev Services for Kafka], a Kafka broker will be started and available throughout the tests, unless it is disabled in `%test` profile.  While it is possible to connect to this broker using Kafka Clients API, https://smallrye.io/smallrye-reactive-messaging/latest/kafka/test-companion/[Kafka Companion Library] proposes an easier way of interacting with a Kafka broker and, creating consumer, producer and admin actions inside tests."
msgstr "Si se utiliza  link:#kafka-dev-services[[kafka-dev-services]], un broker de Kafka se iniciará y estará disponible durante todas las pruebas, a menos que se desactive en el perfil `%test`. Aunque es posible conectarse a este broker utilizando la API de clientes de Kafka,  link:https://smallrye.io/smallrye-reactive-messaging/latest/kafka/test-companion/[la biblioteca Kafka Companion] propone una forma más sencilla de interactuar con un broker de Kafka y, crear acciones de consumidor, productor y administrador dentro de las pruebas."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2203
#, fuzzy
msgid "For using `KafkaCompanion` API in tests, start by adding the following dependency:"
msgstr "Para utilizar la API `KafkaCompanion` en las pruebas, comience por añadir la siguiente dependencia:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2211
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-test-kafka-companion</artifactId>\n"
"    <scope>test</scope>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2214
#, fuzzy
msgid "which provides `io.quarkus.test.kafka.KafkaCompanionResource` - an implementation of `io.quarkus.test.common.QuarkusTestResourceLifecycleManager`."
msgstr "que proporciona `io.quarkus.test.kafka.KafkaCompanionResource` - una implementación de `io.quarkus.test.common.QuarkusTestResourceLifecycleManager`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2216
#, fuzzy
msgid "Then use `@QuarkusTestResource` to configure the Kafka Companion in tests, for example:"
msgstr "A continuación, utilice `@QuarkusTestResource` para configurar el Kafka Companion en las pruebas, por ejemplo:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2220
#, no-wrap
msgid "import static org.junit.jupiter.api.Assertions.assertEquals;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2222
#, no-wrap
msgid "import java.util.UUID;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2225
#, no-wrap
msgid ""
"import org.apache.kafka.clients.producer.ProducerRecord;\n"
"import org.junit.jupiter.api.Test;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2232
#, no-wrap
msgid ""
"import io.quarkus.test.common.QuarkusTestResource;\n"
"import io.quarkus.test.junit.QuarkusTest;\n"
"import io.quarkus.test.kafka.InjectKafkaCompanion;\n"
"import io.quarkus.test.kafka.KafkaCompanionResource;\n"
"import io.smallrye.reactive.messaging.kafka.companion.ConsumerTask;\n"
"import io.smallrye.reactive.messaging.kafka.companion.KafkaCompanion;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2236
#, no-wrap
msgid ""
"@QuarkusTest\n"
"@QuarkusTestResource(KafkaCompanionResource.class)\n"
"public class OrderProcessorTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2239
#, no-wrap
msgid ""
"    @InjectKafkaCompanion // <1>\n"
"    KafkaCompanion companion;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2243
#, no-wrap
msgid ""
"    @Test\n"
"    void testProcessor() {\n"
"        companion.produceStrings().usingGenerator(i -> new ProducerRecord<>(\"orders\", UUID.randomUUID().toString())); // <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2245
#, no-wrap
msgid "        // Expect that the tested application processes orders from 'orders' topic and write to 'orders-processed' topic\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2251
#, no-wrap
msgid ""
"        ConsumerTask<String, String> orders = companion.consumeStrings().fromTopics(\"orders-processed\", 10); // <3>\n"
"        orders.awaitCompletion(); // <4>\n"
"        assertEquals(10, orders.count());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2254
#, fuzzy
msgid "`@InjectKafkaCompanion` injects the `KafkaCompanion` instance, configured to access the Kafka broker created for tests."
msgstr "`@InjectKafkaCompanion` inyecta la instancia `KafkaCompanion`, configurada para acceder al broker Kafka creado para las pruebas."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2255
#, fuzzy
msgid "Use `KafkaCompanion` to create producer task which writes 10 records to 'orders' topic."
msgstr "Utilice `KafkaCompanion` para crear una tarea de producción que escriba 10 registros en el tema \"pedidos\"."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2256
#, fuzzy
msgid "Create consumer task which subscribes to 'orders-processed' topic and consumes 10 records."
msgstr "Crear una tarea de consumo que se suscriba al tema \"pedidos procesados\" y consuma 10 registros."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2257
#, fuzzy
msgid "Await completion of the consumer task."
msgstr "Esperar la finalización de la tarea del consumidor."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:2261
#, fuzzy
msgid "If the Kafka Dev Service is available during tests, `KafkaCompanionResource` uses the created Kafka broker, otherwise it creates a Kafka broker using https://github.com/strimzi/test-container[Strimzi Test Container]."
msgstr "Si el Kafka Dev Service está disponible durante las pruebas, `KafkaCompanionResource` utiliza el broker Kafka creado, de lo contrario crea un broker Kafka utilizando  link:https://github.com/strimzi/test-container[el Strimzi Test Container]."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:2263
#, fuzzy
msgid "The configuration of the created Kafka broker can be customized using `@ResourceArg`, for example:"
msgstr "La configuración del broker Kafka creado puede personalizarse mediante `@ResourceArg`, por ejemplo:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2274
#, no-wrap
msgid ""
"@QuarkusTestResource(value = KafkaCompanionResource.class, initArgs = {\n"
"        @ResourceArg(name = \"strimzi.kafka.image\", value = \"quay.io/strimzi/kafka:0.28.0-kafka-3.0.0\"), // Image name\n"
"        @ResourceArg(name = \"kafka.port\", value = \"9092\"), // Fixed port for kafka, by default it will be exposed on a random port\n"
"        @ResourceArg(name = \"kraft\", value = \"true\"), // Enable Kraft mode\n"
"        @ResourceArg(name = \"num.partitions\", value = \"3\"), // Other custom broker configurations\n"
"})\n"
"public class OrderProcessorTest {\n"
"    // ...\n"
"}\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/kafka.adoc:2277
#, fuzzy, no-wrap
msgid "Custom test resource"
msgstr "Recurso de prueba personalizado"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:2281
#, fuzzy
msgid "Alternatively, you can start a Kafka broker in a test resource.  The following snippet shows a test resource starting a Kafka broker using https://www.testcontainers.org/modules/kafka/[Testcontainers]:"
msgstr "Como alternativa, puede iniciar un broker de Kafka en un recurso de prueba. El siguiente fragmento muestra un recurso de prueba que inicia un corredor de Kafka utilizando  link:https://www.testcontainers.org/modules/kafka/[Testcontainers]:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2285
#, no-wrap
msgid "public class KafkaResource implements QuarkusTestResourceLifecycleManager {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2287
#, no-wrap
msgid "    private final KafkaContainer kafka = new KafkaContainer();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2293
#, no-wrap
msgid ""
"    @Override\n"
"    public Map<String, String> start() {\n"
"        kafka.start();\n"
"        return Collections.singletonMap(\"kafka.bootstrap.servers\", kafka.getBootstrapServers());  // <1>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2299
#, no-wrap
msgid ""
"    @Override\n"
"    public void stop() {\n"
"        kafka.close();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2301
#, fuzzy
msgid "Configure the Kafka bootstrap location, so the application connects to this broker."
msgstr "Configurar la ubicación del bootstrap de Kafka, para que la aplicación se conecte a este broker."

#. type: Title ==
#: upstream/_guides/kafka.adoc:2308
#, fuzzy, no-wrap
msgid "Kubernetes Service Bindings"
msgstr "Enlaces de servicio Kubernetes"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2313
#, fuzzy
msgid "Quarkus Kafka extension supports xref:deploying-to-kubernetes.adoc[Service Binding Specification for Kubernetes].  You can enable this by adding the `quarkus-kubernetes-service-binding` extension to your application."
msgstr "La extensión Kafka de Quarkus admite la  link:deploying-to-kubernetes.html[especificación de enlace de servicios para Kubernetes]. Puede habilitarlo añadiendo la extensión `quarkus-kubernetes-service-binding` a su aplicación."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2315
#, fuzzy
msgid "When running in appropriately configured Kubernetes clusters, Kafka extension will pull its Kafka broker connection configuration from the service binding available inside the cluster, without the need for user configuration."
msgstr "Cuando se ejecuta en clústeres de Kubernetes debidamente configurados, la extensión de Kafka extraerá su configuración de conexión del broker de Kafka del enlace de servicio disponible dentro del clúster, sin necesidad de configuración por parte del usuario."

#. type: Title ==
#: upstream/_guides/kafka.adoc:2316
#, fuzzy, no-wrap
msgid "Execution model"
msgstr "Modelo de ejecución"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2321
#, fuzzy
msgid "Reactive Messaging invokes user's methods on an I/O thread.  Thus, by default, the methods must not block.  As described in xref:blocking-processing[Blocking processing], you need to add the `@Blocking` annotation on the method if this method will block the caller thread."
msgstr "La mensajería reactiva invoca los métodos del usuario en un hilo de E/S. Así, por defecto, los métodos no deben bloquearse. Como se describe en  link:#blocking-processing[[blocking-processing]], es necesario añadir la anotación `@Blocking` en el método si este método va a bloquear el hilo de llamada."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2323
#, fuzzy
msgid "See the xref:quarkus-reactive-architecture.adoc[Quarkus Reactive Architecture documentation] for further details on this topic."
msgstr "Consulte la  link:quarkus-reactive-architecture.html[documentación de la Arquitectura Reactiva de Quarkus] para obtener más detalles sobre este tema."

#. type: Title ==
#: upstream/_guides/kafka.adoc:2324
#, fuzzy, no-wrap
msgid "Channel Decorators"
msgstr "Decoradores de canales"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2327
#, fuzzy
msgid "SmallRye Reactive Messaging supports decorating incoming and outgoing channels for implementing cross-cutting concerns such as monitoring, tracing or message interception. For more information on implementing decorators and message interceptors see the http://smallrye.io/smallrye-reactive-messaging/latest/concepts/decorators/[SmallRye Reactive Messaging documentation]."
msgstr "SmallRye Reactive Messaging admite la decoración de canales entrantes y salientes para implementar preocupaciones transversales como la supervisión, el rastreo o la interceptación de mensajes. Para obtener más información sobre la implementación de decoradores e interceptores de mensajes, consulte la  link:http://smallrye.io/smallrye-reactive-messaging/3.19.1/concepts/decorators/[documentación de SmallRye Reactive] Messaging."

#. type: Title ==
#: upstream/_guides/kafka.adoc:2329
#, fuzzy, no-wrap
msgid "Configuration Reference"
msgstr "Referencia de configuración"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2332
#, fuzzy
msgid "More details about the SmallRye Reactive Messaging configuration can be found in the https://smallrye.io/smallrye-reactive-messaging/latest/kafka/kafka/#using-the-kafka-connector[SmallRye Reactive Messaging - Kafka Connector Documentation]."
msgstr "Puede encontrar más detalles sobre la configuración de SmallRye Reactive Messaging en la  link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.1/kafka/kafka.html[documentación de SmallRye Reactive Messaging - Kafka Connector]."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:2336
#, fuzzy
msgid "Each channel can be disabled via configuration using:"
msgstr "Cada canal se puede desactivar mediante la configuración:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2340
#, no-wrap
msgid "mp.messaging.[incoming|outgoing].[channel].enabled=false\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:2344
#, fuzzy
msgid "The most important attributes are listed in the tables below:"
msgstr "Los atributos más importantes se enumeran en las tablas siguientes:"

#. type: Title ===
#: upstream/_guides/kafka.adoc:2345
#, fuzzy, no-wrap
msgid "Incoming channel configuration (polling from Kafka)"
msgstr "Configuración del canal de entrada (polling desde Kafka)"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2348 upstream/_guides/kafka.adoc:2387
#, fuzzy
msgid "The following attributes are configured using:"
msgstr "Los siguientes atributos se configuran utilizando:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2352
#, no-wrap
msgid "mp.messaging.incoming.your-channel-name.attribute=value\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2355 upstream/_guides/kafka.adoc:2394
#, fuzzy
msgid "Some properties have aliases which can be configured globally:"
msgstr "Algunas propiedades tienen alias que pueden configurarse globalmente:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2359 upstream/_guides/kafka.adoc:2398
#, no-wrap
msgid "kafka.bootstrap.servers=...\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2362
#, fuzzy
msgid "You can also pass any property supported by the underlying https://kafka.apache.org/documentation/#consumerconfigs[Kafka consumer]."
msgstr "También puede pasar cualquier propiedad soportada por el  link:https://kafka.apache.org/documentation/#consumerconfigs[consumidor Kafka] subyacente."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2364
#, fuzzy
msgid "For example, to configure the `max.poll.records` property, use:"
msgstr "Por ejemplo, para configurar la propiedad `max.poll.records`, utilice:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2368
#, no-wrap
msgid "mp.messaging.incoming.[channel].max.poll.records=1000\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2371
#, fuzzy
msgid "Some consumer client properties are configured to sensible default values:"
msgstr "Algunas propiedades del cliente consumidor están configuradas con valores sensibles por defecto:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2373 upstream/_guides/kafka.adoc:2412
#, fuzzy
msgid "If not set, `reconnect.backoff.max.ms` is set to `10000` to avoid high load on disconnection."
msgstr "Si no se configura, `reconnect.backoff.max.ms` se ajusta a `10000` para evitar una carga elevada en la desconexión."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2375
#, fuzzy
msgid "If not set, `key.deserializer` is set to `org.apache.kafka.common.serialization.StringDeserializer`."
msgstr "Si no se establece, `key.deserializer` se fija en `org.apache.kafka.common.serialization.StringDeserializer`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2377
#, fuzzy
msgid "The consumer `client.id` is configured according to the number of clients to create using `mp.messaging.incoming.[channel].partitions` property."
msgstr "El consumidor `client.id` se configura según el número de clientes a crear mediante la propiedad `mp.messaging.incoming.[channel].partitions`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2379
#, fuzzy
msgid "If a `client.id` is provided, it is used as-is or suffixed with client index if `partitions` property is set."
msgstr "Si se proporciona un `client.id`, se utiliza tal cual o con el índice del cliente si se establece la propiedad `partitions`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2380
#, fuzzy
msgid "If a `client.id` is not provided, it is generated as `[client-id-prefix][channel-name][-index]`."
msgstr "Si no se proporciona un `client.id`, se genera como `kafka-consumer-[channel][-index]`."

#. type: Title ===
#: upstream/_guides/kafka.adoc:2384
#, fuzzy, no-wrap
msgid "Outgoing channel configuration (writing to Kafka)"
msgstr "Configuración del canal de salida (escritura en Kafka)"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2391
#, no-wrap
msgid "mp.messaging.outgoing.your-channel-name.attribute=value\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2401
#, fuzzy
msgid "You can also pass any property supported by the underlying https://kafka.apache.org/documentation/#producerconfigs[Kafka producer]."
msgstr "También puede pasar cualquier propiedad soportada por el  link:https://kafka.apache.org/documentation/#producerconfigs[productor Kafka] subyacente."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2403
#, fuzzy
msgid "For example, to configure the `max.block.ms` property, use:"
msgstr "Por ejemplo, para configurar la propiedad `max.block.ms`, utilice:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2407
#, no-wrap
msgid "mp.messaging.incoming.[channel].max.block.ms=10000\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2410
#, fuzzy
msgid "Some producer client properties are configured to sensible default values:"
msgstr "Algunas propiedades del cliente productor están configuradas con valores sensibles por defecto:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2414
#, fuzzy
msgid "If not set, `key.serializer` is set to `org.apache.kafka.common.serialization.StringSerializer`."
msgstr "Si no se establece, `key.serializer` se fija en `org.apache.kafka.common.serialization.StringSerializer`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2416
#, fuzzy
msgid "If not set, producer `client.id` is generated as `[client-id-prefix][channel-name]`."
msgstr "Si no se establece, el productor `client.id` se genera como `kafka-producer-[channel]`."

#. type: Title ===
#: upstream/_guides/kafka.adoc:2420
#, fuzzy, no-wrap
msgid "Kafka Configuration Resolution"
msgstr "Resolución de la configuración de Kafka"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2424
#, fuzzy
msgid "Quarkus exposes all Kafka related application properties, prefixed with `kafka.` or `KAFKA_` inside a configuration map with `default-kafka-broker` name.  This configuration is used to establish the connection with the Kafka broker."
msgstr "Quarkus expone todas las propiedades de la aplicación relacionadas con Kafka, prefijadas con `kafka.` o `KAFKA_` dentro de un mapa de configuración con nombre `default-kafka-broker`. Esta configuración se utiliza para establecer la conexión con el broker de Kafka."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2426
#, fuzzy
msgid "In addition to this default configuration, you can configure the name of the `Map` producer using the `kafka-configuration` attribute:"
msgstr "Además de esta configuración por defecto, puede configurar el nombre del productor de `Map` utilizando el atributo `kafka-configuration`:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2431
#, no-wrap
msgid ""
"mp.messaging.incoming.my-channel.connector=smallrye-kafka\n"
"mp.messaging.incoming.my-channel.kafka-configuration=my-configuration\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2435
#, fuzzy
msgid "In this case, the connector looks for the `Map` associated with the `my-configuration` name.  If `kafka-configuration` is not set, an optional lookup for a `Map` exposed with the channel name (`my-channel` in the previous example) is done."
msgstr "En este caso, el conector busca el `Map` asociado al nombre `my-configuration`. Si no se establece `kafka-configuration`, se realiza una búsqueda opcional de un `Map` expuesto con el nombre del canal ( `my-channel` en el ejemplo anterior)."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2446
#, no-wrap
msgid ""
"@Produces\n"
"@ApplicationScoped\n"
"@Identifier(\"my-configuration\")\n"
"Map<String, Object> outgoing() {\n"
"    return Map.ofEntries(\n"
"            Map.entry(\"value.serializer\", ObjectMapperSerializer.class.getName())\n"
"    );\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2449
#, fuzzy
msgid "If `kafka-configuration` is set and no `Map` can be found, the deployment fails."
msgstr "Si se establece `kafka-configuration` y no se encuentra ningún `Map`, el despliegue falla."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2451
#, fuzzy
msgid "Attribute values are resolved as follows:"
msgstr "Los valores de los atributos se resuelven de la siguiente manera:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2453
#, fuzzy
msgid "the attribute is set directly on the channel configuration (`mp.messaging.incoming.my-channel.attribute=value`),"
msgstr "el atributo se establece directamente en la configuración del canal ( `mp.messaging.incoming.my-channel.attribute=value`),"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2454
#, fuzzy
msgid "if not set, the connector looks for a `Map` with the channel name or the configured `kafka-configuration` (if set) and the value is retrieved from that `Map`"
msgstr "si no se establece, el conector busca un `Map` con el nombre del canal o el `kafka-configuration` configurado (si se establece) y el valor se recupera de ese `Map`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2455
#, fuzzy
msgid "If the resolved `Map` does not contain the value the default `Map` is used (exposed with the `default-kafka-broker` name)"
msgstr "Si el `Map` resuelto no contiene el valor se utiliza el `Map` por defecto (expuesto con el nombre `default-kafka-broker` )"

#. type: Title ===
#: upstream/_guides/kafka.adoc:2456
#, fuzzy, no-wrap
msgid "Conditionally configure channels"
msgstr "Configurar canales condicionalmente"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2460
#, fuzzy
msgid "You can configure the channels using a specific profile.  Thus, the channels are only configured (and added to the application) when the specified profile is enabled."
msgstr "Puede configurar los canales utilizando un perfil específico. De este modo, los canales sólo se configuran (y se añaden a la aplicación) cuando el perfil especificado está activado."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2462
#, fuzzy
msgid "To achieve this, you need:"
msgstr "Para conseguirlo, necesitas:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2464
#, fuzzy
msgid "Prefix the `mp.messaging.[incoming|outgoing].$channel` entries with `%my-profile` such as `%my-profile.mp.messaging.[incoming|outgoing].$channel.key=value`"
msgstr "Prefijo para las entradas `mp.messaging.[incoming|outgoing].$channel` `%my-profile` como `%my-profile.mp.messaging.[incoming|outgoing].$channel.key=value`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2465
#, fuzzy
msgid "Use the `@IfBuildProfile(\"my-profile\")` on the CDI beans containing `@Incoming(channel)` and `@Outgoing(channel)` annotations that need only to be enabled when the profile is enabled."
msgstr "Utilice el `@IfBuildProfile(\"my-profile\")` en los beans CDI que contienen anotaciones `@Incoming(channel)` y `@Outgoing(channel)` que sólo necesitan ser habilitadas cuando el perfil está habilitado."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2468
#, fuzzy
msgid "Note that reactive messaging verifies that the graph is complete.  So, when using such a conditional configuration, ensure the application works with and without the profile enabled."
msgstr "Tenga en cuenta que la mensajería reactiva verifica que el grafo esté completo. Por lo tanto, cuando utilices una configuración condicional de este tipo, asegúrate de que la aplicación funciona con y sin el perfil activado."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2470
#, fuzzy
msgid "Note that this approach can also be used to change the channel configuration based on a profile."
msgstr "Tenga en cuenta que este enfoque también se puede utilizar para cambiar la configuración del canal en función de un perfil."

#. type: Title ==
#: upstream/_guides/kafka.adoc:2471
#, fuzzy, no-wrap
msgid "Integrating with Kafka - Common patterns"
msgstr "Integración con Kafka - Patrones comunes"

#. type: Title ===
#: upstream/_guides/kafka.adoc:2473
#, fuzzy, no-wrap
msgid "Writing to Kafka from an HTTP endpoint"
msgstr "Escribir en Kafka desde un punto final HTTP"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2476
#, fuzzy
msgid "To send messages to Kafka from an HTTP endpoint, inject an `Emitter` (or a `MutinyEmitter`) in your endpoint:"
msgstr "Para enviar mensajes a Kafka desde un endpoint HTTP, inyecte un `Emitter` (o un `MutinyEmitter`) en su endpoint:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2487 upstream/_guides/kafka.adoc:2535
#, no-wrap
msgid ""
"import jakarta.ws.rs.POST;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.Produces;\n"
"import jakarta.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2493 upstream/_guides/kafka.adoc:2543
#: upstream/_guides/kafka.adoc:2768
#, no-wrap
msgid ""
"@Path(\"/\")\n"
"public class ResourceSendingToKafka {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2495
#, no-wrap
msgid "    @Channel(\"kafka\") Emitter<String> emitter;          // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2502
#, no-wrap
msgid ""
"    @POST\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public CompletionStage<Void> send(String payload) { // <2>\n"
"        return emitter.send(payload);                   // <3>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2504
#, fuzzy
msgid "Inject an `Emitter<String>`"
msgstr "Inyectar un `Emitter&amp;lt;String&amp;gt;`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2505
#, fuzzy
msgid "The HTTP method receives the payload and returns a `CompletionStage` completed when the message is written to Kafka"
msgstr "El método HTTP recibe la carga útil y devuelve un `CompletionStage` completado cuando el mensaje se escribe en Kafka"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2506
#, fuzzy
msgid "Send the message to Kafka, the `send` method returns a `CompletionStage`"
msgstr "Enviar el mensaje a Kafka, el método `send` devuelve un `CompletionStage`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2509
#, fuzzy
msgid "The endpoint sends the passed payload (from a `POST` HTTP request) to the emitter.  The emitter's channel is mapped to a Kafka topic in the `application.properties` file:"
msgstr "El endpoint envía la carga útil pasada (de una petición HTTP `POST` ) al emisor. El canal del emisor se asigna a un tema de Kafka en el archivo `application.properties`:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2514
#, no-wrap
msgid ""
"mp.messaging.outgoing.kafka.connector=smallrye-kafka\n"
"mp.messaging.outgoing.kafka.topic=my-topic\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2520
#, fuzzy
msgid "The endpoint returns a `CompletionStage` indicating the asynchronous nature of the method.  The `emitter.send` method returns a `CompletionStage<Void>` .  The returned future is completed when the message has been written to Kafka.  If the writing fails, the returned `CompletionStage` is completed exceptionally."
msgstr "El punto final devuelve un `CompletionStage` que indica la naturaleza asíncrona del método. El método `emitter.send` devuelve un `CompletionStage&amp;lt;Void&amp;gt;`. El futuro devuelto se completa cuando el mensaje se ha escrito en Kafka. Si la escritura falla, el `CompletionStage` devuelto se completa excepcionalmente."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2522
#, fuzzy
msgid "If the endpoint does not return a `CompletionStage`, the HTTP response may be written before the message is sent to Kafka, and so failures won't be reported to the user."
msgstr "Si el endpoint no devuelve un `CompletionStage`, la respuesta HTTP puede escribirse antes de que el mensaje se envíe a Kafka, por lo que los fallos no se comunicarán al usuario."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2524
#, fuzzy
msgid "If you need to send a Kafka record, use:"
msgstr "Si necesita enviar un registro Kafka, utilice"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2540
#, no-wrap
msgid "import io.smallrye.reactive.messaging.kafka.Record;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2545
#, no-wrap
msgid "    @Channel(\"kafka\") Emitter<Record<String,String>> emitter;  // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2553
#, no-wrap
msgid ""
"    @POST\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public CompletionStage<Void> send(String payload) {\n"
"        return emitter.send(Record.of(\"my-key\", payload));    // <2>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2555
#, fuzzy
msgid "Note the usage of an `Emitter<Record<K, V>>`"
msgstr "Obsérvese el uso de un `Emitter&amp;lt;Record&amp;lt;K, V&amp;gt;&amp;gt;`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2556
#, fuzzy
msgid "Create the record using `Record.of(k, v)`"
msgstr "Cree el registro utilizando `Record.of(k, v)`"

#. type: Title ===
#: upstream/_guides/kafka.adoc:2557
#, fuzzy, no-wrap
msgid "Persisting Kafka messages with Hibernate with Panache"
msgstr "Persistencia de mensajes Kafka con Hibernate con Panache"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2560
#, fuzzy
msgid "To persist objects received from Kafka into a database, you can use Hibernate with Panache."
msgstr "Para persistir los objetos recibidos de Kafka en una base de datos, puede utilizar Hibernate con Panache."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2562
#, fuzzy
msgid "If you use Hibernate Reactive, look at xref:persisting-kafka-messages-with-hibernate-reactive[Persisting Kafka messages with Hibernate Reactive]."
msgstr "Si utiliza Hibernate Reactive, consulte  link:#persisting-kafka-messages-with-hibernate-reactive[[persisting-kafka-messages-with-hibernate-reactive]]."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2565 upstream/_guides/kafka.adoc:2645
#, fuzzy
msgid "Let's imagine you receive `Fruit` objects.  For simplicity purposes, our `Fruit` class is pretty simple:"
msgstr "Imaginemos que se reciben objetos de `Fruit`. Para simplificar, nuestra clase `Fruit` es bastante simple:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2573
#, no-wrap
msgid "import io.quarkus.hibernate.orm.panache.PanacheEntity;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2576 upstream/_guides/kafka.adoc:2656
#, no-wrap
msgid ""
"@Entity\n"
"public class Fruit extends PanacheEntity {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2578 upstream/_guides/kafka.adoc:2658
#, no-wrap
msgid "    public String name;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2583 upstream/_guides/kafka.adoc:2664
#, fuzzy
msgid "To consume `Fruit` instances stored on a Kafka topic, and persist them into a database, you can use the following approach:"
msgstr "Para consumir instancias de `Fruit` almacenadas en un tema de Kafka, y persistirlas en una base de datos, puede utilizar el siguiente enfoque:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2594
#, no-wrap
msgid "import io.smallrye.common.annotation.Blocking;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2597
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class FruitConsumer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2604
#, no-wrap
msgid ""
"    @Incoming(\"fruits\")                                     // <1>\n"
"    @Transactional                                          // <2>\n"
"    public void persistFruits(Fruit fruit) {                // <3>\n"
"        fruit.persist();                                    // <4>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2606
#, fuzzy
msgid "Configuring the incoming channel. This channel reads from Kafka."
msgstr "Configurar el canal de entrada. Este canal lee de Kafka."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2608
#, fuzzy
msgid "As we are writing in a database, we must be in a transaction. This annotation starts a new transaction and commits it when the method returns.  Quarkus automatically considers the method as _blocking_. Indeed, writing to a database using classic Hibernate is blocking. So, Quarkus calls the method on a worker thread you can block (and not an I/O thread)."
msgstr "Como estamos escribiendo en una base de datos, debemos estar en una transacción. Esta anotación inicia una nueva transacción y la consigna cuando el método retorna. Quarkus considera automáticamente el método como _bloqueante_. De hecho, escribir en una base de datos usando Hibernate clásico es bloqueante. Por lo tanto, Quarkus llama al método en un hilo de trabajo que puede bloquear (y no un hilo de E/S)."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2609
#, fuzzy
msgid "The method receives each Fruit. Note that you would need a deserializer to reconstruct the Fruit instances from the Kafka records."
msgstr "El método recibe cada Fruta. Tenga en cuenta que necesitaría un deserializador para reconstruir las instancias de Fruit a partir de los registros de Kafka."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2610
#, fuzzy
msgid "Persist the received `fruit` object."
msgstr "Persiste el objeto `fruit` recibido."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2613
#, fuzzy
msgid "As mentioned in <4>, you need a deserializer that can create a `Fruit` from the record.  This can be done using a Jackson deserializer:"
msgstr "Como se mencionó en &lt;4&gt;, se necesita un deserializador que pueda crear un `Fruit` a partir del registro. Esto se puede hacer utilizando un deserializador Jackson:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2628 upstream/_guides/kafka.adoc:2724
#, fuzzy
msgid "The associated configuration would be:"
msgstr "La configuración asociada sería:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2633 upstream/_guides/kafka.adoc:2729
#, no-wrap
msgid ""
"mp.messaging.incoming.fruits.connector=smallrye-kafka\n"
"mp.messaging.incoming.fruits.value.deserializer=org.acme.FruitDeserializer\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2637 upstream/_guides/kafka.adoc:2733
#, fuzzy
msgid "Check xref:jackson-serialization[Serializing via Jackson] for more detail about the usage of Jackson with Kafka.  You can also use Avro."
msgstr "Consulta  link:#jackson-serialization[[jackson-serialization]] para más detalles sobre el uso de Jackson con Kafka. También puedes usar Avro."

#. type: Title ===
#: upstream/_guides/kafka.adoc:2639
#, fuzzy, no-wrap
msgid "Persisting Kafka messages with Hibernate Reactive"
msgstr "Persistencia de mensajes Kafka con Hibernate Reactive"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2642
#, fuzzy
msgid "To persist objects received from Kafka into a database, you can use Hibernate Reactive with Panache."
msgstr "Para persistir los objetos recibidos de Kafka en una base de datos, puede utilizar Hibernate Reactive con Panache."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2653
#, no-wrap
msgid "import io.quarkus.hibernate.reactive.panache.PanacheEntity;  // <1>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2662
#, fuzzy
msgid "Make sure to use the reactive variant"
msgstr "Asegúrese de utilizar la variante reactiva"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2671
#, no-wrap
msgid ""
"import jakarta.enterprise.context.ApplicationScoped;\n"
"import jakarta.enterprise.context.control.ActivateRequestContext;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2676
#, no-wrap
msgid ""
"import io.quarkus.hibernate.reactive.panache.Panache;\n"
"import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2679
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class FruitStore {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2682
#, no-wrap
msgid ""
"    @Inject\n"
"    Mutiny.Session session;                    // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2691
#, no-wrap
msgid ""
"    @Incoming(\"in\")\n"
"    @ActivateRequestContext // <2>\n"
"    public Uni<Void> consume(Fruit entity) {\n"
"        return session.withTransaction(t -> {  // <3>\n"
"            return entity.persistAndFlush()    // <4>\n"
"                    .replaceWithVoid();        // <5>\n"
"        }).onTermination().call(() -> session.close()); // <6>\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2695
#, fuzzy
msgid "Inject the Hibernate Reactive `Session`"
msgstr "Inyecte el Hibernate Reactive `SessionFactory`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2698
#, fuzzy
msgid "Hibernate Reactive `Session` and `Panache` APIs require an active CDI Request context.  `@ActivateRequestContext` annotation creates a new request context and destroys it when the `Uni` returned from the method completes.  If `Panache` is not used, `Mutiny.SessionFactory` can be injected and used similarly without the need of activating the request context or closing the session manually."
msgstr "Las APIs de Hibernate Reactive `Session` y `Panache` requieren un contexto de petición CDI activo. La anotación `@ActivateRequestContext` crea un nuevo contexto de petición y lo destruye cuando el `Uni` devuelto por el método finaliza. Si no se utiliza `Panache`, puede inyectarse `Mutiny.SessionFactory` y utilizarse de forma similar sin necesidad de activar el contexto de solicitud o cerrar la sesión manualmente."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2699
#, fuzzy
msgid "Requests a new transaction. The transaction completes when the passed action completes."
msgstr "Indica a Panache que ejecute la acción dada (asíncrona) en una transacción. La transacción se completa cuando la acción se completa."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2700
#, fuzzy
msgid "Persist the entity. It returns a `Uni<Fruit>`."
msgstr "Persiste la entidad. Devuelve un `Uni&amp;lt;Fruit&amp;gt;`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2701
#, fuzzy
msgid "Switch back to a `Uni<Void>`."
msgstr "Vuelve a cambiar a un `Uni&amp;lt;Void&amp;gt;`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2702
#, fuzzy
msgid "Close the session - this is close the connection with the database. The connection can then be recycled."
msgstr "Cerrar la sesión - esto es cerrar la conexión con la base de datos. La conexión puede entonces ser reciclada."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2706
#, fuzzy
msgid "Unlike with _classic_ Hibernate, you can't use `@Transactional`.  Instead, we use `session.withTransaction` and persist our entity.  The `map` is used to return a `Uni<Void>` and not a `Uni<Fruit>`."
msgstr "A diferencia de lo que ocurre con Hibernate _clásico_, no se puede utilizar `@Transactional`. En su lugar, utilizamos `Panache.withTransaction` y persiste nuestra entidad. El `map` se utiliza para devolver un `Uni&amp;lt;Void&amp;gt;` y no un `Uni&amp;lt;Fruit&amp;gt;`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2709
#, fuzzy
msgid "You need a deserializer that can create a `Fruit` from the record.  This can be done using a Jackson deserializer:"
msgstr "Se necesita un deserializador que pueda crear un `Fruit` a partir del registro. Esto se puede hacer usando un deserializador Jackson:"

#. type: Title ===
#: upstream/_guides/kafka.adoc:2734
#, fuzzy, no-wrap
msgid "Writing entities managed by Hibernate to Kafka"
msgstr "Escritura de entidades gestionadas por Hibernate en Kafka"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2737
#, fuzzy
msgid "Let's imagine the following process:"
msgstr "Imaginemos el siguiente proceso:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2739
#, fuzzy
msgid "You receive an HTTP request with a payload,"
msgstr "Recibe una petición HTTP con una carga útil,"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2740
#, fuzzy
msgid "You create an Hibernate entity instance from this payload,"
msgstr "Se crea una instancia de entidad Hibernate a partir de esta carga útil,"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2741
#, fuzzy
msgid "You persist that entity into a database,"
msgstr "Se persiste esa entidad en una base de datos,"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2742
#, fuzzy
msgid "You send the entity to a Kafka topic"
msgstr "Se envía la entidad a un tema Kafka"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2744
#, fuzzy
msgid "If you use Hibernate Reactive, look at xref:writing-entities-managed-by-hibernate-reactive-to-kafka[Writing entities managed by Hibernate Reactive to Kafka]."
msgstr "Si utiliza Hibernate Reactive, consulte  link:#writing-entities-managed-by-hibernate-reactive-to-kafka[[writing-entities-managed-by-hibernate-reactive-to-kafka]]."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2750
#, fuzzy
msgid "Because we write to a database, we must run this method in a transaction.  Yet, sending the entity to Kafka happens asynchronously.  The operation returns a `CompletionStage` (or a `Uni` if you use a `MutinyEmitter`) reporting when the operation completes.  We must be sure that the transaction is still running until the object is written.  Otherwise, you may access the object outside the transaction, which is not allowed."
msgstr "Como escribimos en una base de datos, debemos ejecutar este método en una transacción. Sin embargo, el envío de la entidad a Kafka ocurre de forma asíncrona. La operación devuelve un `CompletionStage` (o un `Uni` si se utiliza un `MutinyEmitter`) informando cuando la operación se completa. Debemos asegurarnos de que la transacción sigue en marcha hasta que se escribe el objeto. De lo contrario, se podría acceder al objeto fuera de la transacción, lo que no está permitido."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2752
#, fuzzy
msgid "To implement this process, you need the following approach:"
msgstr "Para llevar a cabo este proceso, es necesario el siguiente enfoque:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2762
#, no-wrap
msgid ""
"import jakarta.transaction.Transactional;\n"
"import jakarta.ws.rs.POST;\n"
"import jakarta.ws.rs.Path;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2770
#, no-wrap
msgid "    @Channel(\"kafka\") Emitter<Fruit> emitter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2779
#, no-wrap
msgid ""
"    @POST\n"
"    @Path(\"/fruits\")\n"
"    @Transactional                                                      // <1>\n"
"    public CompletionStage<Void> storeAndSendToKafka(Fruit fruit) {     // <2>\n"
"        fruit.persist();\n"
"        return emitter.send(new FruitDto(fruit));                       // <3>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2781
#, fuzzy
msgid "As we are writing to the database, make sure we run inside a transaction"
msgstr "Como estamos escribiendo en la base de datos, asegúrese de que se ejecuta dentro de una transacción"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2782
#, fuzzy
msgid "The method receives the fruit instance to persist. It returns a `CompletionStage` which is used for the transaction demarcation. The transaction is committed when the return `CompletionStage` completes. In our case, it's when the message is written to Kafka."
msgstr "El método recibe la instancia de la fruta a persistir. Devuelve un `CompletionStage` que se utiliza para la demarcación de la transacción. La transacción se compromete cuando se completa el retorno `CompletionStage`. En nuestro caso, es cuando el mensaje se escribe en Kafka."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2784
#, fuzzy
msgid "Wrap the managed entity inside a Data transfer object and send it to Kafka.  This makes sure that managed entity is not impacted by the Kafka serialization."
msgstr "Envolver la entidad gestionada dentro de un objeto de transferencia de datos y enviarlo a Kafka. Esto asegura que la entidad gestionada no se vea afectada por la serialización de Kafka."

#. type: Title ===
#: upstream/_guides/kafka.adoc:2786
#, fuzzy, no-wrap
msgid "Writing entities managed by Hibernate Reactive to Kafka"
msgstr "Escritura de entidades gestionadas por Hibernate Reactive en Kafka"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2789
#, fuzzy
msgid "To send to Kafka entities managed by Hibernate Reactive, we recommend using:"
msgstr "Para enviar a las entidades de Kafka gestionadas por Hibernate Reactive, se recomienda utilizar:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2791
#, fuzzy
msgid "RESTEasy Reactive to serve HTTP requests"
msgstr "RESTEasy Reactive para servir peticiones HTTP"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2792
#, fuzzy
msgid "A `MutinyEmitter` to send message to a channel, so it can be easily integrated with the Mutiny API exposed by Hibernate Reactive or Hibernate Reactive with Panache."
msgstr "Un `MutinyEmitter` para enviar mensajes a un canal, por lo que se puede integrar fácilmente con la API Mutiny expuesta por Hibernate Reactive o Hibernate Reactive con Panache."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2794
#, fuzzy
msgid "The following example demonstrates how to receive a payload, store it in the database using Hibernate Reactive with Panache, and send the persisted entity to Kafka:"
msgstr "El siguiente ejemplo demuestra cómo recibir una carga útil, almacenarla en la base de datos utilizando Hibernate Reactive con Panache, y enviar la entidad persistente a Kafka:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2801
#, no-wrap
msgid ""
"import jakarta.ws.rs.POST;\n"
"import jakarta.ws.rs.Path;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2807
#, no-wrap
msgid ""
"import io.quarkus.hibernate.reactive.panache.Panache;\n"
"import io.smallrye.mutiny.Uni;\n"
"import io.smallrye.reactive.messaging.MutinyEmitter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2810
#, no-wrap
msgid ""
"@Path(\"/\")\n"
"public class ReactiveGreetingResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2812
#, no-wrap
msgid "    @Channel(\"kafka\") MutinyEmitter<Fruit> emitter;     // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2822
#, no-wrap
msgid ""
"    @POST\n"
"    @Path(\"/fruits\")\n"
"    public Uni<Void> sendToKafka(Fruit fruit) {         // <2>\n"
"        return Panache.withTransaction(() ->            // <3>\n"
"            fruit.<Fruit>persist()\n"
"        )\n"
"            .chain(f -> emitter.send(f));               // <4>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2824
#, fuzzy
msgid "Inject a `MutinyEmitter` which exposes a Mutiny API. It simplifies the integration with the Mutiny API exposed by Hibernate Reactive with Panache."
msgstr "Inyecta un `MutinyEmitter` que expone una API Mutiny. Simplifica la integración con la API Mutiny expuesta por Hibernate Reactive con Panache."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2825
#, fuzzy
msgid "The HTTP method receiving the payload returns a `Uni<Void>`. The HTTP response is written when the operation completes (the entity is persisted and written to Kafka)."
msgstr "El método HTTP que recibe la carga útil devuelve un `Uni&amp;lt;Void&amp;gt;`. La respuesta HTTP se escribe cuando la operación se completa (la entidad se persiste y se escribe en Kafka)."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2826
#, fuzzy
msgid "We need to write the entity into the database in a transaction."
msgstr "Necesitamos escribir la entidad en la base de datos en una transacción."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2827
#, fuzzy
msgid "Once the persist operation completes, we send the entity to Kafka. The `send` method returns a `Uni<Void>`."
msgstr "Una vez completada la operación de persistencia, enviamos la entidad a Kafka. El método `send` devuelve un `Uni&amp;lt;Void&amp;gt;`."

#. type: Title ===
#: upstream/_guides/kafka.adoc:2829
#, fuzzy, no-wrap
msgid "Streaming Kafka topics as server-sent events"
msgstr "Transmisión de temas Kafka como eventos enviados por el servidor"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2832
#, fuzzy
msgid "Streaming a Kafka topic as server-sent events (SSE) is straightforward:"
msgstr "La transmisión de un tema de Kafka como eventos enviados por el servidor (SSE) es sencilla:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2834
#, fuzzy
msgid "You inject the channel representing the Kafka topic in your HTTP endpoint"
msgstr "Se inyecta el canal que representa el tema de Kafka en su punto final HTTP"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2835
#, fuzzy
msgid "You return that channel as a `Publisher` or a `Multi` from the HTTP method"
msgstr "Se devuelve ese canal como un `Publisher` o un `Multi` desde el método HTTP"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2837
#, fuzzy
msgid "The following code provides an example:"
msgstr "El siguiente código proporciona un ejemplo:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2842 upstream/_guides/kafka.adoc:2857
#, no-wrap
msgid ""
"@Channel(\"fruits\")\n"
"Multi<Fruit> fruits;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2848
#, no-wrap
msgid ""
"@GET\n"
"@Produces(MediaType.SERVER_SENT_EVENTS)\n"
"public Multi<Fruit> stream() {\n"
"    return fruits;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2852
#, fuzzy
msgid "Some environment cuts the SSE connection when there is not enough activity.  The workaround consists of sending _ping_ messages (or empty objects) periodically."
msgstr "Algunos entornos cortan la conexión SSE cuando no hay suficiente actividad. La solución consiste en enviar mensajes _ping_ (u objetos vacíos) periódicamente."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2860
#, no-wrap
msgid ""
"@Inject\n"
"ObjectMapper mapper;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2870
#, no-wrap
msgid ""
"@GET\n"
"@Produces(MediaType.SERVER_SENT_EVENTS)\n"
"public Multi<String> stream() {\n"
"    return Multi.createBy().merging()\n"
"            .streams(\n"
"                    fruits.map(this::toJson),\n"
"                    emitAPeriodicPing()\n"
"            );\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2875
#, no-wrap
msgid ""
"Multi<String> emitAPeriodicPing() {\n"
"    return Multi.createFrom().ticks().every(Duration.ofSeconds(10))\n"
"            .onItem().transform(x -> \"{}\");\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2883
#, no-wrap
msgid ""
"private String toJson(Fruit f) {\n"
"    try {\n"
"        return mapper.writeValueAsString(f);\n"
"    } catch (JsonProcessingException e) {\n"
"        throw new RuntimeException(e);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2887
#, fuzzy
msgid "The workaround is a bit more complex as besides sending the fruits coming from Kafka, we need to send pings periodically.  To achieve this we merge the stream coming from Kafka and a periodic stream emitting `{}` every 10 seconds."
msgstr "El workaround es un poco más complejo ya que además de enviar los frutos provenientes de Kafka, necesitamos enviar pings periódicamente. Para ello fusionamos el flujo procedente de Kafka y un flujo periódico que emite `{}` cada 10 segundos."

#. type: Title ===
#: upstream/_guides/kafka.adoc:2889
#, fuzzy, no-wrap
msgid "Chaining Kafka Transactions with Hibernate Reactive transactions"
msgstr "Persistencia de mensajes Kafka con Hibernate Reactive"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2893
#, fuzzy
msgid "By chaining a Kafka transaction with a Hibernate Reactive transaction you can send records to a Kafka transaction, perform database updates and commit the Kafka transaction only if the database transaction is successful."
msgstr "Al encadenar una transacción de Kafka con una transacción de Hibernate Reactive se pueden enviar registros a una transacción de Kafka, realizar actualizaciones de la base de datos y consignar la transacción de Kafka sólo si la transacción de la base de datos tiene éxito."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2895
#, fuzzy
msgid "The following example demonstrates:"
msgstr "El siguiente ejemplo lo demuestra:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2897
#, fuzzy
msgid "Receive a payload by serving HTTP requests using RESTEasy Reactive,"
msgstr "Recibir una carga útil sirviendo peticiones HTTP utilizando RESTEasy Reactive,"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2898
#, fuzzy
msgid "Limit concurrency of that HTTP endpoint using Smallrye Fault Tolerance,"
msgstr "Limitar la concurrencia de ese punto final HTTP utilizando Smallrye Fault Tolerance,"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2899
#, fuzzy
msgid "Start a Kafka transaction and send the payload to Kafka record,"
msgstr "Iniciar una transacción Kafka y enviar la carga útil al registro Kafka,"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2900
#, fuzzy
msgid "Store the payload in the database using Hibernate Reactive with Panache,"
msgstr "Para persistir los objetos recibidos de Kafka en una base de datos, puede utilizar Hibernate Reactive con Panache."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2901
#, fuzzy
msgid "Commit the Kafka transaction only if the entity is persisted successfully."
msgstr "Compromete la transacción de Kafka sólo si la entidad se persiste con éxito."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2910
#, no-wrap
msgid ""
"import jakarta.ws.rs.Consumes;\n"
"import jakarta.ws.rs.POST;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2914 upstream/_guides/kafka.adoc:2964
#, no-wrap
msgid ""
"import org.eclipse.microprofile.faulttolerance.Bulkhead;\n"
"import org.eclipse.microprofile.reactive.messaging.Channel;\n"
"import org.hibernate.reactive.mutiny.Mutiny;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2918
#, no-wrap
msgid ""
"import io.quarkus.hibernate.reactive.panache.Panache;\n"
"import io.smallrye.mutiny.Uni;\n"
"import io.smallrye.reactive.messaging.kafka.transactions.KafkaTransactions;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2921 upstream/_guides/kafka.adoc:2972
#, no-wrap
msgid ""
"@Path(\"/\")\n"
"public class FruitProducer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2923
#, no-wrap
msgid "    @Channel(\"kafka\") KafkaTransactions<Fruit> kafkaTx; // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2937
#, no-wrap
msgid ""
"    @POST\n"
"    @Path(\"/fruits\")\n"
"    @Consumes(MediaType.APPLICATION_JSON)\n"
"    @Bulkhead(1) // <2>\n"
"    public Uni<Void> post(Fruit fruit) { // <3>\n"
"        return kafkaTx.withTransaction(emitter -> { // <4>\n"
"            emitter.send(fruit); // <5>\n"
"            return Panache.withTransaction(() -> { // <6>\n"
"                return fruit.<Fruit>persist(); // <7>\n"
"            });\n"
"        }).replaceWithVoid();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2940
#, fuzzy
msgid "Inject a `KafkaTransactions` which exposes a Mutiny API. It allows the integration with the Mutiny API exposed by Hibernate Reactive with Panache."
msgstr "Inyecta un `MutinyEmitter` que expone una API Mutiny. Simplifica la integración con la API Mutiny expuesta por Hibernate Reactive con Panache."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2941
#, fuzzy
msgid "Limit the concurrency of the HTTP endpoint to \"1\", preventing starting multiple transactions at a given time."
msgstr "Limita la concurrencia del extremo HTTP a \"1\", impidiendo el inicio de múltiples transacciones en un momento dado."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2942
#, fuzzy
msgid "The HTTP method receiving the payload returns a `Uni<Void>`. The HTTP response is written when the operation completes (the entity is persisted and Kafka transaction is committed)."
msgstr "El método HTTP que recibe la carga útil devuelve un `Uni&amp;lt;Void&amp;gt;`. La respuesta HTTP se escribe cuando la operación se completa (la entidad se persiste y se escribe en Kafka)."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2943 upstream/_guides/kafka.adoc:2996
#, fuzzy
msgid "Begin a Kafka transaction."
msgstr "Probar una aplicación Kafka"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2944
#, fuzzy
msgid "Send the payload to Kafka inside the Kafka transaction."
msgstr "Enviar la carga útil a Kafka dentro de la transacción Kafka."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2945
#, fuzzy
msgid "Persist the entity into the database in a Hibernate Reactive transaction."
msgstr "Necesitamos escribir la entidad en la base de datos en una transacción."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2947
#, fuzzy
msgid "Once the persist operation completes, and there is no errors, the Kafka transaction is committed.  The result is omitted and returned as the HTTP response."
msgstr "Una vez que la operación de persistencia se completa, y no hay errores, la transacción de Kafka se confirma. El resultado se omite y se devuelve como respuesta HTTP."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2950
#, fuzzy
msgid "In the previous example the database transaction (inner) will commit followed by the Kafka transaction (outer).  If you wish to commit the Kafka transaction first and the database transaction second, you need to nest them in the reverse order."
msgstr "En el ejemplo anterior, la transacción de la base de datos (interna) se confirmará seguida de la transacción de Kafka (externa). Si desea confirmar la transacción de Kafka primero y la transacción de la base de datos después, debe anidarlas en el orden inverso."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2952
#, fuzzy
msgid "The next example demonstrates that using the Hibernate Reactive API (without Panache):"
msgstr "El siguiente ejemplo demuestra que utilizando la API Reactiva de Hibernate (sin Panache):"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2960
#, no-wrap
msgid ""
"import jakarta.inject.Inject;\n"
"import jakarta.ws.rs.Consumes;\n"
"import jakarta.ws.rs.POST;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2969
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Uni;\n"
"import io.smallrye.reactive.messaging.kafka.transactions.KafkaTransactions;\n"
"import io.vertx.mutiny.core.Context;\n"
"import io.vertx.mutiny.core.Vertx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2974
#, no-wrap
msgid "    @Channel(\"kafka\") KafkaTransactions<Fruit> kafkaTx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2976
#, no-wrap
msgid "    @Inject Mutiny.SessionFactory sf; // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2990
#, no-wrap
msgid ""
"    @POST\n"
"    @Path(\"/fruits\")\n"
"    @Consumes(MediaType.APPLICATION_JSON)\n"
"    @Bulkhead(1)\n"
"    public Uni<Void> post(Fruit fruit) {\n"
"        Context context = Vertx.currentContext(); // <2>\n"
"        return sf.withTransaction(session -> // <3>\n"
"                kafkaTx.withTransaction(emitter -> // <4>\n"
"                        session.persist(fruit).invoke(() -> emitter.send(fruit)) // <5>\n"
"                ).emitOn(context::runOnContext) // <6>\n"
"        );\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2993
#, fuzzy
msgid "Inject the Hibernate Reactive `SessionFactory`."
msgstr "Inyecte el Hibernate Reactive `SessionFactory`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2994
#, fuzzy
msgid "Capture the caller Vert.x context."
msgstr "Captura el contexto Vert.x de la persona que llama."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2995
#, fuzzy
msgid "Begin a Hibernate Reactive transaction."
msgstr "Iniciar una transacción Hibernate Reactive."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2997
#, fuzzy
msgid "Persist the payload and send the entity to Kafka."
msgstr "Se envía la entidad a un tema Kafka"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2999
#, fuzzy
msgid "The Kafka transaction terminates on the Kafka producer sender thread.  We need to switch to the Vert.x context previously captured in order to terminate the Hibernate Reactive transaction on the same context we started it."
msgstr "La transacción Kafka termina en el hilo emisor del productor Kafka. Necesitamos cambiar al contexto Vert.x previamente capturado para terminar la transacción Hibernate Reactive en el mismo contexto en el que la iniciamos."

#. type: Title ==
#: upstream/_guides/kafka.adoc:3000
#, fuzzy, no-wrap
msgid "Logging"
msgstr "Registro"

#. type: Plain text
#: upstream/_guides/kafka.adoc:3003
#, fuzzy
msgid "To reduce the amount of log written by the Kafka client, Quarkus sets the level of the following log categories to `WARNING`:"
msgstr "Para reducir la cantidad de registro escrito por el cliente Kafka, Quarkus establece el nivel de las siguientes categorías de registro en `WARNING`:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:3005
#, fuzzy
msgid "`org.apache.kafka.clients`"
msgstr "`org.apache.kafka.clients`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:3006
#, fuzzy
msgid "`org.apache.kafka.common.utils`"
msgstr "`org.apache.kafka.common.utils`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:3007
#, fuzzy
msgid "`org.apache.kafka.common.metrics`"
msgstr "`org.apache.kafka.common.metrics`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:3009
#, fuzzy
msgid "You can override the configuration by adding the following lines to the `application.properties`:"
msgstr "Puede anular la configuración añadiendo las siguientes líneas a `application.properties`:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:3015
#, no-wrap
msgid ""
"quarkus.log.category.\"org.apache.kafka.clients\".level=INFO\n"
"quarkus.log.category.\"org.apache.kafka.common.utils\".level=INFO\n"
"quarkus.log.category.\"org.apache.kafka.common.metrics\".level=INFO\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:3017
#, fuzzy, no-wrap
msgid "Connecting to Managed Kafka clusters"
msgstr "Conexión a clusters Kafka gestionados"

#. type: Plain text
#: upstream/_guides/kafka.adoc:3020
#, fuzzy
msgid "This section explains how to connect to notorious Kafka Cloud Services."
msgstr "Esta sección explica cómo conectarse a los notorios servicios en la nube de Kafka."

#. type: Title ===
#: upstream/_guides/kafka.adoc:3021
#, fuzzy, no-wrap
msgid "Azure Event Hub"
msgstr "Azure Event Hub"

#. type: Plain text
#: upstream/_guides/kafka.adoc:3024
#, fuzzy
msgid "https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview[Azure Event Hub] provides an endpoint compatible with Apache Kafka."
msgstr "link:https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview[Azure Event Hub] proporciona un punto final compatible con Apache Kafka."

#. type: Plain text
#: upstream/_guides/kafka.adoc:3028
#, fuzzy
msgid "Azure Event Hubs for Kafka is not available in the _basic_ tier.  You need at least the _standard_ tier to use Kafka.  See https://azure.microsoft.com/en-us/pricing/details/event-hubs/[Azure Event Hubs Pricing] to see the other options."
msgstr "Azure Event Hubs para Kafka no está disponible en el nivel _básico_. Necesita al menos el nivel _estándar_ para utilizar Kafka. Consulte  link:https://azure.microsoft.com/en-us/pricing/details/event-hubs/[los precios de Azure Event Hubs] para ver las otras opciones."

#. type: Plain text
#: upstream/_guides/kafka.adoc:3030
#, fuzzy
msgid "To connect to Azure Event Hub, using the Kafka protocol with TLS, you need the following configuration:"
msgstr "Para conectarse a Azure Event Hub, utilizando el protocolo Kafka con TLS, se necesita la siguiente configuración:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:3039
#, no-wrap
msgid ""
"kafka.bootstrap.servers=my-event-hub.servicebus.windows.net:9093 # <1>\n"
"kafka.security.protocol=SASL_SSL\n"
"kafka.sasl.mechanism=PLAIN\n"
"kafka.sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required \\ # <2>\n"
"    username=\"$ConnectionString\" \\ # <3>\n"
"    password=\"<YOUR.EVENTHUBS.CONNECTION.STRING>\"; # <4>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:3041
#, fuzzy
msgid "The port is `9093`."
msgstr "El puerto es `9093`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:3042
#, fuzzy
msgid "You need to use the JAAS `PlainLoginModule`."
msgstr "Es necesario utilizar el JAAS `PlainLoginModule`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:3043
#, fuzzy
msgid "The username is the `$ConnectionString` string."
msgstr "El nombre de usuario es la cadena `$ConnectionString`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:3044
#, fuzzy
msgid "The Event Hub connection string given by Azure."
msgstr "La cadena de conexión del centro de eventos proporcionada por Azure."

#. type: Plain text
#: upstream/_guides/kafka.adoc:3048
#, fuzzy
msgid "Replace `<YOUR.EVENTHUBS.CONNECTION.STRING>` with the connection string for your Event Hubs namespace.  For instructions on getting the connection string, see https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-get-connection-string[Get an Event Hubs connection string].  The result would be something like:"
msgstr "Sustituye `&amp;lt;YOUR.EVENTHUBS.CONNECTION.STRING&amp;gt;` por la cadena de conexión de tu espacio de nombres Event Hubs. Para obtener instrucciones sobre cómo obtener la cadena de conexión, consulte  link:https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-get-connection-string[Obtener una cadena de conexión] de Event Hubs. El resultado sería algo como"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:3054
#, no-wrap
msgid ""
"kafka.sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required \\\n"
"    username=\"$ConnectionString\" \\\n"
"    password=\"Endpoint=sb://my-event-hub.servicebus.windows.net/;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=XXXXXXXXXXXXXXXX\";\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:3057
#, fuzzy
msgid "This configuration can be global (as above), or set in the channel configuration:"
msgstr "Esta configuración puede ser global (como en el caso anterior), o establecerse en la configuración del canal:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:3066
#, no-wrap
msgid ""
"mp.messaging.incoming.$channel.bootstrap.servers=my-event-hub.servicebus.windows.net:9093\n"
"mp.messaging.incoming.$channel.security.protocol=SASL_SSL\n"
"mp.messaging.incoming.$channel.sasl.mechanism=PLAIN\n"
"mp.messaging.incoming.$channel.sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required \\\n"
"    username=\"$ConnectionString\" \\\n"
"    password=\"Endpoint=sb://my-event-hub.servicebus.windows.net/;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=...\";\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/kafka.adoc:3068
#, fuzzy, no-wrap
msgid "Red Hat OpenShift Streams for Apache Kafka"
msgstr "Red Hat OpenShift Streams para Apache Kafka"

#. type: Plain text
#: upstream/_guides/kafka.adoc:3073
#, fuzzy
msgid "https://cloud.redhat.com/[Red Hat OpenShift Streams for Apache Kafka] provides managed Kafka brokers.  First, follow the instructions from https://access.redhat.com/documentation/en-us/red_hat_openshift_streams_for_apache_kafka/1/guide/88e1487a-2a14-4b35-85b9-a7a2d67a37f3[Getting started with the `rhoas` CLI for Red Hat OpenShift Streams for Apache Kafka] to create your Kafka broker instance.  Make sure you copied the client id and client secret associated with the _ServiceAccount_ you created."
msgstr "Red Hat OpenShift link:https://cloud.redhat.com/[Streams] para Apache Kafka proporciona brokers de Kafka gestionados. En primer lugar, siga las instrucciones de  link:https://access.redhat.com/documentation/en-us/red_hat_openshift_streams_for_apache_kafka/1/guide/88e1487a-2a14-4b35-85b9-a7a2d67a37f3[Getting started with the `rhoas` CLI for Red Hat OpenShift Streams for Apache Kafka] para crear su instancia de broker de Kafka. Asegúrese de que ha copiado el id de cliente y el secreto de cliente asociados a la _ServiceAccount_ que ha creado."

#. type: Plain text
#: upstream/_guides/kafka.adoc:3075
#, fuzzy
msgid "Then, you can configure the Quarkus application to connect to the broker as follows:"
msgstr "A continuación, puede configurar la aplicación Quarkus para conectarse al broker de la siguiente manera:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:3084
#, no-wrap
msgid ""
"kafka.bootstrap.servers=<connection url> # <1>\n"
"kafka.security.protocol=SASL_SSL\n"
"kafka.sasl.mechanism=PLAIN\n"
"kafka.sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required \\\n"
"  username=\"${KAFKA_USERNAME}\" \\ # <2>\n"
"  password=\"${KAFKA_PASSWORD}\"; # <3>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:3086
#, fuzzy
msgid "The connection string, given on the admin console, such as `demo-c--bjsv-ldd-cvavkc-a.bf2.kafka.rhcloud.com:443`"
msgstr "La cadena de conexión, dada en la consola de administración, como `demo-c—​bjsv-ldd-cvavkc-a.bf2.kafka.rhcloud.com:443`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:3087
#, fuzzy
msgid "The kafka username (the client id from the service account)"
msgstr "El nombre de usuario de kafka (el identificador de cliente de la cuenta de servicio)"

#. type: Plain text
#: upstream/_guides/kafka.adoc:3088
#, fuzzy
msgid "the kafka password (the client secret from the service account)"
msgstr "la contraseña de kafka (el secreto del cliente de la cuenta de servicio)"

#. type: Plain text
#: upstream/_guides/kafka.adoc:3090
#, fuzzy
msgid "In general, these properties are prefixed using `%prod` to enable them only when running in production mode."
msgstr "En general, estas propiedades llevan el prefijo `%prod` para habilitarlas sólo cuando se ejecutan en modo de producción."

#. type: Plain text
#: upstream/_guides/kafka.adoc:3093
#, fuzzy
msgid "As explained in https://access.redhat.com/documentation/en-us/red_hat_openshift_streams_for_apache_kafka/1/guide/88e1487a-2a14-4b35-85b9-a7a2d67a37f3[Getting started with the rhoas CLI for Red Hat OpenShift Streams for Apache Kafka], to use Red Hat OpenShift Streams for Apache Kafka, you must create the topic beforehand, create a _Service Account_, and provide permissions to read and write to your topic from that service account.  The authentication data (client id and secret) relates to the service account, which means you can implement fine-grain permissions and restrict access to the topic."
msgstr "Como se explica en  link:https://access.redhat.com/documentation/en-us/red_hat_openshift_streams_for_apache_kafka/1/guide/88e1487a-2a14-4b35-85b9-a7a2d67a37f3[Getting started with the rhoas CLI for Red Hat OpenShift Streams for Apache Kafka], para utilizar Red Hat OpenShift Streams for Apache Kafka, debe crear el tema de antemano, crear una _cuenta_ de servicio y proporcionar permisos para leer y escribir en su tema desde esa cuenta de servicio. Los datos de autenticación (id de cliente y secreto) se relacionan con la cuenta de servicio, lo que significa que puede implementar permisos de grano fino y restringir el acceso al tema."

#. type: Plain text
#: upstream/_guides/kafka.adoc:3095
#, fuzzy
msgid "When using Kubernetes, it is recommended to set the client id and secret in a Kubernetes secret:"
msgstr "Cuando se utiliza Kubernetes, se recomienda establecer el id de cliente y el secreto en un secreto de Kubernetes:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:3105
#, no-wrap
msgid ""
"apiVersion: v1\n"
"kind: Secret\n"
"metadata:\n"
"  name: kafka-credentials\n"
"stringData:\n"
"  KAFKA_USERNAME: \"...\"\n"
"  KAFKA_PASSWORD: \"...\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:3108
#, fuzzy
msgid "To allow your Quarkus application to use that secret, add the following line to the `application.properties` file:"
msgstr "Para permitir que su aplicación Quarkus utilice ese secreto, añada la siguiente línea al archivo `application.properties`:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:3112
#, no-wrap
msgid "%prod.quarkus.openshift.env.secrets=kafka-credentials\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/kafka.adoc:3114
#, fuzzy, no-wrap
msgid "Red Hat OpenShift Service Registry"
msgstr "Red Hat OpenShift Streams para Apache Kafka"

#. type: Plain text
#: upstream/_guides/kafka.adoc:3118
#, fuzzy
msgid "https://www.redhat.com/en/technologies/cloud-computing/openshift/openshift-service-registry[Red Hat OpenShift Service Registry] provides fully managed service registry for handling Kafka schemas."
msgstr "link:https://www.redhat.com/en/technologies/cloud-computing/openshift/openshift-service-registry[Red Hat OpenShift Service Registry] proporciona un registro de servicios totalmente gestionado para manejar los esquemas de Kafka."

#. type: Plain text
#: upstream/_guides/kafka.adoc:3122
#, fuzzy
msgid "You can follow the instructions from https://access.redhat.com/documentation/en-us/red_hat_openshift_service_registry/1/guide/ab1894d1-cae0-4d11-b185-81d62b4aabc7#_60472331-fa00-48ec-a621-bbd039500c7d[Getting started with Red Hat OpenShift Service Registry], or use the `rhoas` CLI to create a new service registry instance:"
msgstr "Puede seguir las instrucciones de  link:https://access.redhat.com/documentation/en-us/red_hat_openshift_service_registry/1/guide/ab1894d1-cae0-4d11-b185-81d62b4aabc7#_60472331-fa00-48ec-a621-bbd039500c7d[Introducción al registro de servicios de Red Hat OpenShift] o utilizar la CLI de `rhoas` para crear una nueva instancia de registro de servicios:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:3126
#, no-wrap
msgid "rhoas service-registry create --name my-schema-registry\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:3131
#, fuzzy
msgid "Make sure to note the _Registry URL_ of the instance created.  For authentication, you can use the same _ServiceAccount_ you created previously.  You need to make sure that it has the necessary permissions to access the service registry."
msgstr "Asegúrese de anotar la _URL del Registro_ de la instancia creada. Para la autenticación, puede utilizar la misma _ServiceAccount_ que creó anteriormente. Debe asegurarse de que tiene los permisos necesarios para acceder al registro de servicios."

#. type: Plain text
#: upstream/_guides/kafka.adoc:3133
#, fuzzy
msgid "For example, using the `rhoas` CLI, you can grant the `MANAGER` role to the service account:"
msgstr "Por ejemplo, utilizando la CLI `rhoas`, puede conceder el rol `MANAGER` a la cuenta de servicio:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:3137
#, no-wrap
msgid "rhoas service-registry role add --role manager --service-account [SERVICE_ACCOUNT_CLIENT_ID]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:3140
#, fuzzy
msgid "Then, you can configure the Quarkus application to connect to the schema registry as follows:"
msgstr "A continuación, puede configurar la aplicación Quarkus para conectarse al broker de la siguiente manera:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:3147
#, no-wrap
msgid ""
"mp.messaging.connector.smallrye-kafka.apicurio.registry.url=${RHOAS_SERVICE_REGISTRY_URL} <1>\n"
"mp.messaging.connector.smallrye-kafka.apicurio.auth.service.token.endpoint=${RHOAS_OAUTH_TOKEN_ENDPOINT} <2>\n"
"mp.messaging.connector.smallrye-kafka.apicurio.auth.client.id=${RHOAS_CLIENT_ID} <3>\n"
"mp.messaging.connector.smallrye-kafka.apicurio.auth.client.secret=${RHOAS_CLIENT_ID} <4>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:3149
#, fuzzy
msgid "The service registry URL, given on the admin console, such as `https://bu98.serviceregistry.rhcloud.com/t/0e95af2c-6e11-475e-82ee-f13bd782df24/apis/registry/v2`"
msgstr "La URL del registro de servicios, dada en la consola de administración, como `&lt;a href=\"https://bu98.serviceregistry.rhcloud.com/t/0e95af2c-6e11-475e-82ee-f13bd782df24/apis/registry/v2\" class=\"bare\"&gt;https://bu98.serviceregistry.rhcloud.com/t/0e95af2c-6e11-475e-82ee-f13bd782df24/apis/registry/v2&lt;/a&gt;`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:3150
#, fuzzy
msgid "The OAuth token endpoint URL, such as `https://identity.api.openshift.com/auth/realms/rhoas/protocol/openid-connect/token`"
msgstr "La URL del punto final del token OAuth, como `&lt;a href=\"https://identity.api.openshift.com/auth/realms/rhoas/protocol/openid-connect/token\" class=\"bare\"&gt;https://identity.api.openshift.com/auth/realms/rhoas/protocol/openid-connect/token&lt;/a&gt;`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:3151
#, fuzzy
msgid "The client id (from the service account)"
msgstr "El nombre de usuario de kafka (el identificador de cliente de la cuenta de servicio)"

#. type: Plain text
#: upstream/_guides/kafka.adoc:3152
#, fuzzy
msgid "The client secret (from the service account)"
msgstr "la contraseña de kafka (el secreto del cliente de la cuenta de servicio)"

#. type: Title ====
#: upstream/_guides/kafka.adoc:3153
#, fuzzy, no-wrap
msgid "Binding Red Hat OpenShift managed services to Quarkus application using the Service Binding Operator"
msgstr "Vinculación de los servicios gestionados de Red Hat OpenShift a la aplicación Quarkus mediante el operador de vinculación de servicios"

#. type: Plain text
#: upstream/_guides/kafka.adoc:3157
#, fuzzy
msgid "If your Quarkus application is deployed on a Kubernetes or OpenShift cluster with link:https://github.com/redhat-developer/service-binding-operator[Service Binding Operator] and link:https://github.com/redhat-developer/app-services-operator/tree/main/docs[OpenShift Application Services] operators installed, configurations necessary to access Red Hat OpenShift Streams for Apache Kafka and Service Registry can be injected to the application using xref:deploying-to-kubernetes.adoc#service_binding[Kubernetes Service Binding]."
msgstr "Si su aplicación de Quarkus se despliega en un clúster de Kubernetes u OpenShift con operadores de Service  link:https://github.com/redhat-developer/service-binding-operator[Binding] y  link:https://github.com/redhat-developer/app-services-operator/tree/main/docs[OpenShift Application Services] instalados, las configuraciones necesarias para acceder a Red Hat OpenShift Streams para Apache Kafka y Service Registry pueden inyectarse en la aplicación utilizando  link:deploying-to-kubernetes.html#service_binding[Kubernetes Service Binding]."

#. type: Plain text
#: upstream/_guides/kafka.adoc:3160
#, fuzzy
msgid "In order to set up the Service Binding, you need first to connect OpenShift managed services to your cluster.  For an OpenShift cluster you can follow the instructions from link:https://github.com/redhat-developer/app-services-guides/tree/main/docs/registry/service-binding-registry#connecting-a-kafka-and-service-registry-instance-to-your-openshift-cluster[Connecting a Kafka and Service Registry instance to your OpenShift cluster]."
msgstr "Para configurar la vinculación de servicios, primero debe conectar los servicios gestionados de OpenShift a su clúster. Para un clúster de OpenShift, puede seguir las instrucciones de  link:https://github.com/redhat-developer/app-services-guides/tree/main/docs/registry/service-binding-registry#connecting-a-kafka-and-service-registry-instance-to-your-openshift-cluster[Conectar una instancia de Kafka y Service Registry a su clúster de OpenShift]."

#. type: Plain text
#: upstream/_guides/kafka.adoc:3162
#, fuzzy
msgid "Once you've connected your cluster with the RHOAS Kafka and Service Registry instances, make sure you've granted necessary permissions to the newly created service account."
msgstr "Una vez que haya conectado su clúster con las instancias de RHOAS Kafka y Service Registry, asegúrese de que ha concedido los permisos necesarios a la cuenta de servicio recién creada."

#. type: Plain text
#: upstream/_guides/kafka.adoc:3165
#, fuzzy
msgid "Then, using the xref:deploying-to-kubernetes.adoc#service_binding[Kubernetes Service Binding] extension, you can configure the Quarkus application to generate `ServiceBinding` resources for those services:"
msgstr "Luego, utilizando la extensión  link:deploying-to-kubernetes.html#service_binding[Kubernetes Service Binding], puede configurar la aplicación Quarkus para generar recursos `ServiceBinding` para esos servicios:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:3169
#, no-wrap
msgid "quarkus.kubernetes-service-binding.detect-binding-resources=true\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:3173
#, no-wrap
msgid ""
"quarkus.kubernetes-service-binding.services.kafka.api-version=rhoas.redhat.com/v1alpha1\n"
"quarkus.kubernetes-service-binding.services.kafka.kind=KafkaConnection\n"
"quarkus.kubernetes-service-binding.services.kafka.name=my-kafka\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:3177
#, no-wrap
msgid ""
"quarkus.kubernetes-service-binding.services.serviceregistry.api-version=rhoas.redhat.com/v1alpha1\n"
"quarkus.kubernetes-service-binding.services.serviceregistry.kind=ServiceRegistryConnection\n"
"quarkus.kubernetes-service-binding.services.serviceregistry.name=my-schema-registry\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:3180
#, fuzzy
msgid "For this example Quarkus build will generate the following `ServiceBinding` resources:"
msgstr "Para este ejemplo, Quarkus generará los siguientes recursos `ServiceBinding`:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:3200
#, no-wrap
msgid ""
"apiVersion: binding.operators.coreos.com/v1alpha1\n"
"kind: ServiceBinding\n"
"metadata:\n"
"  name: my-app-kafka\n"
"spec:\n"
"  application:\n"
"    group: apps.openshift.io\n"
"    name: my-app\n"
"    version: v1\n"
"    kind: DeploymentConfig\n"
"  services:\n"
"    - group: rhoas.redhat.com\n"
"      version: v1alpha1\n"
"      kind: KafkaConnection\n"
"      name: my-kafka\n"
"  detectBindingResources: true\n"
"  bindAsFiles: true\n"
"---\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:3218
#, no-wrap
msgid ""
"apiVersion: binding.operators.coreos.com/v1alpha1\n"
"kind: ServiceBinding\n"
"metadata:\n"
"  name: my-app-serviceregistry\n"
"spec:\n"
"  application:\n"
"    group: apps.openshift.io\n"
"    name: my-app\n"
"    version: v1\n"
"    kind: DeploymentConfig\n"
"  services:\n"
"    - group: rhoas.redhat.com\n"
"      version: v1alpha1\n"
"      kind: ServiceRegistryConnection\n"
"      name: my-schema-registry\n"
"  detectBindingResources: true\n"
"  bindAsFiles: true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:3222
#, fuzzy
msgid "You can follow xref:deploying-to-kubernetes.adoc#openshift[Deploying to OpenShift] to deploy your application, including generated `ServiceBinding` resources.  The configuration properties necessary to access the Kafka and Schema Registry instances will be injected to the application automatically at deployment."
msgstr "Puede seguir el proceso  link:deploying-to-kubernetes.html#openshift[de despliegue en OpenShift] para desplegar su aplicación, incluyendo los recursos generados en `ServiceBinding`. Las propiedades de configuración necesarias para acceder a las instancias de Kafka y Schema Registry se inyectarán en la aplicación automáticamente en el momento del despliegue."

#. type: Title ==
#: upstream/_guides/kafka.adoc:3223
#, fuzzy, no-wrap
msgid "Going further"
msgstr "Ir más allá"

#. type: Plain text
#: upstream/_guides/kafka.adoc:3227
#, fuzzy
msgid "This guide has shown how you can interact with Kafka using Quarkus.  It utilizes SmallRye Reactive Messaging to build data streaming applications."
msgstr "Esta guía ha mostrado cómo puedes interactuar con Kafka usando Quarkus. Utiliza SmallRye Reactive Messaging para construir aplicaciones de flujo de datos."

#. type: Plain text
#: upstream/_guides/kafka.adoc:3228
#, fuzzy
msgid "If you want to go further, check the documentation of https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging], the implementation used in Quarkus."
msgstr "Si quieres ir más allá, consulta la documentación de  link:https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging], la implementación utilizada en Quarkus."

#, fuzzy
#~ msgid "Send the managed instance to Kafka. Make sure we wait for the message to complete before closing the transaction."
#~ msgstr "Enviar la instancia gestionada a Kafka. Asegúrate de que esperamos a que el mensaje se complete antes de cerrar la transacción."

#, fuzzy
#~ msgid "Redpanda does not yet support link:https://github.com/redpanda-data/redpanda/issues/3279[producer scalability for exactly-once processing].  In order to use Kafka exactly-once processing with Quarkus you can configure Dev Services for Kafka to <<kafka-dev-services#configuring-the-image, use Strimzi images instead of Redpanda>>."
#~ msgstr "Redpanda todavía no admite la  link:https://github.com/redpanda-data/redpanda/issues/3279[escalabilidad del productor para] el procesamiento exactamente una vez. Para utilizar el procesamiento exactamente único de Kafka con Quarkus, puede configurar Dev Services for Kafka para que  link:kafka-dev-services.html#configuring-the-image[utilice imágenes Strimzi en lugar de Red]panda."

#, fuzzy
#~ msgid "If you are using Dev Services for Kafka using Redpanda, you need to <<kafka-dev-services.adoc#redpanda-enabling-transactions, enable transactions>>."
#~ msgstr "Si está utilizando Dev Services para Kafka usando Redpanda, necesita  link:kafka-dev-services.html#redpanda-enabling-transactions[habilitar las transacciones]."
